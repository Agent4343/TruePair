
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Photo
 * 
 */
export type Photo = $Result.DefaultSelection<Prisma.$PhotoPayload>
/**
 * Model ProfilePrompt
 * 
 */
export type ProfilePrompt = $Result.DefaultSelection<Prisma.$ProfilePromptPayload>
/**
 * Model OnboardingQuestion
 * 
 */
export type OnboardingQuestion = $Result.DefaultSelection<Prisma.$OnboardingQuestionPayload>
/**
 * Model OnboardingAnswer
 * 
 */
export type OnboardingAnswer = $Result.DefaultSelection<Prisma.$OnboardingAnswerPayload>
/**
 * Model Like
 * 
 */
export type Like = $Result.DefaultSelection<Prisma.$LikePayload>
/**
 * Model Match
 * 
 */
export type Match = $Result.DefaultSelection<Prisma.$MatchPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model TrustScore
 * 
 */
export type TrustScore = $Result.DefaultSelection<Prisma.$TrustScorePayload>
/**
 * Model BehaviorLog
 * 
 */
export type BehaviorLog = $Result.DefaultSelection<Prisma.$BehaviorLogPayload>
/**
 * Model RiskAssessment
 * 
 */
export type RiskAssessment = $Result.DefaultSelection<Prisma.$RiskAssessmentPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model SafetySignal
 * 
 */
export type SafetySignal = $Result.DefaultSelection<Prisma.$SafetySignalPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Block
 * 
 */
export type Block = $Result.DefaultSelection<Prisma.$BlockPayload>
/**
 * Model IntentHistory
 * 
 */
export type IntentHistory = $Result.DefaultSelection<Prisma.$IntentHistoryPayload>
/**
 * Model ScheduledDate
 * 
 */
export type ScheduledDate = $Result.DefaultSelection<Prisma.$ScheduledDatePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  BANNED: 'BANNED',
  DEACTIVATED: 'DEACTIVATED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  NON_BINARY: 'NON_BINARY',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const RelationshipIntent: {
  CASUAL: 'CASUAL',
  SHORT_TERM: 'SHORT_TERM',
  LONG_TERM: 'LONG_TERM',
  MARRIAGE: 'MARRIAGE',
  FIGURING_OUT: 'FIGURING_OUT'
};

export type RelationshipIntent = (typeof RelationshipIntent)[keyof typeof RelationshipIntent]


export const QuestionCategory: {
  VALUES: 'VALUES',
  LIFESTYLE: 'LIFESTYLE',
  RELATIONSHIP_GOALS: 'RELATIONSHIP_GOALS',
  COMMUNICATION: 'COMMUNICATION',
  BEHAVIOR_SCENARIO: 'BEHAVIOR_SCENARIO',
  BOUNDARIES: 'BOUNDARIES',
  COMMITMENT: 'COMMITMENT'
};

export type QuestionCategory = (typeof QuestionCategory)[keyof typeof QuestionCategory]


export const QuestionType: {
  FREE_TEXT: 'FREE_TEXT',
  MULTIPLE_CHOICE: 'MULTIPLE_CHOICE',
  SCALE: 'SCALE',
  RANKING: 'RANKING',
  SCENARIO: 'SCENARIO'
};

export type QuestionType = (typeof QuestionType)[keyof typeof QuestionType]


export const MessageStatus: {
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  READ: 'READ'
};

export type MessageStatus = (typeof MessageStatus)[keyof typeof MessageStatus]


export const BehaviorType: {
  MESSAGE_SENT: 'MESSAGE_SENT',
  MESSAGE_RECEIVED: 'MESSAGE_RECEIVED',
  LIKE_SENT: 'LIKE_SENT',
  LIKE_RECEIVED: 'LIKE_RECEIVED',
  MATCH_CREATED: 'MATCH_CREATED',
  DATE_SCHEDULED: 'DATE_SCHEDULED',
  DATE_COMPLETED: 'DATE_COMPLETED',
  DATE_CANCELLED: 'DATE_CANCELLED',
  REPORT_FILED: 'REPORT_FILED',
  BLOCK_CREATED: 'BLOCK_CREATED',
  PROFILE_UPDATED: 'PROFILE_UPDATED'
};

export type BehaviorType = (typeof BehaviorType)[keyof typeof BehaviorType]


export const RiskLevel: {
  NORMAL: 'NORMAL',
  MONITOR: 'MONITOR',
  RESTRICTED: 'RESTRICTED',
  MANUAL_REVIEW: 'MANUAL_REVIEW'
};

export type RiskLevel = (typeof RiskLevel)[keyof typeof RiskLevel]


export const ReportType: {
  HARASSMENT: 'HARASSMENT',
  INAPPROPRIATE_CONTENT: 'INAPPROPRIATE_CONTENT',
  FAKE_PROFILE: 'FAKE_PROFILE',
  SCAM: 'SCAM',
  THREATS: 'THREATS',
  OTHER: 'OTHER'
};

export type ReportType = (typeof ReportType)[keyof typeof ReportType]


export const ReportStatus: {
  PENDING: 'PENDING',
  REVIEWED: 'REVIEWED',
  RESOLVED: 'RESOLVED',
  DISMISSED: 'DISMISSED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const SafetySignalType: {
  VERIFIED_PHOTO: 'VERIFIED_PHOTO',
  VERIFIED_EMAIL: 'VERIFIED_EMAIL',
  VERIFIED_PHONE: 'VERIFIED_PHONE',
  CONSISTENT_PROFILE: 'CONSISTENT_PROFILE',
  RESPONSIVE_COMMUNICATOR: 'RESPONSIVE_COMMUNICATOR',
  BOUNDARIES_RESPECTED: 'BOUNDARIES_RESPECTED',
  LONG_TERM_USER: 'LONG_TERM_USER'
};

export type SafetySignalType = (typeof SafetySignalType)[keyof typeof SafetySignalType]

}

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type RelationshipIntent = $Enums.RelationshipIntent

export const RelationshipIntent: typeof $Enums.RelationshipIntent

export type QuestionCategory = $Enums.QuestionCategory

export const QuestionCategory: typeof $Enums.QuestionCategory

export type QuestionType = $Enums.QuestionType

export const QuestionType: typeof $Enums.QuestionType

export type MessageStatus = $Enums.MessageStatus

export const MessageStatus: typeof $Enums.MessageStatus

export type BehaviorType = $Enums.BehaviorType

export const BehaviorType: typeof $Enums.BehaviorType

export type RiskLevel = $Enums.RiskLevel

export const RiskLevel: typeof $Enums.RiskLevel

export type ReportType = $Enums.ReportType

export const ReportType: typeof $Enums.ReportType

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type SafetySignalType = $Enums.SafetySignalType

export const SafetySignalType: typeof $Enums.SafetySignalType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.photo`: Exposes CRUD operations for the **Photo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos
    * const photos = await prisma.photo.findMany()
    * ```
    */
  get photo(): Prisma.PhotoDelegate<ExtArgs>;

  /**
   * `prisma.profilePrompt`: Exposes CRUD operations for the **ProfilePrompt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfilePrompts
    * const profilePrompts = await prisma.profilePrompt.findMany()
    * ```
    */
  get profilePrompt(): Prisma.ProfilePromptDelegate<ExtArgs>;

  /**
   * `prisma.onboardingQuestion`: Exposes CRUD operations for the **OnboardingQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OnboardingQuestions
    * const onboardingQuestions = await prisma.onboardingQuestion.findMany()
    * ```
    */
  get onboardingQuestion(): Prisma.OnboardingQuestionDelegate<ExtArgs>;

  /**
   * `prisma.onboardingAnswer`: Exposes CRUD operations for the **OnboardingAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OnboardingAnswers
    * const onboardingAnswers = await prisma.onboardingAnswer.findMany()
    * ```
    */
  get onboardingAnswer(): Prisma.OnboardingAnswerDelegate<ExtArgs>;

  /**
   * `prisma.like`: Exposes CRUD operations for the **Like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.like.findMany()
    * ```
    */
  get like(): Prisma.LikeDelegate<ExtArgs>;

  /**
   * `prisma.match`: Exposes CRUD operations for the **Match** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matches
    * const matches = await prisma.match.findMany()
    * ```
    */
  get match(): Prisma.MatchDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.trustScore`: Exposes CRUD operations for the **TrustScore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrustScores
    * const trustScores = await prisma.trustScore.findMany()
    * ```
    */
  get trustScore(): Prisma.TrustScoreDelegate<ExtArgs>;

  /**
   * `prisma.behaviorLog`: Exposes CRUD operations for the **BehaviorLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BehaviorLogs
    * const behaviorLogs = await prisma.behaviorLog.findMany()
    * ```
    */
  get behaviorLog(): Prisma.BehaviorLogDelegate<ExtArgs>;

  /**
   * `prisma.riskAssessment`: Exposes CRUD operations for the **RiskAssessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskAssessments
    * const riskAssessments = await prisma.riskAssessment.findMany()
    * ```
    */
  get riskAssessment(): Prisma.RiskAssessmentDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.safetySignal`: Exposes CRUD operations for the **SafetySignal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SafetySignals
    * const safetySignals = await prisma.safetySignal.findMany()
    * ```
    */
  get safetySignal(): Prisma.SafetySignalDelegate<ExtArgs>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs>;

  /**
   * `prisma.block`: Exposes CRUD operations for the **Block** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.block.findMany()
    * ```
    */
  get block(): Prisma.BlockDelegate<ExtArgs>;

  /**
   * `prisma.intentHistory`: Exposes CRUD operations for the **IntentHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntentHistories
    * const intentHistories = await prisma.intentHistory.findMany()
    * ```
    */
  get intentHistory(): Prisma.IntentHistoryDelegate<ExtArgs>;

  /**
   * `prisma.scheduledDate`: Exposes CRUD operations for the **ScheduledDate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledDates
    * const scheduledDates = await prisma.scheduledDate.findMany()
    * ```
    */
  get scheduledDate(): Prisma.ScheduledDateDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Profile: 'Profile',
    Photo: 'Photo',
    ProfilePrompt: 'ProfilePrompt',
    OnboardingQuestion: 'OnboardingQuestion',
    OnboardingAnswer: 'OnboardingAnswer',
    Like: 'Like',
    Match: 'Match',
    Message: 'Message',
    TrustScore: 'TrustScore',
    BehaviorLog: 'BehaviorLog',
    RiskAssessment: 'RiskAssessment',
    Report: 'Report',
    SafetySignal: 'SafetySignal',
    Verification: 'Verification',
    Block: 'Block',
    IntentHistory: 'IntentHistory',
    ScheduledDate: 'ScheduledDate'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "profile" | "photo" | "profilePrompt" | "onboardingQuestion" | "onboardingAnswer" | "like" | "match" | "message" | "trustScore" | "behaviorLog" | "riskAssessment" | "report" | "safetySignal" | "verification" | "block" | "intentHistory" | "scheduledDate"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Photo: {
        payload: Prisma.$PhotoPayload<ExtArgs>
        fields: Prisma.PhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          findFirst: {
            args: Prisma.PhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          findMany: {
            args: Prisma.PhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>[]
          }
          create: {
            args: Prisma.PhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          createMany: {
            args: Prisma.PhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>[]
          }
          delete: {
            args: Prisma.PhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          update: {
            args: Prisma.PhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          deleteMany: {
            args: Prisma.PhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          aggregate: {
            args: Prisma.PhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhoto>
          }
          groupBy: {
            args: Prisma.PhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhotoCountArgs<ExtArgs>
            result: $Utils.Optional<PhotoCountAggregateOutputType> | number
          }
        }
      }
      ProfilePrompt: {
        payload: Prisma.$ProfilePromptPayload<ExtArgs>
        fields: Prisma.ProfilePromptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfilePromptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePromptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfilePromptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePromptPayload>
          }
          findFirst: {
            args: Prisma.ProfilePromptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePromptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfilePromptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePromptPayload>
          }
          findMany: {
            args: Prisma.ProfilePromptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePromptPayload>[]
          }
          create: {
            args: Prisma.ProfilePromptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePromptPayload>
          }
          createMany: {
            args: Prisma.ProfilePromptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfilePromptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePromptPayload>[]
          }
          delete: {
            args: Prisma.ProfilePromptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePromptPayload>
          }
          update: {
            args: Prisma.ProfilePromptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePromptPayload>
          }
          deleteMany: {
            args: Prisma.ProfilePromptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfilePromptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfilePromptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePromptPayload>
          }
          aggregate: {
            args: Prisma.ProfilePromptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfilePrompt>
          }
          groupBy: {
            args: Prisma.ProfilePromptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfilePromptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfilePromptCountArgs<ExtArgs>
            result: $Utils.Optional<ProfilePromptCountAggregateOutputType> | number
          }
        }
      }
      OnboardingQuestion: {
        payload: Prisma.$OnboardingQuestionPayload<ExtArgs>
        fields: Prisma.OnboardingQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OnboardingQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OnboardingQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingQuestionPayload>
          }
          findFirst: {
            args: Prisma.OnboardingQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OnboardingQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingQuestionPayload>
          }
          findMany: {
            args: Prisma.OnboardingQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingQuestionPayload>[]
          }
          create: {
            args: Prisma.OnboardingQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingQuestionPayload>
          }
          createMany: {
            args: Prisma.OnboardingQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OnboardingQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingQuestionPayload>[]
          }
          delete: {
            args: Prisma.OnboardingQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingQuestionPayload>
          }
          update: {
            args: Prisma.OnboardingQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingQuestionPayload>
          }
          deleteMany: {
            args: Prisma.OnboardingQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OnboardingQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OnboardingQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingQuestionPayload>
          }
          aggregate: {
            args: Prisma.OnboardingQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOnboardingQuestion>
          }
          groupBy: {
            args: Prisma.OnboardingQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OnboardingQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OnboardingQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<OnboardingQuestionCountAggregateOutputType> | number
          }
        }
      }
      OnboardingAnswer: {
        payload: Prisma.$OnboardingAnswerPayload<ExtArgs>
        fields: Prisma.OnboardingAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OnboardingAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OnboardingAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingAnswerPayload>
          }
          findFirst: {
            args: Prisma.OnboardingAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OnboardingAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingAnswerPayload>
          }
          findMany: {
            args: Prisma.OnboardingAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingAnswerPayload>[]
          }
          create: {
            args: Prisma.OnboardingAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingAnswerPayload>
          }
          createMany: {
            args: Prisma.OnboardingAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OnboardingAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingAnswerPayload>[]
          }
          delete: {
            args: Prisma.OnboardingAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingAnswerPayload>
          }
          update: {
            args: Prisma.OnboardingAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingAnswerPayload>
          }
          deleteMany: {
            args: Prisma.OnboardingAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OnboardingAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OnboardingAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingAnswerPayload>
          }
          aggregate: {
            args: Prisma.OnboardingAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOnboardingAnswer>
          }
          groupBy: {
            args: Prisma.OnboardingAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<OnboardingAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.OnboardingAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<OnboardingAnswerCountAggregateOutputType> | number
          }
        }
      }
      Like: {
        payload: Prisma.$LikePayload<ExtArgs>
        fields: Prisma.LikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findFirst: {
            args: Prisma.LikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findMany: {
            args: Prisma.LikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          create: {
            args: Prisma.LikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          createMany: {
            args: Prisma.LikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          delete: {
            args: Prisma.LikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          update: {
            args: Prisma.LikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          deleteMany: {
            args: Prisma.LikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          aggregate: {
            args: Prisma.LikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLike>
          }
          groupBy: {
            args: Prisma.LikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikeCountArgs<ExtArgs>
            result: $Utils.Optional<LikeCountAggregateOutputType> | number
          }
        }
      }
      Match: {
        payload: Prisma.$MatchPayload<ExtArgs>
        fields: Prisma.MatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findFirst: {
            args: Prisma.MatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findMany: {
            args: Prisma.MatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          create: {
            args: Prisma.MatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          createMany: {
            args: Prisma.MatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          delete: {
            args: Prisma.MatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          update: {
            args: Prisma.MatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          deleteMany: {
            args: Prisma.MatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          aggregate: {
            args: Prisma.MatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatch>
          }
          groupBy: {
            args: Prisma.MatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchCountArgs<ExtArgs>
            result: $Utils.Optional<MatchCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      TrustScore: {
        payload: Prisma.$TrustScorePayload<ExtArgs>
        fields: Prisma.TrustScoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrustScoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrustScoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload>
          }
          findFirst: {
            args: Prisma.TrustScoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrustScoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload>
          }
          findMany: {
            args: Prisma.TrustScoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload>[]
          }
          create: {
            args: Prisma.TrustScoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload>
          }
          createMany: {
            args: Prisma.TrustScoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrustScoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload>[]
          }
          delete: {
            args: Prisma.TrustScoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload>
          }
          update: {
            args: Prisma.TrustScoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload>
          }
          deleteMany: {
            args: Prisma.TrustScoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrustScoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrustScoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScorePayload>
          }
          aggregate: {
            args: Prisma.TrustScoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrustScore>
          }
          groupBy: {
            args: Prisma.TrustScoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrustScoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrustScoreCountArgs<ExtArgs>
            result: $Utils.Optional<TrustScoreCountAggregateOutputType> | number
          }
        }
      }
      BehaviorLog: {
        payload: Prisma.$BehaviorLogPayload<ExtArgs>
        fields: Prisma.BehaviorLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BehaviorLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BehaviorLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorLogPayload>
          }
          findFirst: {
            args: Prisma.BehaviorLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BehaviorLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorLogPayload>
          }
          findMany: {
            args: Prisma.BehaviorLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorLogPayload>[]
          }
          create: {
            args: Prisma.BehaviorLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorLogPayload>
          }
          createMany: {
            args: Prisma.BehaviorLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BehaviorLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorLogPayload>[]
          }
          delete: {
            args: Prisma.BehaviorLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorLogPayload>
          }
          update: {
            args: Prisma.BehaviorLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorLogPayload>
          }
          deleteMany: {
            args: Prisma.BehaviorLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BehaviorLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BehaviorLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorLogPayload>
          }
          aggregate: {
            args: Prisma.BehaviorLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBehaviorLog>
          }
          groupBy: {
            args: Prisma.BehaviorLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BehaviorLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BehaviorLogCountArgs<ExtArgs>
            result: $Utils.Optional<BehaviorLogCountAggregateOutputType> | number
          }
        }
      }
      RiskAssessment: {
        payload: Prisma.$RiskAssessmentPayload<ExtArgs>
        fields: Prisma.RiskAssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskAssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskAssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          findFirst: {
            args: Prisma.RiskAssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskAssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          findMany: {
            args: Prisma.RiskAssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>[]
          }
          create: {
            args: Prisma.RiskAssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          createMany: {
            args: Prisma.RiskAssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskAssessmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>[]
          }
          delete: {
            args: Prisma.RiskAssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          update: {
            args: Prisma.RiskAssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          deleteMany: {
            args: Prisma.RiskAssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskAssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RiskAssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          aggregate: {
            args: Prisma.RiskAssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskAssessment>
          }
          groupBy: {
            args: Prisma.RiskAssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskAssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskAssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<RiskAssessmentCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      SafetySignal: {
        payload: Prisma.$SafetySignalPayload<ExtArgs>
        fields: Prisma.SafetySignalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SafetySignalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetySignalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SafetySignalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetySignalPayload>
          }
          findFirst: {
            args: Prisma.SafetySignalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetySignalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SafetySignalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetySignalPayload>
          }
          findMany: {
            args: Prisma.SafetySignalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetySignalPayload>[]
          }
          create: {
            args: Prisma.SafetySignalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetySignalPayload>
          }
          createMany: {
            args: Prisma.SafetySignalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SafetySignalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetySignalPayload>[]
          }
          delete: {
            args: Prisma.SafetySignalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetySignalPayload>
          }
          update: {
            args: Prisma.SafetySignalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetySignalPayload>
          }
          deleteMany: {
            args: Prisma.SafetySignalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SafetySignalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SafetySignalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetySignalPayload>
          }
          aggregate: {
            args: Prisma.SafetySignalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSafetySignal>
          }
          groupBy: {
            args: Prisma.SafetySignalGroupByArgs<ExtArgs>
            result: $Utils.Optional<SafetySignalGroupByOutputType>[]
          }
          count: {
            args: Prisma.SafetySignalCountArgs<ExtArgs>
            result: $Utils.Optional<SafetySignalCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Block: {
        payload: Prisma.$BlockPayload<ExtArgs>
        fields: Prisma.BlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findFirst: {
            args: Prisma.BlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findMany: {
            args: Prisma.BlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          create: {
            args: Prisma.BlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          createMany: {
            args: Prisma.BlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          delete: {
            args: Prisma.BlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          update: {
            args: Prisma.BlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          deleteMany: {
            args: Prisma.BlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          aggregate: {
            args: Prisma.BlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlock>
          }
          groupBy: {
            args: Prisma.BlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockCountArgs<ExtArgs>
            result: $Utils.Optional<BlockCountAggregateOutputType> | number
          }
        }
      }
      IntentHistory: {
        payload: Prisma.$IntentHistoryPayload<ExtArgs>
        fields: Prisma.IntentHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntentHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntentHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentHistoryPayload>
          }
          findFirst: {
            args: Prisma.IntentHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntentHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentHistoryPayload>
          }
          findMany: {
            args: Prisma.IntentHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentHistoryPayload>[]
          }
          create: {
            args: Prisma.IntentHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentHistoryPayload>
          }
          createMany: {
            args: Prisma.IntentHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntentHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentHistoryPayload>[]
          }
          delete: {
            args: Prisma.IntentHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentHistoryPayload>
          }
          update: {
            args: Prisma.IntentHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentHistoryPayload>
          }
          deleteMany: {
            args: Prisma.IntentHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntentHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntentHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentHistoryPayload>
          }
          aggregate: {
            args: Prisma.IntentHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntentHistory>
          }
          groupBy: {
            args: Prisma.IntentHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntentHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntentHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<IntentHistoryCountAggregateOutputType> | number
          }
        }
      }
      ScheduledDate: {
        payload: Prisma.$ScheduledDatePayload<ExtArgs>
        fields: Prisma.ScheduledDateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledDateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledDatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledDateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledDatePayload>
          }
          findFirst: {
            args: Prisma.ScheduledDateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledDatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledDateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledDatePayload>
          }
          findMany: {
            args: Prisma.ScheduledDateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledDatePayload>[]
          }
          create: {
            args: Prisma.ScheduledDateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledDatePayload>
          }
          createMany: {
            args: Prisma.ScheduledDateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduledDateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledDatePayload>[]
          }
          delete: {
            args: Prisma.ScheduledDateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledDatePayload>
          }
          update: {
            args: Prisma.ScheduledDateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledDatePayload>
          }
          deleteMany: {
            args: Prisma.ScheduledDateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledDateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduledDateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledDatePayload>
          }
          aggregate: {
            args: Prisma.ScheduledDateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduledDate>
          }
          groupBy: {
            args: Prisma.ScheduledDateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduledDateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduledDateCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduledDateCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    onboardingAnswers: number
    likesGiven: number
    likesReceived: number
    matchesAsUserA: number
    matchesAsUserB: number
    messagesSent: number
    messagesReceived: number
    behaviorLogs: number
    reportsFiled: number
    reportsReceived: number
    safetySignals: number
    verifications: number
    intentHistory: number
    blocksCreated: number
    blocksReceived: number
    scheduledDates: number
    datesAsPartner: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    onboardingAnswers?: boolean | UserCountOutputTypeCountOnboardingAnswersArgs
    likesGiven?: boolean | UserCountOutputTypeCountLikesGivenArgs
    likesReceived?: boolean | UserCountOutputTypeCountLikesReceivedArgs
    matchesAsUserA?: boolean | UserCountOutputTypeCountMatchesAsUserAArgs
    matchesAsUserB?: boolean | UserCountOutputTypeCountMatchesAsUserBArgs
    messagesSent?: boolean | UserCountOutputTypeCountMessagesSentArgs
    messagesReceived?: boolean | UserCountOutputTypeCountMessagesReceivedArgs
    behaviorLogs?: boolean | UserCountOutputTypeCountBehaviorLogsArgs
    reportsFiled?: boolean | UserCountOutputTypeCountReportsFiledArgs
    reportsReceived?: boolean | UserCountOutputTypeCountReportsReceivedArgs
    safetySignals?: boolean | UserCountOutputTypeCountSafetySignalsArgs
    verifications?: boolean | UserCountOutputTypeCountVerificationsArgs
    intentHistory?: boolean | UserCountOutputTypeCountIntentHistoryArgs
    blocksCreated?: boolean | UserCountOutputTypeCountBlocksCreatedArgs
    blocksReceived?: boolean | UserCountOutputTypeCountBlocksReceivedArgs
    scheduledDates?: boolean | UserCountOutputTypeCountScheduledDatesArgs
    datesAsPartner?: boolean | UserCountOutputTypeCountDatesAsPartnerArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOnboardingAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnboardingAnswerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikesGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMatchesAsUserAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMatchesAsUserBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBehaviorLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BehaviorLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsFiledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSafetySignalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SafetySignalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIntentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntentHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlocksCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlocksReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountScheduledDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledDateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDatesAsPartnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledDateWhereInput
  }


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    photos: number
    prompts: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | ProfileCountOutputTypeCountPhotosArgs
    prompts?: boolean | ProfileCountOutputTypeCountPromptsArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotoWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountPromptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfilePromptWhereInput
  }


  /**
   * Count Type OnboardingQuestionCountOutputType
   */

  export type OnboardingQuestionCountOutputType = {
    answers: number
  }

  export type OnboardingQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | OnboardingQuestionCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * OnboardingQuestionCountOutputType without action
   */
  export type OnboardingQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingQuestionCountOutputType
     */
    select?: OnboardingQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OnboardingQuestionCountOutputType without action
   */
  export type OnboardingQuestionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnboardingAnswerWhereInput
  }


  /**
   * Count Type MatchCountOutputType
   */

  export type MatchCountOutputType = {
    messages: number
    scheduledDates: number
  }

  export type MatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | MatchCountOutputTypeCountMessagesArgs
    scheduledDates?: boolean | MatchCountOutputTypeCountScheduledDatesArgs
  }

  // Custom InputTypes
  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchCountOutputType
     */
    select?: MatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeCountScheduledDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledDateWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    status: $Enums.UserStatus | null
    onboardingCompleted: boolean | null
    emailVerified: boolean | null
    phoneVerified: boolean | null
    lastActiveAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    status: $Enums.UserStatus | null
    onboardingCompleted: boolean | null
    emailVerified: boolean | null
    phoneVerified: boolean | null
    lastActiveAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    status: number
    onboardingCompleted: number
    emailVerified: number
    phoneVerified: number
    lastActiveAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    status?: true
    onboardingCompleted?: true
    emailVerified?: true
    phoneVerified?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    status?: true
    onboardingCompleted?: true
    emailVerified?: true
    phoneVerified?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    status?: true
    onboardingCompleted?: true
    emailVerified?: true
    phoneVerified?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    status: $Enums.UserStatus
    onboardingCompleted: boolean
    emailVerified: boolean
    phoneVerified: boolean
    lastActiveAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    status?: boolean
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    onboardingAnswers?: boolean | User$onboardingAnswersArgs<ExtArgs>
    likesGiven?: boolean | User$likesGivenArgs<ExtArgs>
    likesReceived?: boolean | User$likesReceivedArgs<ExtArgs>
    matchesAsUserA?: boolean | User$matchesAsUserAArgs<ExtArgs>
    matchesAsUserB?: boolean | User$matchesAsUserBArgs<ExtArgs>
    messagesSent?: boolean | User$messagesSentArgs<ExtArgs>
    messagesReceived?: boolean | User$messagesReceivedArgs<ExtArgs>
    trustScore?: boolean | User$trustScoreArgs<ExtArgs>
    behaviorLogs?: boolean | User$behaviorLogsArgs<ExtArgs>
    riskAssessment?: boolean | User$riskAssessmentArgs<ExtArgs>
    reportsFiled?: boolean | User$reportsFiledArgs<ExtArgs>
    reportsReceived?: boolean | User$reportsReceivedArgs<ExtArgs>
    safetySignals?: boolean | User$safetySignalsArgs<ExtArgs>
    verifications?: boolean | User$verificationsArgs<ExtArgs>
    intentHistory?: boolean | User$intentHistoryArgs<ExtArgs>
    blocksCreated?: boolean | User$blocksCreatedArgs<ExtArgs>
    blocksReceived?: boolean | User$blocksReceivedArgs<ExtArgs>
    scheduledDates?: boolean | User$scheduledDatesArgs<ExtArgs>
    datesAsPartner?: boolean | User$datesAsPartnerArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    status?: boolean
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    status?: boolean
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    onboardingAnswers?: boolean | User$onboardingAnswersArgs<ExtArgs>
    likesGiven?: boolean | User$likesGivenArgs<ExtArgs>
    likesReceived?: boolean | User$likesReceivedArgs<ExtArgs>
    matchesAsUserA?: boolean | User$matchesAsUserAArgs<ExtArgs>
    matchesAsUserB?: boolean | User$matchesAsUserBArgs<ExtArgs>
    messagesSent?: boolean | User$messagesSentArgs<ExtArgs>
    messagesReceived?: boolean | User$messagesReceivedArgs<ExtArgs>
    trustScore?: boolean | User$trustScoreArgs<ExtArgs>
    behaviorLogs?: boolean | User$behaviorLogsArgs<ExtArgs>
    riskAssessment?: boolean | User$riskAssessmentArgs<ExtArgs>
    reportsFiled?: boolean | User$reportsFiledArgs<ExtArgs>
    reportsReceived?: boolean | User$reportsReceivedArgs<ExtArgs>
    safetySignals?: boolean | User$safetySignalsArgs<ExtArgs>
    verifications?: boolean | User$verificationsArgs<ExtArgs>
    intentHistory?: boolean | User$intentHistoryArgs<ExtArgs>
    blocksCreated?: boolean | User$blocksCreatedArgs<ExtArgs>
    blocksReceived?: boolean | User$blocksReceivedArgs<ExtArgs>
    scheduledDates?: boolean | User$scheduledDatesArgs<ExtArgs>
    datesAsPartner?: boolean | User$datesAsPartnerArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      onboardingAnswers: Prisma.$OnboardingAnswerPayload<ExtArgs>[]
      likesGiven: Prisma.$LikePayload<ExtArgs>[]
      likesReceived: Prisma.$LikePayload<ExtArgs>[]
      matchesAsUserA: Prisma.$MatchPayload<ExtArgs>[]
      matchesAsUserB: Prisma.$MatchPayload<ExtArgs>[]
      messagesSent: Prisma.$MessagePayload<ExtArgs>[]
      messagesReceived: Prisma.$MessagePayload<ExtArgs>[]
      trustScore: Prisma.$TrustScorePayload<ExtArgs> | null
      behaviorLogs: Prisma.$BehaviorLogPayload<ExtArgs>[]
      riskAssessment: Prisma.$RiskAssessmentPayload<ExtArgs> | null
      reportsFiled: Prisma.$ReportPayload<ExtArgs>[]
      reportsReceived: Prisma.$ReportPayload<ExtArgs>[]
      safetySignals: Prisma.$SafetySignalPayload<ExtArgs>[]
      verifications: Prisma.$VerificationPayload<ExtArgs>[]
      intentHistory: Prisma.$IntentHistoryPayload<ExtArgs>[]
      blocksCreated: Prisma.$BlockPayload<ExtArgs>[]
      blocksReceived: Prisma.$BlockPayload<ExtArgs>[]
      scheduledDates: Prisma.$ScheduledDatePayload<ExtArgs>[]
      datesAsPartner: Prisma.$ScheduledDatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      status: $Enums.UserStatus
      onboardingCompleted: boolean
      emailVerified: boolean
      phoneVerified: boolean
      lastActiveAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    onboardingAnswers<T extends User$onboardingAnswersArgs<ExtArgs> = {}>(args?: Subset<T, User$onboardingAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    likesGiven<T extends User$likesGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$likesGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany"> | Null>
    likesReceived<T extends User$likesReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$likesReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany"> | Null>
    matchesAsUserA<T extends User$matchesAsUserAArgs<ExtArgs> = {}>(args?: Subset<T, User$matchesAsUserAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany"> | Null>
    matchesAsUserB<T extends User$matchesAsUserBArgs<ExtArgs> = {}>(args?: Subset<T, User$matchesAsUserBArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany"> | Null>
    messagesSent<T extends User$messagesSentArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    messagesReceived<T extends User$messagesReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    trustScore<T extends User$trustScoreArgs<ExtArgs> = {}>(args?: Subset<T, User$trustScoreArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    behaviorLogs<T extends User$behaviorLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$behaviorLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehaviorLogPayload<ExtArgs>, T, "findMany"> | Null>
    riskAssessment<T extends User$riskAssessmentArgs<ExtArgs> = {}>(args?: Subset<T, User$riskAssessmentArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reportsFiled<T extends User$reportsFiledArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsFiledArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    reportsReceived<T extends User$reportsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    safetySignals<T extends User$safetySignalsArgs<ExtArgs> = {}>(args?: Subset<T, User$safetySignalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetySignalPayload<ExtArgs>, T, "findMany"> | Null>
    verifications<T extends User$verificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$verificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany"> | Null>
    intentHistory<T extends User$intentHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$intentHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntentHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    blocksCreated<T extends User$blocksCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$blocksCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany"> | Null>
    blocksReceived<T extends User$blocksReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$blocksReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany"> | Null>
    scheduledDates<T extends User$scheduledDatesArgs<ExtArgs> = {}>(args?: Subset<T, User$scheduledDatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledDatePayload<ExtArgs>, T, "findMany"> | Null>
    datesAsPartner<T extends User$datesAsPartnerArgs<ExtArgs> = {}>(args?: Subset<T, User$datesAsPartnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledDatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly onboardingCompleted: FieldRef<"User", 'Boolean'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly phoneVerified: FieldRef<"User", 'Boolean'>
    readonly lastActiveAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User.onboardingAnswers
   */
  export type User$onboardingAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingAnswer
     */
    select?: OnboardingAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingAnswerInclude<ExtArgs> | null
    where?: OnboardingAnswerWhereInput
    orderBy?: OnboardingAnswerOrderByWithRelationInput | OnboardingAnswerOrderByWithRelationInput[]
    cursor?: OnboardingAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OnboardingAnswerScalarFieldEnum | OnboardingAnswerScalarFieldEnum[]
  }

  /**
   * User.likesGiven
   */
  export type User$likesGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * User.likesReceived
   */
  export type User$likesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * User.matchesAsUserA
   */
  export type User$matchesAsUserAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * User.matchesAsUserB
   */
  export type User$matchesAsUserBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * User.messagesSent
   */
  export type User$messagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.messagesReceived
   */
  export type User$messagesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.trustScore
   */
  export type User$trustScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    where?: TrustScoreWhereInput
  }

  /**
   * User.behaviorLogs
   */
  export type User$behaviorLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorLog
     */
    select?: BehaviorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorLogInclude<ExtArgs> | null
    where?: BehaviorLogWhereInput
    orderBy?: BehaviorLogOrderByWithRelationInput | BehaviorLogOrderByWithRelationInput[]
    cursor?: BehaviorLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BehaviorLogScalarFieldEnum | BehaviorLogScalarFieldEnum[]
  }

  /**
   * User.riskAssessment
   */
  export type User$riskAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    where?: RiskAssessmentWhereInput
  }

  /**
   * User.reportsFiled
   */
  export type User$reportsFiledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.reportsReceived
   */
  export type User$reportsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.safetySignals
   */
  export type User$safetySignalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetySignal
     */
    select?: SafetySignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetySignalInclude<ExtArgs> | null
    where?: SafetySignalWhereInput
    orderBy?: SafetySignalOrderByWithRelationInput | SafetySignalOrderByWithRelationInput[]
    cursor?: SafetySignalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SafetySignalScalarFieldEnum | SafetySignalScalarFieldEnum[]
  }

  /**
   * User.verifications
   */
  export type User$verificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    cursor?: VerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * User.intentHistory
   */
  export type User$intentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentHistory
     */
    select?: IntentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentHistoryInclude<ExtArgs> | null
    where?: IntentHistoryWhereInput
    orderBy?: IntentHistoryOrderByWithRelationInput | IntentHistoryOrderByWithRelationInput[]
    cursor?: IntentHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntentHistoryScalarFieldEnum | IntentHistoryScalarFieldEnum[]
  }

  /**
   * User.blocksCreated
   */
  export type User$blocksCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * User.blocksReceived
   */
  export type User$blocksReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * User.scheduledDates
   */
  export type User$scheduledDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledDate
     */
    select?: ScheduledDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledDateInclude<ExtArgs> | null
    where?: ScheduledDateWhereInput
    orderBy?: ScheduledDateOrderByWithRelationInput | ScheduledDateOrderByWithRelationInput[]
    cursor?: ScheduledDateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledDateScalarFieldEnum | ScheduledDateScalarFieldEnum[]
  }

  /**
   * User.datesAsPartner
   */
  export type User$datesAsPartnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledDate
     */
    select?: ScheduledDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledDateInclude<ExtArgs> | null
    where?: ScheduledDateWhereInput
    orderBy?: ScheduledDateOrderByWithRelationInput | ScheduledDateOrderByWithRelationInput[]
    cursor?: ScheduledDateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledDateScalarFieldEnum | ScheduledDateScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    height: number | null
    profileStrengthScore: number | null
    completenessScore: number | null
    specificityScore: number | null
    consistencyScore: number | null
    stabilityScore: number | null
  }

  export type ProfileSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    height: number | null
    profileStrengthScore: number | null
    completenessScore: number | null
    specificityScore: number | null
    consistencyScore: number | null
    stabilityScore: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    displayName: string | null
    birthDate: Date | null
    gender: $Enums.Gender | null
    city: string | null
    state: string | null
    country: string | null
    latitude: number | null
    longitude: number | null
    bio: string | null
    height: number | null
    relationshipIntent: $Enums.RelationshipIntent | null
    profileStrengthScore: number | null
    completenessScore: number | null
    specificityScore: number | null
    consistencyScore: number | null
    stabilityScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    displayName: string | null
    birthDate: Date | null
    gender: $Enums.Gender | null
    city: string | null
    state: string | null
    country: string | null
    latitude: number | null
    longitude: number | null
    bio: string | null
    height: number | null
    relationshipIntent: $Enums.RelationshipIntent | null
    profileStrengthScore: number | null
    completenessScore: number | null
    specificityScore: number | null
    consistencyScore: number | null
    stabilityScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    displayName: number
    birthDate: number
    gender: number
    genderPreferences: number
    city: number
    state: number
    country: number
    latitude: number
    longitude: number
    bio: number
    height: number
    relationshipIntent: number
    values: number
    lifestyle: number
    dealbreakers: number
    profileStrengthScore: number
    completenessScore: number
    specificityScore: number
    consistencyScore: number
    stabilityScore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    height?: true
    profileStrengthScore?: true
    completenessScore?: true
    specificityScore?: true
    consistencyScore?: true
    stabilityScore?: true
  }

  export type ProfileSumAggregateInputType = {
    latitude?: true
    longitude?: true
    height?: true
    profileStrengthScore?: true
    completenessScore?: true
    specificityScore?: true
    consistencyScore?: true
    stabilityScore?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    displayName?: true
    birthDate?: true
    gender?: true
    city?: true
    state?: true
    country?: true
    latitude?: true
    longitude?: true
    bio?: true
    height?: true
    relationshipIntent?: true
    profileStrengthScore?: true
    completenessScore?: true
    specificityScore?: true
    consistencyScore?: true
    stabilityScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    displayName?: true
    birthDate?: true
    gender?: true
    city?: true
    state?: true
    country?: true
    latitude?: true
    longitude?: true
    bio?: true
    height?: true
    relationshipIntent?: true
    profileStrengthScore?: true
    completenessScore?: true
    specificityScore?: true
    consistencyScore?: true
    stabilityScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    displayName?: true
    birthDate?: true
    gender?: true
    genderPreferences?: true
    city?: true
    state?: true
    country?: true
    latitude?: true
    longitude?: true
    bio?: true
    height?: true
    relationshipIntent?: true
    values?: true
    lifestyle?: true
    dealbreakers?: true
    profileStrengthScore?: true
    completenessScore?: true
    specificityScore?: true
    consistencyScore?: true
    stabilityScore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    firstName: string
    displayName: string | null
    birthDate: Date
    gender: $Enums.Gender
    genderPreferences: $Enums.Gender[]
    city: string | null
    state: string | null
    country: string | null
    latitude: number | null
    longitude: number | null
    bio: string | null
    height: number | null
    relationshipIntent: $Enums.RelationshipIntent | null
    values: JsonValue | null
    lifestyle: JsonValue | null
    dealbreakers: JsonValue | null
    profileStrengthScore: number
    completenessScore: number
    specificityScore: number
    consistencyScore: number
    stabilityScore: number
    createdAt: Date
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    displayName?: boolean
    birthDate?: boolean
    gender?: boolean
    genderPreferences?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    bio?: boolean
    height?: boolean
    relationshipIntent?: boolean
    values?: boolean
    lifestyle?: boolean
    dealbreakers?: boolean
    profileStrengthScore?: boolean
    completenessScore?: boolean
    specificityScore?: boolean
    consistencyScore?: boolean
    stabilityScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    photos?: boolean | Profile$photosArgs<ExtArgs>
    prompts?: boolean | Profile$promptsArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    displayName?: boolean
    birthDate?: boolean
    gender?: boolean
    genderPreferences?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    bio?: boolean
    height?: boolean
    relationshipIntent?: boolean
    values?: boolean
    lifestyle?: boolean
    dealbreakers?: boolean
    profileStrengthScore?: boolean
    completenessScore?: boolean
    specificityScore?: boolean
    consistencyScore?: boolean
    stabilityScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    displayName?: boolean
    birthDate?: boolean
    gender?: boolean
    genderPreferences?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    bio?: boolean
    height?: boolean
    relationshipIntent?: boolean
    values?: boolean
    lifestyle?: boolean
    dealbreakers?: boolean
    profileStrengthScore?: boolean
    completenessScore?: boolean
    specificityScore?: boolean
    consistencyScore?: boolean
    stabilityScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    photos?: boolean | Profile$photosArgs<ExtArgs>
    prompts?: boolean | Profile$promptsArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      photos: Prisma.$PhotoPayload<ExtArgs>[]
      prompts: Prisma.$ProfilePromptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      firstName: string
      displayName: string | null
      birthDate: Date
      gender: $Enums.Gender
      genderPreferences: $Enums.Gender[]
      city: string | null
      state: string | null
      country: string | null
      latitude: number | null
      longitude: number | null
      bio: string | null
      height: number | null
      relationshipIntent: $Enums.RelationshipIntent | null
      values: Prisma.JsonValue | null
      lifestyle: Prisma.JsonValue | null
      dealbreakers: Prisma.JsonValue | null
      profileStrengthScore: number
      completenessScore: number
      specificityScore: number
      consistencyScore: number
      stabilityScore: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    photos<T extends Profile$photosArgs<ExtArgs> = {}>(args?: Subset<T, Profile$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findMany"> | Null>
    prompts<T extends Profile$promptsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$promptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePromptPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly firstName: FieldRef<"Profile", 'String'>
    readonly displayName: FieldRef<"Profile", 'String'>
    readonly birthDate: FieldRef<"Profile", 'DateTime'>
    readonly gender: FieldRef<"Profile", 'Gender'>
    readonly genderPreferences: FieldRef<"Profile", 'Gender[]'>
    readonly city: FieldRef<"Profile", 'String'>
    readonly state: FieldRef<"Profile", 'String'>
    readonly country: FieldRef<"Profile", 'String'>
    readonly latitude: FieldRef<"Profile", 'Float'>
    readonly longitude: FieldRef<"Profile", 'Float'>
    readonly bio: FieldRef<"Profile", 'String'>
    readonly height: FieldRef<"Profile", 'Int'>
    readonly relationshipIntent: FieldRef<"Profile", 'RelationshipIntent'>
    readonly values: FieldRef<"Profile", 'Json'>
    readonly lifestyle: FieldRef<"Profile", 'Json'>
    readonly dealbreakers: FieldRef<"Profile", 'Json'>
    readonly profileStrengthScore: FieldRef<"Profile", 'Int'>
    readonly completenessScore: FieldRef<"Profile", 'Int'>
    readonly specificityScore: FieldRef<"Profile", 'Int'>
    readonly consistencyScore: FieldRef<"Profile", 'Int'>
    readonly stabilityScore: FieldRef<"Profile", 'Int'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile.photos
   */
  export type Profile$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    where?: PhotoWhereInput
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    cursor?: PhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }

  /**
   * Profile.prompts
   */
  export type Profile$promptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePrompt
     */
    select?: ProfilePromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePromptInclude<ExtArgs> | null
    where?: ProfilePromptWhereInput
    orderBy?: ProfilePromptOrderByWithRelationInput | ProfilePromptOrderByWithRelationInput[]
    cursor?: ProfilePromptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfilePromptScalarFieldEnum | ProfilePromptScalarFieldEnum[]
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Photo
   */

  export type AggregatePhoto = {
    _count: PhotoCountAggregateOutputType | null
    _avg: PhotoAvgAggregateOutputType | null
    _sum: PhotoSumAggregateOutputType | null
    _min: PhotoMinAggregateOutputType | null
    _max: PhotoMaxAggregateOutputType | null
  }

  export type PhotoAvgAggregateOutputType = {
    order: number | null
  }

  export type PhotoSumAggregateOutputType = {
    order: number | null
  }

  export type PhotoMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    url: string | null
    isMain: boolean | null
    isVerified: boolean | null
    order: number | null
    createdAt: Date | null
  }

  export type PhotoMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    url: string | null
    isMain: boolean | null
    isVerified: boolean | null
    order: number | null
    createdAt: Date | null
  }

  export type PhotoCountAggregateOutputType = {
    id: number
    profileId: number
    url: number
    isMain: number
    isVerified: number
    order: number
    createdAt: number
    _all: number
  }


  export type PhotoAvgAggregateInputType = {
    order?: true
  }

  export type PhotoSumAggregateInputType = {
    order?: true
  }

  export type PhotoMinAggregateInputType = {
    id?: true
    profileId?: true
    url?: true
    isMain?: true
    isVerified?: true
    order?: true
    createdAt?: true
  }

  export type PhotoMaxAggregateInputType = {
    id?: true
    profileId?: true
    url?: true
    isMain?: true
    isVerified?: true
    order?: true
    createdAt?: true
  }

  export type PhotoCountAggregateInputType = {
    id?: true
    profileId?: true
    url?: true
    isMain?: true
    isVerified?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type PhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Photo to aggregate.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Photos
    **/
    _count?: true | PhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhotoMaxAggregateInputType
  }

  export type GetPhotoAggregateType<T extends PhotoAggregateArgs> = {
        [P in keyof T & keyof AggregatePhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhoto[P]>
      : GetScalarType<T[P], AggregatePhoto[P]>
  }




  export type PhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotoWhereInput
    orderBy?: PhotoOrderByWithAggregationInput | PhotoOrderByWithAggregationInput[]
    by: PhotoScalarFieldEnum[] | PhotoScalarFieldEnum
    having?: PhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhotoCountAggregateInputType | true
    _avg?: PhotoAvgAggregateInputType
    _sum?: PhotoSumAggregateInputType
    _min?: PhotoMinAggregateInputType
    _max?: PhotoMaxAggregateInputType
  }

  export type PhotoGroupByOutputType = {
    id: string
    profileId: string
    url: string
    isMain: boolean
    isVerified: boolean
    order: number
    createdAt: Date
    _count: PhotoCountAggregateOutputType | null
    _avg: PhotoAvgAggregateOutputType | null
    _sum: PhotoSumAggregateOutputType | null
    _min: PhotoMinAggregateOutputType | null
    _max: PhotoMaxAggregateOutputType | null
  }

  type GetPhotoGroupByPayload<T extends PhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhotoGroupByOutputType[P]>
            : GetScalarType<T[P], PhotoGroupByOutputType[P]>
        }
      >
    >


  export type PhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    url?: boolean
    isMain?: boolean
    isVerified?: boolean
    order?: boolean
    createdAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photo"]>

  export type PhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    url?: boolean
    isMain?: boolean
    isVerified?: boolean
    order?: boolean
    createdAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photo"]>

  export type PhotoSelectScalar = {
    id?: boolean
    profileId?: boolean
    url?: boolean
    isMain?: boolean
    isVerified?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type PhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type PhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $PhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Photo"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      url: string
      isMain: boolean
      isVerified: boolean
      order: number
      createdAt: Date
    }, ExtArgs["result"]["photo"]>
    composites: {}
  }

  type PhotoGetPayload<S extends boolean | null | undefined | PhotoDefaultArgs> = $Result.GetResult<Prisma.$PhotoPayload, S>

  type PhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PhotoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PhotoCountAggregateInputType | true
    }

  export interface PhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Photo'], meta: { name: 'Photo' } }
    /**
     * Find zero or one Photo that matches the filter.
     * @param {PhotoFindUniqueArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhotoFindUniqueArgs>(args: SelectSubset<T, PhotoFindUniqueArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Photo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PhotoFindUniqueOrThrowArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, PhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Photo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindFirstArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhotoFindFirstArgs>(args?: SelectSubset<T, PhotoFindFirstArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Photo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindFirstOrThrowArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, PhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Photos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos
     * const photos = await prisma.photo.findMany()
     * 
     * // Get first 10 Photos
     * const photos = await prisma.photo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const photoWithIdOnly = await prisma.photo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhotoFindManyArgs>(args?: SelectSubset<T, PhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Photo.
     * @param {PhotoCreateArgs} args - Arguments to create a Photo.
     * @example
     * // Create one Photo
     * const Photo = await prisma.photo.create({
     *   data: {
     *     // ... data to create a Photo
     *   }
     * })
     * 
     */
    create<T extends PhotoCreateArgs>(args: SelectSubset<T, PhotoCreateArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Photos.
     * @param {PhotoCreateManyArgs} args - Arguments to create many Photos.
     * @example
     * // Create many Photos
     * const photo = await prisma.photo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhotoCreateManyArgs>(args?: SelectSubset<T, PhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Photos and returns the data saved in the database.
     * @param {PhotoCreateManyAndReturnArgs} args - Arguments to create many Photos.
     * @example
     * // Create many Photos
     * const photo = await prisma.photo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Photos and only return the `id`
     * const photoWithIdOnly = await prisma.photo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, PhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Photo.
     * @param {PhotoDeleteArgs} args - Arguments to delete one Photo.
     * @example
     * // Delete one Photo
     * const Photo = await prisma.photo.delete({
     *   where: {
     *     // ... filter to delete one Photo
     *   }
     * })
     * 
     */
    delete<T extends PhotoDeleteArgs>(args: SelectSubset<T, PhotoDeleteArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Photo.
     * @param {PhotoUpdateArgs} args - Arguments to update one Photo.
     * @example
     * // Update one Photo
     * const photo = await prisma.photo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhotoUpdateArgs>(args: SelectSubset<T, PhotoUpdateArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Photos.
     * @param {PhotoDeleteManyArgs} args - Arguments to filter Photos to delete.
     * @example
     * // Delete a few Photos
     * const { count } = await prisma.photo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhotoDeleteManyArgs>(args?: SelectSubset<T, PhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos
     * const photo = await prisma.photo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhotoUpdateManyArgs>(args: SelectSubset<T, PhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photo.
     * @param {PhotoUpsertArgs} args - Arguments to update or create a Photo.
     * @example
     * // Update or create a Photo
     * const photo = await prisma.photo.upsert({
     *   create: {
     *     // ... data to create a Photo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photo we want to update
     *   }
     * })
     */
    upsert<T extends PhotoUpsertArgs>(args: SelectSubset<T, PhotoUpsertArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoCountArgs} args - Arguments to filter Photos to count.
     * @example
     * // Count the number of Photos
     * const count = await prisma.photo.count({
     *   where: {
     *     // ... the filter for the Photos we want to count
     *   }
     * })
    **/
    count<T extends PhotoCountArgs>(
      args?: Subset<T, PhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhotoAggregateArgs>(args: Subset<T, PhotoAggregateArgs>): Prisma.PrismaPromise<GetPhotoAggregateType<T>>

    /**
     * Group by Photo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhotoGroupByArgs['orderBy'] }
        : { orderBy?: PhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Photo model
   */
  readonly fields: PhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Photo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Photo model
   */ 
  interface PhotoFieldRefs {
    readonly id: FieldRef<"Photo", 'String'>
    readonly profileId: FieldRef<"Photo", 'String'>
    readonly url: FieldRef<"Photo", 'String'>
    readonly isMain: FieldRef<"Photo", 'Boolean'>
    readonly isVerified: FieldRef<"Photo", 'Boolean'>
    readonly order: FieldRef<"Photo", 'Int'>
    readonly createdAt: FieldRef<"Photo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Photo findUnique
   */
  export type PhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where: PhotoWhereUniqueInput
  }

  /**
   * Photo findUniqueOrThrow
   */
  export type PhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where: PhotoWhereUniqueInput
  }

  /**
   * Photo findFirst
   */
  export type PhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Photos.
     */
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }

  /**
   * Photo findFirstOrThrow
   */
  export type PhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Photos.
     */
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }

  /**
   * Photo findMany
   */
  export type PhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photos to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }

  /**
   * Photo create
   */
  export type PhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a Photo.
     */
    data: XOR<PhotoCreateInput, PhotoUncheckedCreateInput>
  }

  /**
   * Photo createMany
   */
  export type PhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Photos.
     */
    data: PhotoCreateManyInput | PhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Photo createManyAndReturn
   */
  export type PhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Photos.
     */
    data: PhotoCreateManyInput | PhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Photo update
   */
  export type PhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a Photo.
     */
    data: XOR<PhotoUpdateInput, PhotoUncheckedUpdateInput>
    /**
     * Choose, which Photo to update.
     */
    where: PhotoWhereUniqueInput
  }

  /**
   * Photo updateMany
   */
  export type PhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Photos.
     */
    data: XOR<PhotoUpdateManyMutationInput, PhotoUncheckedUpdateManyInput>
    /**
     * Filter which Photos to update
     */
    where?: PhotoWhereInput
  }

  /**
   * Photo upsert
   */
  export type PhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the Photo to update in case it exists.
     */
    where: PhotoWhereUniqueInput
    /**
     * In case the Photo found by the `where` argument doesn't exist, create a new Photo with this data.
     */
    create: XOR<PhotoCreateInput, PhotoUncheckedCreateInput>
    /**
     * In case the Photo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhotoUpdateInput, PhotoUncheckedUpdateInput>
  }

  /**
   * Photo delete
   */
  export type PhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter which Photo to delete.
     */
    where: PhotoWhereUniqueInput
  }

  /**
   * Photo deleteMany
   */
  export type PhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Photos to delete
     */
    where?: PhotoWhereInput
  }

  /**
   * Photo without action
   */
  export type PhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
  }


  /**
   * Model ProfilePrompt
   */

  export type AggregateProfilePrompt = {
    _count: ProfilePromptCountAggregateOutputType | null
    _avg: ProfilePromptAvgAggregateOutputType | null
    _sum: ProfilePromptSumAggregateOutputType | null
    _min: ProfilePromptMinAggregateOutputType | null
    _max: ProfilePromptMaxAggregateOutputType | null
  }

  export type ProfilePromptAvgAggregateOutputType = {
    order: number | null
  }

  export type ProfilePromptSumAggregateOutputType = {
    order: number | null
  }

  export type ProfilePromptMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    question: string | null
    answer: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfilePromptMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    question: string | null
    answer: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfilePromptCountAggregateOutputType = {
    id: number
    profileId: number
    question: number
    answer: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfilePromptAvgAggregateInputType = {
    order?: true
  }

  export type ProfilePromptSumAggregateInputType = {
    order?: true
  }

  export type ProfilePromptMinAggregateInputType = {
    id?: true
    profileId?: true
    question?: true
    answer?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfilePromptMaxAggregateInputType = {
    id?: true
    profileId?: true
    question?: true
    answer?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfilePromptCountAggregateInputType = {
    id?: true
    profileId?: true
    question?: true
    answer?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfilePromptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfilePrompt to aggregate.
     */
    where?: ProfilePromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfilePrompts to fetch.
     */
    orderBy?: ProfilePromptOrderByWithRelationInput | ProfilePromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfilePromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfilePrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfilePrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfilePrompts
    **/
    _count?: true | ProfilePromptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfilePromptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfilePromptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfilePromptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfilePromptMaxAggregateInputType
  }

  export type GetProfilePromptAggregateType<T extends ProfilePromptAggregateArgs> = {
        [P in keyof T & keyof AggregateProfilePrompt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfilePrompt[P]>
      : GetScalarType<T[P], AggregateProfilePrompt[P]>
  }




  export type ProfilePromptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfilePromptWhereInput
    orderBy?: ProfilePromptOrderByWithAggregationInput | ProfilePromptOrderByWithAggregationInput[]
    by: ProfilePromptScalarFieldEnum[] | ProfilePromptScalarFieldEnum
    having?: ProfilePromptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfilePromptCountAggregateInputType | true
    _avg?: ProfilePromptAvgAggregateInputType
    _sum?: ProfilePromptSumAggregateInputType
    _min?: ProfilePromptMinAggregateInputType
    _max?: ProfilePromptMaxAggregateInputType
  }

  export type ProfilePromptGroupByOutputType = {
    id: string
    profileId: string
    question: string
    answer: string
    order: number
    createdAt: Date
    updatedAt: Date
    _count: ProfilePromptCountAggregateOutputType | null
    _avg: ProfilePromptAvgAggregateOutputType | null
    _sum: ProfilePromptSumAggregateOutputType | null
    _min: ProfilePromptMinAggregateOutputType | null
    _max: ProfilePromptMaxAggregateOutputType | null
  }

  type GetProfilePromptGroupByPayload<T extends ProfilePromptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfilePromptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfilePromptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfilePromptGroupByOutputType[P]>
            : GetScalarType<T[P], ProfilePromptGroupByOutputType[P]>
        }
      >
    >


  export type ProfilePromptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    question?: boolean
    answer?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profilePrompt"]>

  export type ProfilePromptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    question?: boolean
    answer?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profilePrompt"]>

  export type ProfilePromptSelectScalar = {
    id?: boolean
    profileId?: boolean
    question?: boolean
    answer?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfilePromptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ProfilePromptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ProfilePromptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfilePrompt"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      question: string
      answer: string
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profilePrompt"]>
    composites: {}
  }

  type ProfilePromptGetPayload<S extends boolean | null | undefined | ProfilePromptDefaultArgs> = $Result.GetResult<Prisma.$ProfilePromptPayload, S>

  type ProfilePromptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfilePromptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfilePromptCountAggregateInputType | true
    }

  export interface ProfilePromptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfilePrompt'], meta: { name: 'ProfilePrompt' } }
    /**
     * Find zero or one ProfilePrompt that matches the filter.
     * @param {ProfilePromptFindUniqueArgs} args - Arguments to find a ProfilePrompt
     * @example
     * // Get one ProfilePrompt
     * const profilePrompt = await prisma.profilePrompt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfilePromptFindUniqueArgs>(args: SelectSubset<T, ProfilePromptFindUniqueArgs<ExtArgs>>): Prisma__ProfilePromptClient<$Result.GetResult<Prisma.$ProfilePromptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProfilePrompt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfilePromptFindUniqueOrThrowArgs} args - Arguments to find a ProfilePrompt
     * @example
     * // Get one ProfilePrompt
     * const profilePrompt = await prisma.profilePrompt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfilePromptFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfilePromptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfilePromptClient<$Result.GetResult<Prisma.$ProfilePromptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProfilePrompt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilePromptFindFirstArgs} args - Arguments to find a ProfilePrompt
     * @example
     * // Get one ProfilePrompt
     * const profilePrompt = await prisma.profilePrompt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfilePromptFindFirstArgs>(args?: SelectSubset<T, ProfilePromptFindFirstArgs<ExtArgs>>): Prisma__ProfilePromptClient<$Result.GetResult<Prisma.$ProfilePromptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProfilePrompt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilePromptFindFirstOrThrowArgs} args - Arguments to find a ProfilePrompt
     * @example
     * // Get one ProfilePrompt
     * const profilePrompt = await prisma.profilePrompt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfilePromptFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfilePromptFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfilePromptClient<$Result.GetResult<Prisma.$ProfilePromptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProfilePrompts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilePromptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfilePrompts
     * const profilePrompts = await prisma.profilePrompt.findMany()
     * 
     * // Get first 10 ProfilePrompts
     * const profilePrompts = await prisma.profilePrompt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profilePromptWithIdOnly = await prisma.profilePrompt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfilePromptFindManyArgs>(args?: SelectSubset<T, ProfilePromptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePromptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProfilePrompt.
     * @param {ProfilePromptCreateArgs} args - Arguments to create a ProfilePrompt.
     * @example
     * // Create one ProfilePrompt
     * const ProfilePrompt = await prisma.profilePrompt.create({
     *   data: {
     *     // ... data to create a ProfilePrompt
     *   }
     * })
     * 
     */
    create<T extends ProfilePromptCreateArgs>(args: SelectSubset<T, ProfilePromptCreateArgs<ExtArgs>>): Prisma__ProfilePromptClient<$Result.GetResult<Prisma.$ProfilePromptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProfilePrompts.
     * @param {ProfilePromptCreateManyArgs} args - Arguments to create many ProfilePrompts.
     * @example
     * // Create many ProfilePrompts
     * const profilePrompt = await prisma.profilePrompt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfilePromptCreateManyArgs>(args?: SelectSubset<T, ProfilePromptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfilePrompts and returns the data saved in the database.
     * @param {ProfilePromptCreateManyAndReturnArgs} args - Arguments to create many ProfilePrompts.
     * @example
     * // Create many ProfilePrompts
     * const profilePrompt = await prisma.profilePrompt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfilePrompts and only return the `id`
     * const profilePromptWithIdOnly = await prisma.profilePrompt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfilePromptCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfilePromptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePromptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProfilePrompt.
     * @param {ProfilePromptDeleteArgs} args - Arguments to delete one ProfilePrompt.
     * @example
     * // Delete one ProfilePrompt
     * const ProfilePrompt = await prisma.profilePrompt.delete({
     *   where: {
     *     // ... filter to delete one ProfilePrompt
     *   }
     * })
     * 
     */
    delete<T extends ProfilePromptDeleteArgs>(args: SelectSubset<T, ProfilePromptDeleteArgs<ExtArgs>>): Prisma__ProfilePromptClient<$Result.GetResult<Prisma.$ProfilePromptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProfilePrompt.
     * @param {ProfilePromptUpdateArgs} args - Arguments to update one ProfilePrompt.
     * @example
     * // Update one ProfilePrompt
     * const profilePrompt = await prisma.profilePrompt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfilePromptUpdateArgs>(args: SelectSubset<T, ProfilePromptUpdateArgs<ExtArgs>>): Prisma__ProfilePromptClient<$Result.GetResult<Prisma.$ProfilePromptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProfilePrompts.
     * @param {ProfilePromptDeleteManyArgs} args - Arguments to filter ProfilePrompts to delete.
     * @example
     * // Delete a few ProfilePrompts
     * const { count } = await prisma.profilePrompt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfilePromptDeleteManyArgs>(args?: SelectSubset<T, ProfilePromptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfilePrompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilePromptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfilePrompts
     * const profilePrompt = await prisma.profilePrompt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfilePromptUpdateManyArgs>(args: SelectSubset<T, ProfilePromptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfilePrompt.
     * @param {ProfilePromptUpsertArgs} args - Arguments to update or create a ProfilePrompt.
     * @example
     * // Update or create a ProfilePrompt
     * const profilePrompt = await prisma.profilePrompt.upsert({
     *   create: {
     *     // ... data to create a ProfilePrompt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfilePrompt we want to update
     *   }
     * })
     */
    upsert<T extends ProfilePromptUpsertArgs>(args: SelectSubset<T, ProfilePromptUpsertArgs<ExtArgs>>): Prisma__ProfilePromptClient<$Result.GetResult<Prisma.$ProfilePromptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProfilePrompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilePromptCountArgs} args - Arguments to filter ProfilePrompts to count.
     * @example
     * // Count the number of ProfilePrompts
     * const count = await prisma.profilePrompt.count({
     *   where: {
     *     // ... the filter for the ProfilePrompts we want to count
     *   }
     * })
    **/
    count<T extends ProfilePromptCountArgs>(
      args?: Subset<T, ProfilePromptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfilePromptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfilePrompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilePromptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfilePromptAggregateArgs>(args: Subset<T, ProfilePromptAggregateArgs>): Prisma.PrismaPromise<GetProfilePromptAggregateType<T>>

    /**
     * Group by ProfilePrompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilePromptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfilePromptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfilePromptGroupByArgs['orderBy'] }
        : { orderBy?: ProfilePromptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfilePromptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfilePromptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfilePrompt model
   */
  readonly fields: ProfilePromptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfilePrompt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfilePromptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfilePrompt model
   */ 
  interface ProfilePromptFieldRefs {
    readonly id: FieldRef<"ProfilePrompt", 'String'>
    readonly profileId: FieldRef<"ProfilePrompt", 'String'>
    readonly question: FieldRef<"ProfilePrompt", 'String'>
    readonly answer: FieldRef<"ProfilePrompt", 'String'>
    readonly order: FieldRef<"ProfilePrompt", 'Int'>
    readonly createdAt: FieldRef<"ProfilePrompt", 'DateTime'>
    readonly updatedAt: FieldRef<"ProfilePrompt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfilePrompt findUnique
   */
  export type ProfilePromptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePrompt
     */
    select?: ProfilePromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePromptInclude<ExtArgs> | null
    /**
     * Filter, which ProfilePrompt to fetch.
     */
    where: ProfilePromptWhereUniqueInput
  }

  /**
   * ProfilePrompt findUniqueOrThrow
   */
  export type ProfilePromptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePrompt
     */
    select?: ProfilePromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePromptInclude<ExtArgs> | null
    /**
     * Filter, which ProfilePrompt to fetch.
     */
    where: ProfilePromptWhereUniqueInput
  }

  /**
   * ProfilePrompt findFirst
   */
  export type ProfilePromptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePrompt
     */
    select?: ProfilePromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePromptInclude<ExtArgs> | null
    /**
     * Filter, which ProfilePrompt to fetch.
     */
    where?: ProfilePromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfilePrompts to fetch.
     */
    orderBy?: ProfilePromptOrderByWithRelationInput | ProfilePromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfilePrompts.
     */
    cursor?: ProfilePromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfilePrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfilePrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfilePrompts.
     */
    distinct?: ProfilePromptScalarFieldEnum | ProfilePromptScalarFieldEnum[]
  }

  /**
   * ProfilePrompt findFirstOrThrow
   */
  export type ProfilePromptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePrompt
     */
    select?: ProfilePromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePromptInclude<ExtArgs> | null
    /**
     * Filter, which ProfilePrompt to fetch.
     */
    where?: ProfilePromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfilePrompts to fetch.
     */
    orderBy?: ProfilePromptOrderByWithRelationInput | ProfilePromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfilePrompts.
     */
    cursor?: ProfilePromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfilePrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfilePrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfilePrompts.
     */
    distinct?: ProfilePromptScalarFieldEnum | ProfilePromptScalarFieldEnum[]
  }

  /**
   * ProfilePrompt findMany
   */
  export type ProfilePromptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePrompt
     */
    select?: ProfilePromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePromptInclude<ExtArgs> | null
    /**
     * Filter, which ProfilePrompts to fetch.
     */
    where?: ProfilePromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfilePrompts to fetch.
     */
    orderBy?: ProfilePromptOrderByWithRelationInput | ProfilePromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfilePrompts.
     */
    cursor?: ProfilePromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfilePrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfilePrompts.
     */
    skip?: number
    distinct?: ProfilePromptScalarFieldEnum | ProfilePromptScalarFieldEnum[]
  }

  /**
   * ProfilePrompt create
   */
  export type ProfilePromptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePrompt
     */
    select?: ProfilePromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePromptInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfilePrompt.
     */
    data: XOR<ProfilePromptCreateInput, ProfilePromptUncheckedCreateInput>
  }

  /**
   * ProfilePrompt createMany
   */
  export type ProfilePromptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfilePrompts.
     */
    data: ProfilePromptCreateManyInput | ProfilePromptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfilePrompt createManyAndReturn
   */
  export type ProfilePromptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePrompt
     */
    select?: ProfilePromptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProfilePrompts.
     */
    data: ProfilePromptCreateManyInput | ProfilePromptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePromptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfilePrompt update
   */
  export type ProfilePromptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePrompt
     */
    select?: ProfilePromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePromptInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfilePrompt.
     */
    data: XOR<ProfilePromptUpdateInput, ProfilePromptUncheckedUpdateInput>
    /**
     * Choose, which ProfilePrompt to update.
     */
    where: ProfilePromptWhereUniqueInput
  }

  /**
   * ProfilePrompt updateMany
   */
  export type ProfilePromptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfilePrompts.
     */
    data: XOR<ProfilePromptUpdateManyMutationInput, ProfilePromptUncheckedUpdateManyInput>
    /**
     * Filter which ProfilePrompts to update
     */
    where?: ProfilePromptWhereInput
  }

  /**
   * ProfilePrompt upsert
   */
  export type ProfilePromptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePrompt
     */
    select?: ProfilePromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePromptInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfilePrompt to update in case it exists.
     */
    where: ProfilePromptWhereUniqueInput
    /**
     * In case the ProfilePrompt found by the `where` argument doesn't exist, create a new ProfilePrompt with this data.
     */
    create: XOR<ProfilePromptCreateInput, ProfilePromptUncheckedCreateInput>
    /**
     * In case the ProfilePrompt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfilePromptUpdateInput, ProfilePromptUncheckedUpdateInput>
  }

  /**
   * ProfilePrompt delete
   */
  export type ProfilePromptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePrompt
     */
    select?: ProfilePromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePromptInclude<ExtArgs> | null
    /**
     * Filter which ProfilePrompt to delete.
     */
    where: ProfilePromptWhereUniqueInput
  }

  /**
   * ProfilePrompt deleteMany
   */
  export type ProfilePromptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfilePrompts to delete
     */
    where?: ProfilePromptWhereInput
  }

  /**
   * ProfilePrompt without action
   */
  export type ProfilePromptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilePrompt
     */
    select?: ProfilePromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilePromptInclude<ExtArgs> | null
  }


  /**
   * Model OnboardingQuestion
   */

  export type AggregateOnboardingQuestion = {
    _count: OnboardingQuestionCountAggregateOutputType | null
    _avg: OnboardingQuestionAvgAggregateOutputType | null
    _sum: OnboardingQuestionSumAggregateOutputType | null
    _min: OnboardingQuestionMinAggregateOutputType | null
    _max: OnboardingQuestionMaxAggregateOutputType | null
  }

  export type OnboardingQuestionAvgAggregateOutputType = {
    order: number | null
  }

  export type OnboardingQuestionSumAggregateOutputType = {
    order: number | null
  }

  export type OnboardingQuestionMinAggregateOutputType = {
    id: string | null
    category: $Enums.QuestionCategory | null
    questionText: string | null
    questionType: $Enums.QuestionType | null
    order: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type OnboardingQuestionMaxAggregateOutputType = {
    id: string | null
    category: $Enums.QuestionCategory | null
    questionText: string | null
    questionType: $Enums.QuestionType | null
    order: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type OnboardingQuestionCountAggregateOutputType = {
    id: number
    category: number
    questionText: number
    questionType: number
    options: number
    followUpLogic: number
    order: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type OnboardingQuestionAvgAggregateInputType = {
    order?: true
  }

  export type OnboardingQuestionSumAggregateInputType = {
    order?: true
  }

  export type OnboardingQuestionMinAggregateInputType = {
    id?: true
    category?: true
    questionText?: true
    questionType?: true
    order?: true
    isActive?: true
    createdAt?: true
  }

  export type OnboardingQuestionMaxAggregateInputType = {
    id?: true
    category?: true
    questionText?: true
    questionType?: true
    order?: true
    isActive?: true
    createdAt?: true
  }

  export type OnboardingQuestionCountAggregateInputType = {
    id?: true
    category?: true
    questionText?: true
    questionType?: true
    options?: true
    followUpLogic?: true
    order?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type OnboardingQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnboardingQuestion to aggregate.
     */
    where?: OnboardingQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingQuestions to fetch.
     */
    orderBy?: OnboardingQuestionOrderByWithRelationInput | OnboardingQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OnboardingQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OnboardingQuestions
    **/
    _count?: true | OnboardingQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OnboardingQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OnboardingQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OnboardingQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OnboardingQuestionMaxAggregateInputType
  }

  export type GetOnboardingQuestionAggregateType<T extends OnboardingQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateOnboardingQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOnboardingQuestion[P]>
      : GetScalarType<T[P], AggregateOnboardingQuestion[P]>
  }




  export type OnboardingQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnboardingQuestionWhereInput
    orderBy?: OnboardingQuestionOrderByWithAggregationInput | OnboardingQuestionOrderByWithAggregationInput[]
    by: OnboardingQuestionScalarFieldEnum[] | OnboardingQuestionScalarFieldEnum
    having?: OnboardingQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OnboardingQuestionCountAggregateInputType | true
    _avg?: OnboardingQuestionAvgAggregateInputType
    _sum?: OnboardingQuestionSumAggregateInputType
    _min?: OnboardingQuestionMinAggregateInputType
    _max?: OnboardingQuestionMaxAggregateInputType
  }

  export type OnboardingQuestionGroupByOutputType = {
    id: string
    category: $Enums.QuestionCategory
    questionText: string
    questionType: $Enums.QuestionType
    options: JsonValue | null
    followUpLogic: JsonValue | null
    order: number
    isActive: boolean
    createdAt: Date
    _count: OnboardingQuestionCountAggregateOutputType | null
    _avg: OnboardingQuestionAvgAggregateOutputType | null
    _sum: OnboardingQuestionSumAggregateOutputType | null
    _min: OnboardingQuestionMinAggregateOutputType | null
    _max: OnboardingQuestionMaxAggregateOutputType | null
  }

  type GetOnboardingQuestionGroupByPayload<T extends OnboardingQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OnboardingQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OnboardingQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OnboardingQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], OnboardingQuestionGroupByOutputType[P]>
        }
      >
    >


  export type OnboardingQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    questionText?: boolean
    questionType?: boolean
    options?: boolean
    followUpLogic?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    answers?: boolean | OnboardingQuestion$answersArgs<ExtArgs>
    _count?: boolean | OnboardingQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingQuestion"]>

  export type OnboardingQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    questionText?: boolean
    questionType?: boolean
    options?: boolean
    followUpLogic?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["onboardingQuestion"]>

  export type OnboardingQuestionSelectScalar = {
    id?: boolean
    category?: boolean
    questionText?: boolean
    questionType?: boolean
    options?: boolean
    followUpLogic?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type OnboardingQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | OnboardingQuestion$answersArgs<ExtArgs>
    _count?: boolean | OnboardingQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OnboardingQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OnboardingQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OnboardingQuestion"
    objects: {
      answers: Prisma.$OnboardingAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: $Enums.QuestionCategory
      questionText: string
      questionType: $Enums.QuestionType
      options: Prisma.JsonValue | null
      followUpLogic: Prisma.JsonValue | null
      order: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["onboardingQuestion"]>
    composites: {}
  }

  type OnboardingQuestionGetPayload<S extends boolean | null | undefined | OnboardingQuestionDefaultArgs> = $Result.GetResult<Prisma.$OnboardingQuestionPayload, S>

  type OnboardingQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OnboardingQuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OnboardingQuestionCountAggregateInputType | true
    }

  export interface OnboardingQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OnboardingQuestion'], meta: { name: 'OnboardingQuestion' } }
    /**
     * Find zero or one OnboardingQuestion that matches the filter.
     * @param {OnboardingQuestionFindUniqueArgs} args - Arguments to find a OnboardingQuestion
     * @example
     * // Get one OnboardingQuestion
     * const onboardingQuestion = await prisma.onboardingQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OnboardingQuestionFindUniqueArgs>(args: SelectSubset<T, OnboardingQuestionFindUniqueArgs<ExtArgs>>): Prisma__OnboardingQuestionClient<$Result.GetResult<Prisma.$OnboardingQuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OnboardingQuestion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OnboardingQuestionFindUniqueOrThrowArgs} args - Arguments to find a OnboardingQuestion
     * @example
     * // Get one OnboardingQuestion
     * const onboardingQuestion = await prisma.onboardingQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OnboardingQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, OnboardingQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OnboardingQuestionClient<$Result.GetResult<Prisma.$OnboardingQuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OnboardingQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingQuestionFindFirstArgs} args - Arguments to find a OnboardingQuestion
     * @example
     * // Get one OnboardingQuestion
     * const onboardingQuestion = await prisma.onboardingQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OnboardingQuestionFindFirstArgs>(args?: SelectSubset<T, OnboardingQuestionFindFirstArgs<ExtArgs>>): Prisma__OnboardingQuestionClient<$Result.GetResult<Prisma.$OnboardingQuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OnboardingQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingQuestionFindFirstOrThrowArgs} args - Arguments to find a OnboardingQuestion
     * @example
     * // Get one OnboardingQuestion
     * const onboardingQuestion = await prisma.onboardingQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OnboardingQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, OnboardingQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__OnboardingQuestionClient<$Result.GetResult<Prisma.$OnboardingQuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OnboardingQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OnboardingQuestions
     * const onboardingQuestions = await prisma.onboardingQuestion.findMany()
     * 
     * // Get first 10 OnboardingQuestions
     * const onboardingQuestions = await prisma.onboardingQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const onboardingQuestionWithIdOnly = await prisma.onboardingQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OnboardingQuestionFindManyArgs>(args?: SelectSubset<T, OnboardingQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingQuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OnboardingQuestion.
     * @param {OnboardingQuestionCreateArgs} args - Arguments to create a OnboardingQuestion.
     * @example
     * // Create one OnboardingQuestion
     * const OnboardingQuestion = await prisma.onboardingQuestion.create({
     *   data: {
     *     // ... data to create a OnboardingQuestion
     *   }
     * })
     * 
     */
    create<T extends OnboardingQuestionCreateArgs>(args: SelectSubset<T, OnboardingQuestionCreateArgs<ExtArgs>>): Prisma__OnboardingQuestionClient<$Result.GetResult<Prisma.$OnboardingQuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OnboardingQuestions.
     * @param {OnboardingQuestionCreateManyArgs} args - Arguments to create many OnboardingQuestions.
     * @example
     * // Create many OnboardingQuestions
     * const onboardingQuestion = await prisma.onboardingQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OnboardingQuestionCreateManyArgs>(args?: SelectSubset<T, OnboardingQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OnboardingQuestions and returns the data saved in the database.
     * @param {OnboardingQuestionCreateManyAndReturnArgs} args - Arguments to create many OnboardingQuestions.
     * @example
     * // Create many OnboardingQuestions
     * const onboardingQuestion = await prisma.onboardingQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OnboardingQuestions and only return the `id`
     * const onboardingQuestionWithIdOnly = await prisma.onboardingQuestion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OnboardingQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, OnboardingQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingQuestionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OnboardingQuestion.
     * @param {OnboardingQuestionDeleteArgs} args - Arguments to delete one OnboardingQuestion.
     * @example
     * // Delete one OnboardingQuestion
     * const OnboardingQuestion = await prisma.onboardingQuestion.delete({
     *   where: {
     *     // ... filter to delete one OnboardingQuestion
     *   }
     * })
     * 
     */
    delete<T extends OnboardingQuestionDeleteArgs>(args: SelectSubset<T, OnboardingQuestionDeleteArgs<ExtArgs>>): Prisma__OnboardingQuestionClient<$Result.GetResult<Prisma.$OnboardingQuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OnboardingQuestion.
     * @param {OnboardingQuestionUpdateArgs} args - Arguments to update one OnboardingQuestion.
     * @example
     * // Update one OnboardingQuestion
     * const onboardingQuestion = await prisma.onboardingQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OnboardingQuestionUpdateArgs>(args: SelectSubset<T, OnboardingQuestionUpdateArgs<ExtArgs>>): Prisma__OnboardingQuestionClient<$Result.GetResult<Prisma.$OnboardingQuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OnboardingQuestions.
     * @param {OnboardingQuestionDeleteManyArgs} args - Arguments to filter OnboardingQuestions to delete.
     * @example
     * // Delete a few OnboardingQuestions
     * const { count } = await prisma.onboardingQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OnboardingQuestionDeleteManyArgs>(args?: SelectSubset<T, OnboardingQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnboardingQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OnboardingQuestions
     * const onboardingQuestion = await prisma.onboardingQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OnboardingQuestionUpdateManyArgs>(args: SelectSubset<T, OnboardingQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OnboardingQuestion.
     * @param {OnboardingQuestionUpsertArgs} args - Arguments to update or create a OnboardingQuestion.
     * @example
     * // Update or create a OnboardingQuestion
     * const onboardingQuestion = await prisma.onboardingQuestion.upsert({
     *   create: {
     *     // ... data to create a OnboardingQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OnboardingQuestion we want to update
     *   }
     * })
     */
    upsert<T extends OnboardingQuestionUpsertArgs>(args: SelectSubset<T, OnboardingQuestionUpsertArgs<ExtArgs>>): Prisma__OnboardingQuestionClient<$Result.GetResult<Prisma.$OnboardingQuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OnboardingQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingQuestionCountArgs} args - Arguments to filter OnboardingQuestions to count.
     * @example
     * // Count the number of OnboardingQuestions
     * const count = await prisma.onboardingQuestion.count({
     *   where: {
     *     // ... the filter for the OnboardingQuestions we want to count
     *   }
     * })
    **/
    count<T extends OnboardingQuestionCountArgs>(
      args?: Subset<T, OnboardingQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OnboardingQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OnboardingQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OnboardingQuestionAggregateArgs>(args: Subset<T, OnboardingQuestionAggregateArgs>): Prisma.PrismaPromise<GetOnboardingQuestionAggregateType<T>>

    /**
     * Group by OnboardingQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OnboardingQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OnboardingQuestionGroupByArgs['orderBy'] }
        : { orderBy?: OnboardingQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OnboardingQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOnboardingQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OnboardingQuestion model
   */
  readonly fields: OnboardingQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OnboardingQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OnboardingQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    answers<T extends OnboardingQuestion$answersArgs<ExtArgs> = {}>(args?: Subset<T, OnboardingQuestion$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OnboardingQuestion model
   */ 
  interface OnboardingQuestionFieldRefs {
    readonly id: FieldRef<"OnboardingQuestion", 'String'>
    readonly category: FieldRef<"OnboardingQuestion", 'QuestionCategory'>
    readonly questionText: FieldRef<"OnboardingQuestion", 'String'>
    readonly questionType: FieldRef<"OnboardingQuestion", 'QuestionType'>
    readonly options: FieldRef<"OnboardingQuestion", 'Json'>
    readonly followUpLogic: FieldRef<"OnboardingQuestion", 'Json'>
    readonly order: FieldRef<"OnboardingQuestion", 'Int'>
    readonly isActive: FieldRef<"OnboardingQuestion", 'Boolean'>
    readonly createdAt: FieldRef<"OnboardingQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OnboardingQuestion findUnique
   */
  export type OnboardingQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingQuestion
     */
    select?: OnboardingQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingQuestionInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingQuestion to fetch.
     */
    where: OnboardingQuestionWhereUniqueInput
  }

  /**
   * OnboardingQuestion findUniqueOrThrow
   */
  export type OnboardingQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingQuestion
     */
    select?: OnboardingQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingQuestionInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingQuestion to fetch.
     */
    where: OnboardingQuestionWhereUniqueInput
  }

  /**
   * OnboardingQuestion findFirst
   */
  export type OnboardingQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingQuestion
     */
    select?: OnboardingQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingQuestionInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingQuestion to fetch.
     */
    where?: OnboardingQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingQuestions to fetch.
     */
    orderBy?: OnboardingQuestionOrderByWithRelationInput | OnboardingQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnboardingQuestions.
     */
    cursor?: OnboardingQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnboardingQuestions.
     */
    distinct?: OnboardingQuestionScalarFieldEnum | OnboardingQuestionScalarFieldEnum[]
  }

  /**
   * OnboardingQuestion findFirstOrThrow
   */
  export type OnboardingQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingQuestion
     */
    select?: OnboardingQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingQuestionInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingQuestion to fetch.
     */
    where?: OnboardingQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingQuestions to fetch.
     */
    orderBy?: OnboardingQuestionOrderByWithRelationInput | OnboardingQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnboardingQuestions.
     */
    cursor?: OnboardingQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnboardingQuestions.
     */
    distinct?: OnboardingQuestionScalarFieldEnum | OnboardingQuestionScalarFieldEnum[]
  }

  /**
   * OnboardingQuestion findMany
   */
  export type OnboardingQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingQuestion
     */
    select?: OnboardingQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingQuestionInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingQuestions to fetch.
     */
    where?: OnboardingQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingQuestions to fetch.
     */
    orderBy?: OnboardingQuestionOrderByWithRelationInput | OnboardingQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OnboardingQuestions.
     */
    cursor?: OnboardingQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingQuestions.
     */
    skip?: number
    distinct?: OnboardingQuestionScalarFieldEnum | OnboardingQuestionScalarFieldEnum[]
  }

  /**
   * OnboardingQuestion create
   */
  export type OnboardingQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingQuestion
     */
    select?: OnboardingQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a OnboardingQuestion.
     */
    data: XOR<OnboardingQuestionCreateInput, OnboardingQuestionUncheckedCreateInput>
  }

  /**
   * OnboardingQuestion createMany
   */
  export type OnboardingQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OnboardingQuestions.
     */
    data: OnboardingQuestionCreateManyInput | OnboardingQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OnboardingQuestion createManyAndReturn
   */
  export type OnboardingQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingQuestion
     */
    select?: OnboardingQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OnboardingQuestions.
     */
    data: OnboardingQuestionCreateManyInput | OnboardingQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OnboardingQuestion update
   */
  export type OnboardingQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingQuestion
     */
    select?: OnboardingQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a OnboardingQuestion.
     */
    data: XOR<OnboardingQuestionUpdateInput, OnboardingQuestionUncheckedUpdateInput>
    /**
     * Choose, which OnboardingQuestion to update.
     */
    where: OnboardingQuestionWhereUniqueInput
  }

  /**
   * OnboardingQuestion updateMany
   */
  export type OnboardingQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OnboardingQuestions.
     */
    data: XOR<OnboardingQuestionUpdateManyMutationInput, OnboardingQuestionUncheckedUpdateManyInput>
    /**
     * Filter which OnboardingQuestions to update
     */
    where?: OnboardingQuestionWhereInput
  }

  /**
   * OnboardingQuestion upsert
   */
  export type OnboardingQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingQuestion
     */
    select?: OnboardingQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the OnboardingQuestion to update in case it exists.
     */
    where: OnboardingQuestionWhereUniqueInput
    /**
     * In case the OnboardingQuestion found by the `where` argument doesn't exist, create a new OnboardingQuestion with this data.
     */
    create: XOR<OnboardingQuestionCreateInput, OnboardingQuestionUncheckedCreateInput>
    /**
     * In case the OnboardingQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OnboardingQuestionUpdateInput, OnboardingQuestionUncheckedUpdateInput>
  }

  /**
   * OnboardingQuestion delete
   */
  export type OnboardingQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingQuestion
     */
    select?: OnboardingQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingQuestionInclude<ExtArgs> | null
    /**
     * Filter which OnboardingQuestion to delete.
     */
    where: OnboardingQuestionWhereUniqueInput
  }

  /**
   * OnboardingQuestion deleteMany
   */
  export type OnboardingQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnboardingQuestions to delete
     */
    where?: OnboardingQuestionWhereInput
  }

  /**
   * OnboardingQuestion.answers
   */
  export type OnboardingQuestion$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingAnswer
     */
    select?: OnboardingAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingAnswerInclude<ExtArgs> | null
    where?: OnboardingAnswerWhereInput
    orderBy?: OnboardingAnswerOrderByWithRelationInput | OnboardingAnswerOrderByWithRelationInput[]
    cursor?: OnboardingAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OnboardingAnswerScalarFieldEnum | OnboardingAnswerScalarFieldEnum[]
  }

  /**
   * OnboardingQuestion without action
   */
  export type OnboardingQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingQuestion
     */
    select?: OnboardingQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingQuestionInclude<ExtArgs> | null
  }


  /**
   * Model OnboardingAnswer
   */

  export type AggregateOnboardingAnswer = {
    _count: OnboardingAnswerCountAggregateOutputType | null
    _avg: OnboardingAnswerAvgAggregateOutputType | null
    _sum: OnboardingAnswerSumAggregateOutputType | null
    _min: OnboardingAnswerMinAggregateOutputType | null
    _max: OnboardingAnswerMaxAggregateOutputType | null
  }

  export type OnboardingAnswerAvgAggregateOutputType = {
    followUpCount: number | null
    confidence: number | null
    consistency: number | null
  }

  export type OnboardingAnswerSumAggregateOutputType = {
    followUpCount: number | null
    confidence: number | null
    consistency: number | null
  }

  export type OnboardingAnswerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    questionId: string | null
    followUpCount: number | null
    confidence: number | null
    consistency: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OnboardingAnswerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    questionId: string | null
    followUpCount: number | null
    confidence: number | null
    consistency: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OnboardingAnswerCountAggregateOutputType = {
    id: number
    userId: number
    questionId: number
    answer: number
    followUpCount: number
    confidence: number
    consistency: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OnboardingAnswerAvgAggregateInputType = {
    followUpCount?: true
    confidence?: true
    consistency?: true
  }

  export type OnboardingAnswerSumAggregateInputType = {
    followUpCount?: true
    confidence?: true
    consistency?: true
  }

  export type OnboardingAnswerMinAggregateInputType = {
    id?: true
    userId?: true
    questionId?: true
    followUpCount?: true
    confidence?: true
    consistency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OnboardingAnswerMaxAggregateInputType = {
    id?: true
    userId?: true
    questionId?: true
    followUpCount?: true
    confidence?: true
    consistency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OnboardingAnswerCountAggregateInputType = {
    id?: true
    userId?: true
    questionId?: true
    answer?: true
    followUpCount?: true
    confidence?: true
    consistency?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OnboardingAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnboardingAnswer to aggregate.
     */
    where?: OnboardingAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingAnswers to fetch.
     */
    orderBy?: OnboardingAnswerOrderByWithRelationInput | OnboardingAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OnboardingAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OnboardingAnswers
    **/
    _count?: true | OnboardingAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OnboardingAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OnboardingAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OnboardingAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OnboardingAnswerMaxAggregateInputType
  }

  export type GetOnboardingAnswerAggregateType<T extends OnboardingAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateOnboardingAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOnboardingAnswer[P]>
      : GetScalarType<T[P], AggregateOnboardingAnswer[P]>
  }




  export type OnboardingAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnboardingAnswerWhereInput
    orderBy?: OnboardingAnswerOrderByWithAggregationInput | OnboardingAnswerOrderByWithAggregationInput[]
    by: OnboardingAnswerScalarFieldEnum[] | OnboardingAnswerScalarFieldEnum
    having?: OnboardingAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OnboardingAnswerCountAggregateInputType | true
    _avg?: OnboardingAnswerAvgAggregateInputType
    _sum?: OnboardingAnswerSumAggregateInputType
    _min?: OnboardingAnswerMinAggregateInputType
    _max?: OnboardingAnswerMaxAggregateInputType
  }

  export type OnboardingAnswerGroupByOutputType = {
    id: string
    userId: string
    questionId: string
    answer: JsonValue
    followUpCount: number
    confidence: number | null
    consistency: number | null
    createdAt: Date
    updatedAt: Date
    _count: OnboardingAnswerCountAggregateOutputType | null
    _avg: OnboardingAnswerAvgAggregateOutputType | null
    _sum: OnboardingAnswerSumAggregateOutputType | null
    _min: OnboardingAnswerMinAggregateOutputType | null
    _max: OnboardingAnswerMaxAggregateOutputType | null
  }

  type GetOnboardingAnswerGroupByPayload<T extends OnboardingAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OnboardingAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OnboardingAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OnboardingAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], OnboardingAnswerGroupByOutputType[P]>
        }
      >
    >


  export type OnboardingAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    questionId?: boolean
    answer?: boolean
    followUpCount?: boolean
    confidence?: boolean
    consistency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    question?: boolean | OnboardingQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingAnswer"]>

  export type OnboardingAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    questionId?: boolean
    answer?: boolean
    followUpCount?: boolean
    confidence?: boolean
    consistency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    question?: boolean | OnboardingQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingAnswer"]>

  export type OnboardingAnswerSelectScalar = {
    id?: boolean
    userId?: boolean
    questionId?: boolean
    answer?: boolean
    followUpCount?: boolean
    confidence?: boolean
    consistency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OnboardingAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    question?: boolean | OnboardingQuestionDefaultArgs<ExtArgs>
  }
  export type OnboardingAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    question?: boolean | OnboardingQuestionDefaultArgs<ExtArgs>
  }

  export type $OnboardingAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OnboardingAnswer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      question: Prisma.$OnboardingQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      questionId: string
      answer: Prisma.JsonValue
      followUpCount: number
      confidence: number | null
      consistency: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["onboardingAnswer"]>
    composites: {}
  }

  type OnboardingAnswerGetPayload<S extends boolean | null | undefined | OnboardingAnswerDefaultArgs> = $Result.GetResult<Prisma.$OnboardingAnswerPayload, S>

  type OnboardingAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OnboardingAnswerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OnboardingAnswerCountAggregateInputType | true
    }

  export interface OnboardingAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OnboardingAnswer'], meta: { name: 'OnboardingAnswer' } }
    /**
     * Find zero or one OnboardingAnswer that matches the filter.
     * @param {OnboardingAnswerFindUniqueArgs} args - Arguments to find a OnboardingAnswer
     * @example
     * // Get one OnboardingAnswer
     * const onboardingAnswer = await prisma.onboardingAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OnboardingAnswerFindUniqueArgs>(args: SelectSubset<T, OnboardingAnswerFindUniqueArgs<ExtArgs>>): Prisma__OnboardingAnswerClient<$Result.GetResult<Prisma.$OnboardingAnswerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OnboardingAnswer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OnboardingAnswerFindUniqueOrThrowArgs} args - Arguments to find a OnboardingAnswer
     * @example
     * // Get one OnboardingAnswer
     * const onboardingAnswer = await prisma.onboardingAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OnboardingAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, OnboardingAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OnboardingAnswerClient<$Result.GetResult<Prisma.$OnboardingAnswerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OnboardingAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingAnswerFindFirstArgs} args - Arguments to find a OnboardingAnswer
     * @example
     * // Get one OnboardingAnswer
     * const onboardingAnswer = await prisma.onboardingAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OnboardingAnswerFindFirstArgs>(args?: SelectSubset<T, OnboardingAnswerFindFirstArgs<ExtArgs>>): Prisma__OnboardingAnswerClient<$Result.GetResult<Prisma.$OnboardingAnswerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OnboardingAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingAnswerFindFirstOrThrowArgs} args - Arguments to find a OnboardingAnswer
     * @example
     * // Get one OnboardingAnswer
     * const onboardingAnswer = await prisma.onboardingAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OnboardingAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, OnboardingAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__OnboardingAnswerClient<$Result.GetResult<Prisma.$OnboardingAnswerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OnboardingAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OnboardingAnswers
     * const onboardingAnswers = await prisma.onboardingAnswer.findMany()
     * 
     * // Get first 10 OnboardingAnswers
     * const onboardingAnswers = await prisma.onboardingAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const onboardingAnswerWithIdOnly = await prisma.onboardingAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OnboardingAnswerFindManyArgs>(args?: SelectSubset<T, OnboardingAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingAnswerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OnboardingAnswer.
     * @param {OnboardingAnswerCreateArgs} args - Arguments to create a OnboardingAnswer.
     * @example
     * // Create one OnboardingAnswer
     * const OnboardingAnswer = await prisma.onboardingAnswer.create({
     *   data: {
     *     // ... data to create a OnboardingAnswer
     *   }
     * })
     * 
     */
    create<T extends OnboardingAnswerCreateArgs>(args: SelectSubset<T, OnboardingAnswerCreateArgs<ExtArgs>>): Prisma__OnboardingAnswerClient<$Result.GetResult<Prisma.$OnboardingAnswerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OnboardingAnswers.
     * @param {OnboardingAnswerCreateManyArgs} args - Arguments to create many OnboardingAnswers.
     * @example
     * // Create many OnboardingAnswers
     * const onboardingAnswer = await prisma.onboardingAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OnboardingAnswerCreateManyArgs>(args?: SelectSubset<T, OnboardingAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OnboardingAnswers and returns the data saved in the database.
     * @param {OnboardingAnswerCreateManyAndReturnArgs} args - Arguments to create many OnboardingAnswers.
     * @example
     * // Create many OnboardingAnswers
     * const onboardingAnswer = await prisma.onboardingAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OnboardingAnswers and only return the `id`
     * const onboardingAnswerWithIdOnly = await prisma.onboardingAnswer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OnboardingAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, OnboardingAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingAnswerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OnboardingAnswer.
     * @param {OnboardingAnswerDeleteArgs} args - Arguments to delete one OnboardingAnswer.
     * @example
     * // Delete one OnboardingAnswer
     * const OnboardingAnswer = await prisma.onboardingAnswer.delete({
     *   where: {
     *     // ... filter to delete one OnboardingAnswer
     *   }
     * })
     * 
     */
    delete<T extends OnboardingAnswerDeleteArgs>(args: SelectSubset<T, OnboardingAnswerDeleteArgs<ExtArgs>>): Prisma__OnboardingAnswerClient<$Result.GetResult<Prisma.$OnboardingAnswerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OnboardingAnswer.
     * @param {OnboardingAnswerUpdateArgs} args - Arguments to update one OnboardingAnswer.
     * @example
     * // Update one OnboardingAnswer
     * const onboardingAnswer = await prisma.onboardingAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OnboardingAnswerUpdateArgs>(args: SelectSubset<T, OnboardingAnswerUpdateArgs<ExtArgs>>): Prisma__OnboardingAnswerClient<$Result.GetResult<Prisma.$OnboardingAnswerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OnboardingAnswers.
     * @param {OnboardingAnswerDeleteManyArgs} args - Arguments to filter OnboardingAnswers to delete.
     * @example
     * // Delete a few OnboardingAnswers
     * const { count } = await prisma.onboardingAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OnboardingAnswerDeleteManyArgs>(args?: SelectSubset<T, OnboardingAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnboardingAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OnboardingAnswers
     * const onboardingAnswer = await prisma.onboardingAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OnboardingAnswerUpdateManyArgs>(args: SelectSubset<T, OnboardingAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OnboardingAnswer.
     * @param {OnboardingAnswerUpsertArgs} args - Arguments to update or create a OnboardingAnswer.
     * @example
     * // Update or create a OnboardingAnswer
     * const onboardingAnswer = await prisma.onboardingAnswer.upsert({
     *   create: {
     *     // ... data to create a OnboardingAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OnboardingAnswer we want to update
     *   }
     * })
     */
    upsert<T extends OnboardingAnswerUpsertArgs>(args: SelectSubset<T, OnboardingAnswerUpsertArgs<ExtArgs>>): Prisma__OnboardingAnswerClient<$Result.GetResult<Prisma.$OnboardingAnswerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OnboardingAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingAnswerCountArgs} args - Arguments to filter OnboardingAnswers to count.
     * @example
     * // Count the number of OnboardingAnswers
     * const count = await prisma.onboardingAnswer.count({
     *   where: {
     *     // ... the filter for the OnboardingAnswers we want to count
     *   }
     * })
    **/
    count<T extends OnboardingAnswerCountArgs>(
      args?: Subset<T, OnboardingAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OnboardingAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OnboardingAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OnboardingAnswerAggregateArgs>(args: Subset<T, OnboardingAnswerAggregateArgs>): Prisma.PrismaPromise<GetOnboardingAnswerAggregateType<T>>

    /**
     * Group by OnboardingAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OnboardingAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OnboardingAnswerGroupByArgs['orderBy'] }
        : { orderBy?: OnboardingAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OnboardingAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOnboardingAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OnboardingAnswer model
   */
  readonly fields: OnboardingAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OnboardingAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OnboardingAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    question<T extends OnboardingQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OnboardingQuestionDefaultArgs<ExtArgs>>): Prisma__OnboardingQuestionClient<$Result.GetResult<Prisma.$OnboardingQuestionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OnboardingAnswer model
   */ 
  interface OnboardingAnswerFieldRefs {
    readonly id: FieldRef<"OnboardingAnswer", 'String'>
    readonly userId: FieldRef<"OnboardingAnswer", 'String'>
    readonly questionId: FieldRef<"OnboardingAnswer", 'String'>
    readonly answer: FieldRef<"OnboardingAnswer", 'Json'>
    readonly followUpCount: FieldRef<"OnboardingAnswer", 'Int'>
    readonly confidence: FieldRef<"OnboardingAnswer", 'Float'>
    readonly consistency: FieldRef<"OnboardingAnswer", 'Float'>
    readonly createdAt: FieldRef<"OnboardingAnswer", 'DateTime'>
    readonly updatedAt: FieldRef<"OnboardingAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OnboardingAnswer findUnique
   */
  export type OnboardingAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingAnswer
     */
    select?: OnboardingAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingAnswerInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingAnswer to fetch.
     */
    where: OnboardingAnswerWhereUniqueInput
  }

  /**
   * OnboardingAnswer findUniqueOrThrow
   */
  export type OnboardingAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingAnswer
     */
    select?: OnboardingAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingAnswerInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingAnswer to fetch.
     */
    where: OnboardingAnswerWhereUniqueInput
  }

  /**
   * OnboardingAnswer findFirst
   */
  export type OnboardingAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingAnswer
     */
    select?: OnboardingAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingAnswerInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingAnswer to fetch.
     */
    where?: OnboardingAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingAnswers to fetch.
     */
    orderBy?: OnboardingAnswerOrderByWithRelationInput | OnboardingAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnboardingAnswers.
     */
    cursor?: OnboardingAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnboardingAnswers.
     */
    distinct?: OnboardingAnswerScalarFieldEnum | OnboardingAnswerScalarFieldEnum[]
  }

  /**
   * OnboardingAnswer findFirstOrThrow
   */
  export type OnboardingAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingAnswer
     */
    select?: OnboardingAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingAnswerInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingAnswer to fetch.
     */
    where?: OnboardingAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingAnswers to fetch.
     */
    orderBy?: OnboardingAnswerOrderByWithRelationInput | OnboardingAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnboardingAnswers.
     */
    cursor?: OnboardingAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnboardingAnswers.
     */
    distinct?: OnboardingAnswerScalarFieldEnum | OnboardingAnswerScalarFieldEnum[]
  }

  /**
   * OnboardingAnswer findMany
   */
  export type OnboardingAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingAnswer
     */
    select?: OnboardingAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingAnswerInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingAnswers to fetch.
     */
    where?: OnboardingAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingAnswers to fetch.
     */
    orderBy?: OnboardingAnswerOrderByWithRelationInput | OnboardingAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OnboardingAnswers.
     */
    cursor?: OnboardingAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingAnswers.
     */
    skip?: number
    distinct?: OnboardingAnswerScalarFieldEnum | OnboardingAnswerScalarFieldEnum[]
  }

  /**
   * OnboardingAnswer create
   */
  export type OnboardingAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingAnswer
     */
    select?: OnboardingAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a OnboardingAnswer.
     */
    data: XOR<OnboardingAnswerCreateInput, OnboardingAnswerUncheckedCreateInput>
  }

  /**
   * OnboardingAnswer createMany
   */
  export type OnboardingAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OnboardingAnswers.
     */
    data: OnboardingAnswerCreateManyInput | OnboardingAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OnboardingAnswer createManyAndReturn
   */
  export type OnboardingAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingAnswer
     */
    select?: OnboardingAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OnboardingAnswers.
     */
    data: OnboardingAnswerCreateManyInput | OnboardingAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OnboardingAnswer update
   */
  export type OnboardingAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingAnswer
     */
    select?: OnboardingAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a OnboardingAnswer.
     */
    data: XOR<OnboardingAnswerUpdateInput, OnboardingAnswerUncheckedUpdateInput>
    /**
     * Choose, which OnboardingAnswer to update.
     */
    where: OnboardingAnswerWhereUniqueInput
  }

  /**
   * OnboardingAnswer updateMany
   */
  export type OnboardingAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OnboardingAnswers.
     */
    data: XOR<OnboardingAnswerUpdateManyMutationInput, OnboardingAnswerUncheckedUpdateManyInput>
    /**
     * Filter which OnboardingAnswers to update
     */
    where?: OnboardingAnswerWhereInput
  }

  /**
   * OnboardingAnswer upsert
   */
  export type OnboardingAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingAnswer
     */
    select?: OnboardingAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the OnboardingAnswer to update in case it exists.
     */
    where: OnboardingAnswerWhereUniqueInput
    /**
     * In case the OnboardingAnswer found by the `where` argument doesn't exist, create a new OnboardingAnswer with this data.
     */
    create: XOR<OnboardingAnswerCreateInput, OnboardingAnswerUncheckedCreateInput>
    /**
     * In case the OnboardingAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OnboardingAnswerUpdateInput, OnboardingAnswerUncheckedUpdateInput>
  }

  /**
   * OnboardingAnswer delete
   */
  export type OnboardingAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingAnswer
     */
    select?: OnboardingAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingAnswerInclude<ExtArgs> | null
    /**
     * Filter which OnboardingAnswer to delete.
     */
    where: OnboardingAnswerWhereUniqueInput
  }

  /**
   * OnboardingAnswer deleteMany
   */
  export type OnboardingAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnboardingAnswers to delete
     */
    where?: OnboardingAnswerWhereInput
  }

  /**
   * OnboardingAnswer without action
   */
  export type OnboardingAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingAnswer
     */
    select?: OnboardingAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingAnswerInclude<ExtArgs> | null
  }


  /**
   * Model Like
   */

  export type AggregateLike = {
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  export type LikeMinAggregateOutputType = {
    id: string | null
    fromUserId: string | null
    toUserId: string | null
    createdAt: Date | null
  }

  export type LikeMaxAggregateOutputType = {
    id: string | null
    fromUserId: string | null
    toUserId: string | null
    createdAt: Date | null
  }

  export type LikeCountAggregateOutputType = {
    id: number
    fromUserId: number
    toUserId: number
    createdAt: number
    _all: number
  }


  export type LikeMinAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
  }

  export type LikeMaxAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
  }

  export type LikeCountAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    createdAt?: true
    _all?: true
  }

  export type LikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Like to aggregate.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Likes
    **/
    _count?: true | LikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeMaxAggregateInputType
  }

  export type GetLikeAggregateType<T extends LikeAggregateArgs> = {
        [P in keyof T & keyof AggregateLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLike[P]>
      : GetScalarType<T[P], AggregateLike[P]>
  }




  export type LikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithAggregationInput | LikeOrderByWithAggregationInput[]
    by: LikeScalarFieldEnum[] | LikeScalarFieldEnum
    having?: LikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeCountAggregateInputType | true
    _min?: LikeMinAggregateInputType
    _max?: LikeMaxAggregateInputType
  }

  export type LikeGroupByOutputType = {
    id: string
    fromUserId: string
    toUserId: string
    createdAt: Date
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  type GetLikeGroupByPayload<T extends LikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeGroupByOutputType[P]>
            : GetScalarType<T[P], LikeGroupByOutputType[P]>
        }
      >
    >


  export type LikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    createdAt?: boolean
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    createdAt?: boolean
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectScalar = {
    id?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    createdAt?: boolean
  }

  export type LikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Like"
    objects: {
      fromUser: Prisma.$UserPayload<ExtArgs>
      toUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromUserId: string
      toUserId: string
      createdAt: Date
    }, ExtArgs["result"]["like"]>
    composites: {}
  }

  type LikeGetPayload<S extends boolean | null | undefined | LikeDefaultArgs> = $Result.GetResult<Prisma.$LikePayload, S>

  type LikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LikeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LikeCountAggregateInputType | true
    }

  export interface LikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Like'], meta: { name: 'Like' } }
    /**
     * Find zero or one Like that matches the filter.
     * @param {LikeFindUniqueArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikeFindUniqueArgs>(args: SelectSubset<T, LikeFindUniqueArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Like that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LikeFindUniqueOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikeFindUniqueOrThrowArgs>(args: SelectSubset<T, LikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikeFindFirstArgs>(args?: SelectSubset<T, LikeFindFirstArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikeFindFirstOrThrowArgs>(args?: SelectSubset<T, LikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.like.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.like.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeWithIdOnly = await prisma.like.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikeFindManyArgs>(args?: SelectSubset<T, LikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Like.
     * @param {LikeCreateArgs} args - Arguments to create a Like.
     * @example
     * // Create one Like
     * const Like = await prisma.like.create({
     *   data: {
     *     // ... data to create a Like
     *   }
     * })
     * 
     */
    create<T extends LikeCreateArgs>(args: SelectSubset<T, LikeCreateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Likes.
     * @param {LikeCreateManyArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikeCreateManyArgs>(args?: SelectSubset<T, LikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Likes and returns the data saved in the database.
     * @param {LikeCreateManyAndReturnArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Likes and only return the `id`
     * const likeWithIdOnly = await prisma.like.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikeCreateManyAndReturnArgs>(args?: SelectSubset<T, LikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Like.
     * @param {LikeDeleteArgs} args - Arguments to delete one Like.
     * @example
     * // Delete one Like
     * const Like = await prisma.like.delete({
     *   where: {
     *     // ... filter to delete one Like
     *   }
     * })
     * 
     */
    delete<T extends LikeDeleteArgs>(args: SelectSubset<T, LikeDeleteArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Like.
     * @param {LikeUpdateArgs} args - Arguments to update one Like.
     * @example
     * // Update one Like
     * const like = await prisma.like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikeUpdateArgs>(args: SelectSubset<T, LikeUpdateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Likes.
     * @param {LikeDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikeDeleteManyArgs>(args?: SelectSubset<T, LikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikeUpdateManyArgs>(args: SelectSubset<T, LikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Like.
     * @param {LikeUpsertArgs} args - Arguments to update or create a Like.
     * @example
     * // Update or create a Like
     * const like = await prisma.like.upsert({
     *   create: {
     *     // ... data to create a Like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Like we want to update
     *   }
     * })
     */
    upsert<T extends LikeUpsertArgs>(args: SelectSubset<T, LikeUpsertArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.like.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends LikeCountArgs>(
      args?: Subset<T, LikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeAggregateArgs>(args: Subset<T, LikeAggregateArgs>): Prisma.PrismaPromise<GetLikeAggregateType<T>>

    /**
     * Group by Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeGroupByArgs['orderBy'] }
        : { orderBy?: LikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Like model
   */
  readonly fields: LikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    toUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Like model
   */ 
  interface LikeFieldRefs {
    readonly id: FieldRef<"Like", 'String'>
    readonly fromUserId: FieldRef<"Like", 'String'>
    readonly toUserId: FieldRef<"Like", 'String'>
    readonly createdAt: FieldRef<"Like", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Like findUnique
   */
  export type LikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findUniqueOrThrow
   */
  export type LikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findFirst
   */
  export type LikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findFirstOrThrow
   */
  export type LikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findMany
   */
  export type LikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like create
   */
  export type LikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to create a Like.
     */
    data: XOR<LikeCreateInput, LikeUncheckedCreateInput>
  }

  /**
   * Like createMany
   */
  export type LikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Like createManyAndReturn
   */
  export type LikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Like update
   */
  export type LikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to update a Like.
     */
    data: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
    /**
     * Choose, which Like to update.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like updateMany
   */
  export type LikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
  }

  /**
   * Like upsert
   */
  export type LikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The filter to search for the Like to update in case it exists.
     */
    where: LikeWhereUniqueInput
    /**
     * In case the Like found by the `where` argument doesn't exist, create a new Like with this data.
     */
    create: XOR<LikeCreateInput, LikeUncheckedCreateInput>
    /**
     * In case the Like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
  }

  /**
   * Like delete
   */
  export type LikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter which Like to delete.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like deleteMany
   */
  export type LikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to delete
     */
    where?: LikeWhereInput
  }

  /**
   * Like without action
   */
  export type LikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
  }


  /**
   * Model Match
   */

  export type AggregateMatch = {
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  export type MatchAvgAggregateOutputType = {
    overallScore: number | null
    valuesScore: number | null
    lifestyleScore: number | null
    intentScore: number | null
    communicationScore: number | null
    logisticsScore: number | null
    confidenceLevel: number | null
  }

  export type MatchSumAggregateOutputType = {
    overallScore: number | null
    valuesScore: number | null
    lifestyleScore: number | null
    intentScore: number | null
    communicationScore: number | null
    logisticsScore: number | null
    confidenceLevel: number | null
  }

  export type MatchMinAggregateOutputType = {
    id: string | null
    userAId: string | null
    userBId: string | null
    overallScore: number | null
    valuesScore: number | null
    lifestyleScore: number | null
    intentScore: number | null
    communicationScore: number | null
    logisticsScore: number | null
    frictionPoint: string | null
    confidenceLevel: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchMaxAggregateOutputType = {
    id: string | null
    userAId: string | null
    userBId: string | null
    overallScore: number | null
    valuesScore: number | null
    lifestyleScore: number | null
    intentScore: number | null
    communicationScore: number | null
    logisticsScore: number | null
    frictionPoint: string | null
    confidenceLevel: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchCountAggregateOutputType = {
    id: number
    userAId: number
    userBId: number
    overallScore: number
    valuesScore: number
    lifestyleScore: number
    intentScore: number
    communicationScore: number
    logisticsScore: number
    topReasons: number
    frictionPoint: number
    confidenceLevel: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatchAvgAggregateInputType = {
    overallScore?: true
    valuesScore?: true
    lifestyleScore?: true
    intentScore?: true
    communicationScore?: true
    logisticsScore?: true
    confidenceLevel?: true
  }

  export type MatchSumAggregateInputType = {
    overallScore?: true
    valuesScore?: true
    lifestyleScore?: true
    intentScore?: true
    communicationScore?: true
    logisticsScore?: true
    confidenceLevel?: true
  }

  export type MatchMinAggregateInputType = {
    id?: true
    userAId?: true
    userBId?: true
    overallScore?: true
    valuesScore?: true
    lifestyleScore?: true
    intentScore?: true
    communicationScore?: true
    logisticsScore?: true
    frictionPoint?: true
    confidenceLevel?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchMaxAggregateInputType = {
    id?: true
    userAId?: true
    userBId?: true
    overallScore?: true
    valuesScore?: true
    lifestyleScore?: true
    intentScore?: true
    communicationScore?: true
    logisticsScore?: true
    frictionPoint?: true
    confidenceLevel?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchCountAggregateInputType = {
    id?: true
    userAId?: true
    userBId?: true
    overallScore?: true
    valuesScore?: true
    lifestyleScore?: true
    intentScore?: true
    communicationScore?: true
    logisticsScore?: true
    topReasons?: true
    frictionPoint?: true
    confidenceLevel?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Match to aggregate.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Matches
    **/
    _count?: true | MatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchMaxAggregateInputType
  }

  export type GetMatchAggregateType<T extends MatchAggregateArgs> = {
        [P in keyof T & keyof AggregateMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatch[P]>
      : GetScalarType<T[P], AggregateMatch[P]>
  }




  export type MatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithAggregationInput | MatchOrderByWithAggregationInput[]
    by: MatchScalarFieldEnum[] | MatchScalarFieldEnum
    having?: MatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchCountAggregateInputType | true
    _avg?: MatchAvgAggregateInputType
    _sum?: MatchSumAggregateInputType
    _min?: MatchMinAggregateInputType
    _max?: MatchMaxAggregateInputType
  }

  export type MatchGroupByOutputType = {
    id: string
    userAId: string
    userBId: string
    overallScore: number
    valuesScore: number
    lifestyleScore: number
    intentScore: number
    communicationScore: number
    logisticsScore: number
    topReasons: string[]
    frictionPoint: string | null
    confidenceLevel: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  type GetMatchGroupByPayload<T extends MatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchGroupByOutputType[P]>
            : GetScalarType<T[P], MatchGroupByOutputType[P]>
        }
      >
    >


  export type MatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userAId?: boolean
    userBId?: boolean
    overallScore?: boolean
    valuesScore?: boolean
    lifestyleScore?: boolean
    intentScore?: boolean
    communicationScore?: boolean
    logisticsScore?: boolean
    topReasons?: boolean
    frictionPoint?: boolean
    confidenceLevel?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userA?: boolean | UserDefaultArgs<ExtArgs>
    userB?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Match$messagesArgs<ExtArgs>
    scheduledDates?: boolean | Match$scheduledDatesArgs<ExtArgs>
    _count?: boolean | MatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userAId?: boolean
    userBId?: boolean
    overallScore?: boolean
    valuesScore?: boolean
    lifestyleScore?: boolean
    intentScore?: boolean
    communicationScore?: boolean
    logisticsScore?: boolean
    topReasons?: boolean
    frictionPoint?: boolean
    confidenceLevel?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userA?: boolean | UserDefaultArgs<ExtArgs>
    userB?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectScalar = {
    id?: boolean
    userAId?: boolean
    userBId?: boolean
    overallScore?: boolean
    valuesScore?: boolean
    lifestyleScore?: boolean
    intentScore?: boolean
    communicationScore?: boolean
    logisticsScore?: boolean
    topReasons?: boolean
    frictionPoint?: boolean
    confidenceLevel?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userA?: boolean | UserDefaultArgs<ExtArgs>
    userB?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Match$messagesArgs<ExtArgs>
    scheduledDates?: boolean | Match$scheduledDatesArgs<ExtArgs>
    _count?: boolean | MatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userA?: boolean | UserDefaultArgs<ExtArgs>
    userB?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Match"
    objects: {
      userA: Prisma.$UserPayload<ExtArgs>
      userB: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
      scheduledDates: Prisma.$ScheduledDatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userAId: string
      userBId: string
      overallScore: number
      valuesScore: number
      lifestyleScore: number
      intentScore: number
      communicationScore: number
      logisticsScore: number
      topReasons: string[]
      frictionPoint: string | null
      confidenceLevel: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["match"]>
    composites: {}
  }

  type MatchGetPayload<S extends boolean | null | undefined | MatchDefaultArgs> = $Result.GetResult<Prisma.$MatchPayload, S>

  type MatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MatchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MatchCountAggregateInputType | true
    }

  export interface MatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Match'], meta: { name: 'Match' } }
    /**
     * Find zero or one Match that matches the filter.
     * @param {MatchFindUniqueArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchFindUniqueArgs>(args: SelectSubset<T, MatchFindUniqueArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Match that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MatchFindUniqueOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Match that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchFindFirstArgs>(args?: SelectSubset<T, MatchFindFirstArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Match that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matches
     * const matches = await prisma.match.findMany()
     * 
     * // Get first 10 Matches
     * const matches = await prisma.match.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchWithIdOnly = await prisma.match.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchFindManyArgs>(args?: SelectSubset<T, MatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Match.
     * @param {MatchCreateArgs} args - Arguments to create a Match.
     * @example
     * // Create one Match
     * const Match = await prisma.match.create({
     *   data: {
     *     // ... data to create a Match
     *   }
     * })
     * 
     */
    create<T extends MatchCreateArgs>(args: SelectSubset<T, MatchCreateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Matches.
     * @param {MatchCreateManyArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const match = await prisma.match.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchCreateManyArgs>(args?: SelectSubset<T, MatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Matches and returns the data saved in the database.
     * @param {MatchCreateManyAndReturnArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const match = await prisma.match.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Matches and only return the `id`
     * const matchWithIdOnly = await prisma.match.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Match.
     * @param {MatchDeleteArgs} args - Arguments to delete one Match.
     * @example
     * // Delete one Match
     * const Match = await prisma.match.delete({
     *   where: {
     *     // ... filter to delete one Match
     *   }
     * })
     * 
     */
    delete<T extends MatchDeleteArgs>(args: SelectSubset<T, MatchDeleteArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Match.
     * @param {MatchUpdateArgs} args - Arguments to update one Match.
     * @example
     * // Update one Match
     * const match = await prisma.match.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchUpdateArgs>(args: SelectSubset<T, MatchUpdateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Matches.
     * @param {MatchDeleteManyArgs} args - Arguments to filter Matches to delete.
     * @example
     * // Delete a few Matches
     * const { count } = await prisma.match.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchDeleteManyArgs>(args?: SelectSubset<T, MatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matches
     * const match = await prisma.match.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchUpdateManyArgs>(args: SelectSubset<T, MatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Match.
     * @param {MatchUpsertArgs} args - Arguments to update or create a Match.
     * @example
     * // Update or create a Match
     * const match = await prisma.match.upsert({
     *   create: {
     *     // ... data to create a Match
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Match we want to update
     *   }
     * })
     */
    upsert<T extends MatchUpsertArgs>(args: SelectSubset<T, MatchUpsertArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchCountArgs} args - Arguments to filter Matches to count.
     * @example
     * // Count the number of Matches
     * const count = await prisma.match.count({
     *   where: {
     *     // ... the filter for the Matches we want to count
     *   }
     * })
    **/
    count<T extends MatchCountArgs>(
      args?: Subset<T, MatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchAggregateArgs>(args: Subset<T, MatchAggregateArgs>): Prisma.PrismaPromise<GetMatchAggregateType<T>>

    /**
     * Group by Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchGroupByArgs['orderBy'] }
        : { orderBy?: MatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Match model
   */
  readonly fields: MatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Match.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userA<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    userB<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messages<T extends Match$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Match$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    scheduledDates<T extends Match$scheduledDatesArgs<ExtArgs> = {}>(args?: Subset<T, Match$scheduledDatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledDatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Match model
   */ 
  interface MatchFieldRefs {
    readonly id: FieldRef<"Match", 'String'>
    readonly userAId: FieldRef<"Match", 'String'>
    readonly userBId: FieldRef<"Match", 'String'>
    readonly overallScore: FieldRef<"Match", 'Int'>
    readonly valuesScore: FieldRef<"Match", 'Int'>
    readonly lifestyleScore: FieldRef<"Match", 'Int'>
    readonly intentScore: FieldRef<"Match", 'Int'>
    readonly communicationScore: FieldRef<"Match", 'Int'>
    readonly logisticsScore: FieldRef<"Match", 'Int'>
    readonly topReasons: FieldRef<"Match", 'String[]'>
    readonly frictionPoint: FieldRef<"Match", 'String'>
    readonly confidenceLevel: FieldRef<"Match", 'Float'>
    readonly isActive: FieldRef<"Match", 'Boolean'>
    readonly createdAt: FieldRef<"Match", 'DateTime'>
    readonly updatedAt: FieldRef<"Match", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Match findUnique
   */
  export type MatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findUniqueOrThrow
   */
  export type MatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findFirst
   */
  export type MatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findFirstOrThrow
   */
  export type MatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findMany
   */
  export type MatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Matches to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match create
   */
  export type MatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Match.
     */
    data: XOR<MatchCreateInput, MatchUncheckedCreateInput>
  }

  /**
   * Match createMany
   */
  export type MatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Match createManyAndReturn
   */
  export type MatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Match update
   */
  export type MatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Match.
     */
    data: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
    /**
     * Choose, which Match to update.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match updateMany
   */
  export type MatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Matches.
     */
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyInput>
    /**
     * Filter which Matches to update
     */
    where?: MatchWhereInput
  }

  /**
   * Match upsert
   */
  export type MatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Match to update in case it exists.
     */
    where: MatchWhereUniqueInput
    /**
     * In case the Match found by the `where` argument doesn't exist, create a new Match with this data.
     */
    create: XOR<MatchCreateInput, MatchUncheckedCreateInput>
    /**
     * In case the Match was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
  }

  /**
   * Match delete
   */
  export type MatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter which Match to delete.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match deleteMany
   */
  export type MatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matches to delete
     */
    where?: MatchWhereInput
  }

  /**
   * Match.messages
   */
  export type Match$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Match.scheduledDates
   */
  export type Match$scheduledDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledDate
     */
    select?: ScheduledDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledDateInclude<ExtArgs> | null
    where?: ScheduledDateWhereInput
    orderBy?: ScheduledDateOrderByWithRelationInput | ScheduledDateOrderByWithRelationInput[]
    cursor?: ScheduledDateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledDateScalarFieldEnum | ScheduledDateScalarFieldEnum[]
  }

  /**
   * Match without action
   */
  export type MatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    safetyScore: number | null
  }

  export type MessageSumAggregateOutputType = {
    safetyScore: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    matchId: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    status: $Enums.MessageStatus | null
    safetyScore: number | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    matchId: string | null
    senderId: string | null
    receiverId: string | null
    content: string | null
    status: $Enums.MessageStatus | null
    safetyScore: number | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    matchId: number
    senderId: number
    receiverId: number
    content: number
    status: number
    safetyScore: number
    safetyFlags: number
    createdAt: number
    readAt: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    safetyScore?: true
  }

  export type MessageSumAggregateInputType = {
    safetyScore?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    matchId?: true
    senderId?: true
    receiverId?: true
    content?: true
    status?: true
    safetyScore?: true
    createdAt?: true
    readAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    matchId?: true
    senderId?: true
    receiverId?: true
    content?: true
    status?: true
    safetyScore?: true
    createdAt?: true
    readAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    matchId?: true
    senderId?: true
    receiverId?: true
    content?: true
    status?: true
    safetyScore?: true
    safetyFlags?: true
    createdAt?: true
    readAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    matchId: string
    senderId: string
    receiverId: string
    content: string
    status: $Enums.MessageStatus
    safetyScore: number | null
    safetyFlags: string[]
    createdAt: Date
    readAt: Date | null
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    status?: boolean
    safetyScore?: boolean
    safetyFlags?: boolean
    createdAt?: boolean
    readAt?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    status?: boolean
    safetyScore?: boolean
    safetyFlags?: boolean
    createdAt?: boolean
    readAt?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    matchId?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    status?: boolean
    safetyScore?: boolean
    safetyFlags?: boolean
    createdAt?: boolean
    readAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      match: Prisma.$MatchPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      matchId: string
      senderId: string
      receiverId: string
      content: string
      status: $Enums.MessageStatus
      safetyScore: number | null
      safetyFlags: string[]
      createdAt: Date
      readAt: Date | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    match<T extends MatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatchDefaultArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly matchId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly receiverId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly status: FieldRef<"Message", 'MessageStatus'>
    readonly safetyScore: FieldRef<"Message", 'Int'>
    readonly safetyFlags: FieldRef<"Message", 'String[]'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly readAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model TrustScore
   */

  export type AggregateTrustScore = {
    _count: TrustScoreCountAggregateOutputType | null
    _avg: TrustScoreAvgAggregateOutputType | null
    _sum: TrustScoreSumAggregateOutputType | null
    _min: TrustScoreMinAggregateOutputType | null
    _max: TrustScoreMaxAggregateOutputType | null
  }

  export type TrustScoreAvgAggregateOutputType = {
    overallScore: number | null
    replyPatternScore: number | null
    commitmentScore: number | null
    respectScore: number | null
    toneConsistencyScore: number | null
  }

  export type TrustScoreSumAggregateOutputType = {
    overallScore: number | null
    replyPatternScore: number | null
    commitmentScore: number | null
    respectScore: number | null
    toneConsistencyScore: number | null
  }

  export type TrustScoreMinAggregateOutputType = {
    id: string | null
    userId: string | null
    overallScore: number | null
    replyPatternScore: number | null
    commitmentScore: number | null
    respectScore: number | null
    toneConsistencyScore: number | null
    lastCalculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrustScoreMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    overallScore: number | null
    replyPatternScore: number | null
    commitmentScore: number | null
    respectScore: number | null
    toneConsistencyScore: number | null
    lastCalculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrustScoreCountAggregateOutputType = {
    id: number
    userId: number
    overallScore: number
    replyPatternScore: number
    commitmentScore: number
    respectScore: number
    toneConsistencyScore: number
    lastCalculatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrustScoreAvgAggregateInputType = {
    overallScore?: true
    replyPatternScore?: true
    commitmentScore?: true
    respectScore?: true
    toneConsistencyScore?: true
  }

  export type TrustScoreSumAggregateInputType = {
    overallScore?: true
    replyPatternScore?: true
    commitmentScore?: true
    respectScore?: true
    toneConsistencyScore?: true
  }

  export type TrustScoreMinAggregateInputType = {
    id?: true
    userId?: true
    overallScore?: true
    replyPatternScore?: true
    commitmentScore?: true
    respectScore?: true
    toneConsistencyScore?: true
    lastCalculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrustScoreMaxAggregateInputType = {
    id?: true
    userId?: true
    overallScore?: true
    replyPatternScore?: true
    commitmentScore?: true
    respectScore?: true
    toneConsistencyScore?: true
    lastCalculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrustScoreCountAggregateInputType = {
    id?: true
    userId?: true
    overallScore?: true
    replyPatternScore?: true
    commitmentScore?: true
    respectScore?: true
    toneConsistencyScore?: true
    lastCalculatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrustScoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrustScore to aggregate.
     */
    where?: TrustScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrustScores to fetch.
     */
    orderBy?: TrustScoreOrderByWithRelationInput | TrustScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrustScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrustScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrustScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrustScores
    **/
    _count?: true | TrustScoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrustScoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrustScoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrustScoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrustScoreMaxAggregateInputType
  }

  export type GetTrustScoreAggregateType<T extends TrustScoreAggregateArgs> = {
        [P in keyof T & keyof AggregateTrustScore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrustScore[P]>
      : GetScalarType<T[P], AggregateTrustScore[P]>
  }




  export type TrustScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrustScoreWhereInput
    orderBy?: TrustScoreOrderByWithAggregationInput | TrustScoreOrderByWithAggregationInput[]
    by: TrustScoreScalarFieldEnum[] | TrustScoreScalarFieldEnum
    having?: TrustScoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrustScoreCountAggregateInputType | true
    _avg?: TrustScoreAvgAggregateInputType
    _sum?: TrustScoreSumAggregateInputType
    _min?: TrustScoreMinAggregateInputType
    _max?: TrustScoreMaxAggregateInputType
  }

  export type TrustScoreGroupByOutputType = {
    id: string
    userId: string
    overallScore: number
    replyPatternScore: number
    commitmentScore: number
    respectScore: number
    toneConsistencyScore: number
    lastCalculatedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: TrustScoreCountAggregateOutputType | null
    _avg: TrustScoreAvgAggregateOutputType | null
    _sum: TrustScoreSumAggregateOutputType | null
    _min: TrustScoreMinAggregateOutputType | null
    _max: TrustScoreMaxAggregateOutputType | null
  }

  type GetTrustScoreGroupByPayload<T extends TrustScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrustScoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrustScoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrustScoreGroupByOutputType[P]>
            : GetScalarType<T[P], TrustScoreGroupByOutputType[P]>
        }
      >
    >


  export type TrustScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    overallScore?: boolean
    replyPatternScore?: boolean
    commitmentScore?: boolean
    respectScore?: boolean
    toneConsistencyScore?: boolean
    lastCalculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trustScore"]>

  export type TrustScoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    overallScore?: boolean
    replyPatternScore?: boolean
    commitmentScore?: boolean
    respectScore?: boolean
    toneConsistencyScore?: boolean
    lastCalculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trustScore"]>

  export type TrustScoreSelectScalar = {
    id?: boolean
    userId?: boolean
    overallScore?: boolean
    replyPatternScore?: boolean
    commitmentScore?: boolean
    respectScore?: boolean
    toneConsistencyScore?: boolean
    lastCalculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrustScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrustScoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrustScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrustScore"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      overallScore: number
      replyPatternScore: number
      commitmentScore: number
      respectScore: number
      toneConsistencyScore: number
      lastCalculatedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trustScore"]>
    composites: {}
  }

  type TrustScoreGetPayload<S extends boolean | null | undefined | TrustScoreDefaultArgs> = $Result.GetResult<Prisma.$TrustScorePayload, S>

  type TrustScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrustScoreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrustScoreCountAggregateInputType | true
    }

  export interface TrustScoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrustScore'], meta: { name: 'TrustScore' } }
    /**
     * Find zero or one TrustScore that matches the filter.
     * @param {TrustScoreFindUniqueArgs} args - Arguments to find a TrustScore
     * @example
     * // Get one TrustScore
     * const trustScore = await prisma.trustScore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrustScoreFindUniqueArgs>(args: SelectSubset<T, TrustScoreFindUniqueArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrustScore that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrustScoreFindUniqueOrThrowArgs} args - Arguments to find a TrustScore
     * @example
     * // Get one TrustScore
     * const trustScore = await prisma.trustScore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrustScoreFindUniqueOrThrowArgs>(args: SelectSubset<T, TrustScoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrustScore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreFindFirstArgs} args - Arguments to find a TrustScore
     * @example
     * // Get one TrustScore
     * const trustScore = await prisma.trustScore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrustScoreFindFirstArgs>(args?: SelectSubset<T, TrustScoreFindFirstArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrustScore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreFindFirstOrThrowArgs} args - Arguments to find a TrustScore
     * @example
     * // Get one TrustScore
     * const trustScore = await prisma.trustScore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrustScoreFindFirstOrThrowArgs>(args?: SelectSubset<T, TrustScoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrustScores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrustScores
     * const trustScores = await prisma.trustScore.findMany()
     * 
     * // Get first 10 TrustScores
     * const trustScores = await prisma.trustScore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trustScoreWithIdOnly = await prisma.trustScore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrustScoreFindManyArgs>(args?: SelectSubset<T, TrustScoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrustScore.
     * @param {TrustScoreCreateArgs} args - Arguments to create a TrustScore.
     * @example
     * // Create one TrustScore
     * const TrustScore = await prisma.trustScore.create({
     *   data: {
     *     // ... data to create a TrustScore
     *   }
     * })
     * 
     */
    create<T extends TrustScoreCreateArgs>(args: SelectSubset<T, TrustScoreCreateArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrustScores.
     * @param {TrustScoreCreateManyArgs} args - Arguments to create many TrustScores.
     * @example
     * // Create many TrustScores
     * const trustScore = await prisma.trustScore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrustScoreCreateManyArgs>(args?: SelectSubset<T, TrustScoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrustScores and returns the data saved in the database.
     * @param {TrustScoreCreateManyAndReturnArgs} args - Arguments to create many TrustScores.
     * @example
     * // Create many TrustScores
     * const trustScore = await prisma.trustScore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrustScores and only return the `id`
     * const trustScoreWithIdOnly = await prisma.trustScore.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrustScoreCreateManyAndReturnArgs>(args?: SelectSubset<T, TrustScoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrustScore.
     * @param {TrustScoreDeleteArgs} args - Arguments to delete one TrustScore.
     * @example
     * // Delete one TrustScore
     * const TrustScore = await prisma.trustScore.delete({
     *   where: {
     *     // ... filter to delete one TrustScore
     *   }
     * })
     * 
     */
    delete<T extends TrustScoreDeleteArgs>(args: SelectSubset<T, TrustScoreDeleteArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrustScore.
     * @param {TrustScoreUpdateArgs} args - Arguments to update one TrustScore.
     * @example
     * // Update one TrustScore
     * const trustScore = await prisma.trustScore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrustScoreUpdateArgs>(args: SelectSubset<T, TrustScoreUpdateArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrustScores.
     * @param {TrustScoreDeleteManyArgs} args - Arguments to filter TrustScores to delete.
     * @example
     * // Delete a few TrustScores
     * const { count } = await prisma.trustScore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrustScoreDeleteManyArgs>(args?: SelectSubset<T, TrustScoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrustScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrustScores
     * const trustScore = await prisma.trustScore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrustScoreUpdateManyArgs>(args: SelectSubset<T, TrustScoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrustScore.
     * @param {TrustScoreUpsertArgs} args - Arguments to update or create a TrustScore.
     * @example
     * // Update or create a TrustScore
     * const trustScore = await prisma.trustScore.upsert({
     *   create: {
     *     // ... data to create a TrustScore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrustScore we want to update
     *   }
     * })
     */
    upsert<T extends TrustScoreUpsertArgs>(args: SelectSubset<T, TrustScoreUpsertArgs<ExtArgs>>): Prisma__TrustScoreClient<$Result.GetResult<Prisma.$TrustScorePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrustScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreCountArgs} args - Arguments to filter TrustScores to count.
     * @example
     * // Count the number of TrustScores
     * const count = await prisma.trustScore.count({
     *   where: {
     *     // ... the filter for the TrustScores we want to count
     *   }
     * })
    **/
    count<T extends TrustScoreCountArgs>(
      args?: Subset<T, TrustScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrustScoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrustScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrustScoreAggregateArgs>(args: Subset<T, TrustScoreAggregateArgs>): Prisma.PrismaPromise<GetTrustScoreAggregateType<T>>

    /**
     * Group by TrustScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrustScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrustScoreGroupByArgs['orderBy'] }
        : { orderBy?: TrustScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrustScoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrustScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrustScore model
   */
  readonly fields: TrustScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrustScore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrustScoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrustScore model
   */ 
  interface TrustScoreFieldRefs {
    readonly id: FieldRef<"TrustScore", 'String'>
    readonly userId: FieldRef<"TrustScore", 'String'>
    readonly overallScore: FieldRef<"TrustScore", 'Int'>
    readonly replyPatternScore: FieldRef<"TrustScore", 'Int'>
    readonly commitmentScore: FieldRef<"TrustScore", 'Int'>
    readonly respectScore: FieldRef<"TrustScore", 'Int'>
    readonly toneConsistencyScore: FieldRef<"TrustScore", 'Int'>
    readonly lastCalculatedAt: FieldRef<"TrustScore", 'DateTime'>
    readonly createdAt: FieldRef<"TrustScore", 'DateTime'>
    readonly updatedAt: FieldRef<"TrustScore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrustScore findUnique
   */
  export type TrustScoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * Filter, which TrustScore to fetch.
     */
    where: TrustScoreWhereUniqueInput
  }

  /**
   * TrustScore findUniqueOrThrow
   */
  export type TrustScoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * Filter, which TrustScore to fetch.
     */
    where: TrustScoreWhereUniqueInput
  }

  /**
   * TrustScore findFirst
   */
  export type TrustScoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * Filter, which TrustScore to fetch.
     */
    where?: TrustScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrustScores to fetch.
     */
    orderBy?: TrustScoreOrderByWithRelationInput | TrustScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrustScores.
     */
    cursor?: TrustScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrustScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrustScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrustScores.
     */
    distinct?: TrustScoreScalarFieldEnum | TrustScoreScalarFieldEnum[]
  }

  /**
   * TrustScore findFirstOrThrow
   */
  export type TrustScoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * Filter, which TrustScore to fetch.
     */
    where?: TrustScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrustScores to fetch.
     */
    orderBy?: TrustScoreOrderByWithRelationInput | TrustScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrustScores.
     */
    cursor?: TrustScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrustScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrustScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrustScores.
     */
    distinct?: TrustScoreScalarFieldEnum | TrustScoreScalarFieldEnum[]
  }

  /**
   * TrustScore findMany
   */
  export type TrustScoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * Filter, which TrustScores to fetch.
     */
    where?: TrustScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrustScores to fetch.
     */
    orderBy?: TrustScoreOrderByWithRelationInput | TrustScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrustScores.
     */
    cursor?: TrustScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrustScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrustScores.
     */
    skip?: number
    distinct?: TrustScoreScalarFieldEnum | TrustScoreScalarFieldEnum[]
  }

  /**
   * TrustScore create
   */
  export type TrustScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * The data needed to create a TrustScore.
     */
    data: XOR<TrustScoreCreateInput, TrustScoreUncheckedCreateInput>
  }

  /**
   * TrustScore createMany
   */
  export type TrustScoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrustScores.
     */
    data: TrustScoreCreateManyInput | TrustScoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrustScore createManyAndReturn
   */
  export type TrustScoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrustScores.
     */
    data: TrustScoreCreateManyInput | TrustScoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrustScore update
   */
  export type TrustScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * The data needed to update a TrustScore.
     */
    data: XOR<TrustScoreUpdateInput, TrustScoreUncheckedUpdateInput>
    /**
     * Choose, which TrustScore to update.
     */
    where: TrustScoreWhereUniqueInput
  }

  /**
   * TrustScore updateMany
   */
  export type TrustScoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrustScores.
     */
    data: XOR<TrustScoreUpdateManyMutationInput, TrustScoreUncheckedUpdateManyInput>
    /**
     * Filter which TrustScores to update
     */
    where?: TrustScoreWhereInput
  }

  /**
   * TrustScore upsert
   */
  export type TrustScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * The filter to search for the TrustScore to update in case it exists.
     */
    where: TrustScoreWhereUniqueInput
    /**
     * In case the TrustScore found by the `where` argument doesn't exist, create a new TrustScore with this data.
     */
    create: XOR<TrustScoreCreateInput, TrustScoreUncheckedCreateInput>
    /**
     * In case the TrustScore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrustScoreUpdateInput, TrustScoreUncheckedUpdateInput>
  }

  /**
   * TrustScore delete
   */
  export type TrustScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
    /**
     * Filter which TrustScore to delete.
     */
    where: TrustScoreWhereUniqueInput
  }

  /**
   * TrustScore deleteMany
   */
  export type TrustScoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrustScores to delete
     */
    where?: TrustScoreWhereInput
  }

  /**
   * TrustScore without action
   */
  export type TrustScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScore
     */
    select?: TrustScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreInclude<ExtArgs> | null
  }


  /**
   * Model BehaviorLog
   */

  export type AggregateBehaviorLog = {
    _count: BehaviorLogCountAggregateOutputType | null
    _avg: BehaviorLogAvgAggregateOutputType | null
    _sum: BehaviorLogSumAggregateOutputType | null
    _min: BehaviorLogMinAggregateOutputType | null
    _max: BehaviorLogMaxAggregateOutputType | null
  }

  export type BehaviorLogAvgAggregateOutputType = {
    score: number | null
  }

  export type BehaviorLogSumAggregateOutputType = {
    score: number | null
  }

  export type BehaviorLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    behaviorType: $Enums.BehaviorType | null
    score: number | null
    createdAt: Date | null
  }

  export type BehaviorLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    behaviorType: $Enums.BehaviorType | null
    score: number | null
    createdAt: Date | null
  }

  export type BehaviorLogCountAggregateOutputType = {
    id: number
    userId: number
    behaviorType: number
    metadata: number
    score: number
    createdAt: number
    _all: number
  }


  export type BehaviorLogAvgAggregateInputType = {
    score?: true
  }

  export type BehaviorLogSumAggregateInputType = {
    score?: true
  }

  export type BehaviorLogMinAggregateInputType = {
    id?: true
    userId?: true
    behaviorType?: true
    score?: true
    createdAt?: true
  }

  export type BehaviorLogMaxAggregateInputType = {
    id?: true
    userId?: true
    behaviorType?: true
    score?: true
    createdAt?: true
  }

  export type BehaviorLogCountAggregateInputType = {
    id?: true
    userId?: true
    behaviorType?: true
    metadata?: true
    score?: true
    createdAt?: true
    _all?: true
  }

  export type BehaviorLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BehaviorLog to aggregate.
     */
    where?: BehaviorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehaviorLogs to fetch.
     */
    orderBy?: BehaviorLogOrderByWithRelationInput | BehaviorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BehaviorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehaviorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehaviorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BehaviorLogs
    **/
    _count?: true | BehaviorLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BehaviorLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BehaviorLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BehaviorLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BehaviorLogMaxAggregateInputType
  }

  export type GetBehaviorLogAggregateType<T extends BehaviorLogAggregateArgs> = {
        [P in keyof T & keyof AggregateBehaviorLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBehaviorLog[P]>
      : GetScalarType<T[P], AggregateBehaviorLog[P]>
  }




  export type BehaviorLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BehaviorLogWhereInput
    orderBy?: BehaviorLogOrderByWithAggregationInput | BehaviorLogOrderByWithAggregationInput[]
    by: BehaviorLogScalarFieldEnum[] | BehaviorLogScalarFieldEnum
    having?: BehaviorLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BehaviorLogCountAggregateInputType | true
    _avg?: BehaviorLogAvgAggregateInputType
    _sum?: BehaviorLogSumAggregateInputType
    _min?: BehaviorLogMinAggregateInputType
    _max?: BehaviorLogMaxAggregateInputType
  }

  export type BehaviorLogGroupByOutputType = {
    id: string
    userId: string
    behaviorType: $Enums.BehaviorType
    metadata: JsonValue | null
    score: number | null
    createdAt: Date
    _count: BehaviorLogCountAggregateOutputType | null
    _avg: BehaviorLogAvgAggregateOutputType | null
    _sum: BehaviorLogSumAggregateOutputType | null
    _min: BehaviorLogMinAggregateOutputType | null
    _max: BehaviorLogMaxAggregateOutputType | null
  }

  type GetBehaviorLogGroupByPayload<T extends BehaviorLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BehaviorLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BehaviorLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BehaviorLogGroupByOutputType[P]>
            : GetScalarType<T[P], BehaviorLogGroupByOutputType[P]>
        }
      >
    >


  export type BehaviorLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    behaviorType?: boolean
    metadata?: boolean
    score?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["behaviorLog"]>

  export type BehaviorLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    behaviorType?: boolean
    metadata?: boolean
    score?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["behaviorLog"]>

  export type BehaviorLogSelectScalar = {
    id?: boolean
    userId?: boolean
    behaviorType?: boolean
    metadata?: boolean
    score?: boolean
    createdAt?: boolean
  }

  export type BehaviorLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BehaviorLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BehaviorLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BehaviorLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      behaviorType: $Enums.BehaviorType
      metadata: Prisma.JsonValue | null
      score: number | null
      createdAt: Date
    }, ExtArgs["result"]["behaviorLog"]>
    composites: {}
  }

  type BehaviorLogGetPayload<S extends boolean | null | undefined | BehaviorLogDefaultArgs> = $Result.GetResult<Prisma.$BehaviorLogPayload, S>

  type BehaviorLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BehaviorLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BehaviorLogCountAggregateInputType | true
    }

  export interface BehaviorLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BehaviorLog'], meta: { name: 'BehaviorLog' } }
    /**
     * Find zero or one BehaviorLog that matches the filter.
     * @param {BehaviorLogFindUniqueArgs} args - Arguments to find a BehaviorLog
     * @example
     * // Get one BehaviorLog
     * const behaviorLog = await prisma.behaviorLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BehaviorLogFindUniqueArgs>(args: SelectSubset<T, BehaviorLogFindUniqueArgs<ExtArgs>>): Prisma__BehaviorLogClient<$Result.GetResult<Prisma.$BehaviorLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BehaviorLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BehaviorLogFindUniqueOrThrowArgs} args - Arguments to find a BehaviorLog
     * @example
     * // Get one BehaviorLog
     * const behaviorLog = await prisma.behaviorLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BehaviorLogFindUniqueOrThrowArgs>(args: SelectSubset<T, BehaviorLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BehaviorLogClient<$Result.GetResult<Prisma.$BehaviorLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BehaviorLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorLogFindFirstArgs} args - Arguments to find a BehaviorLog
     * @example
     * // Get one BehaviorLog
     * const behaviorLog = await prisma.behaviorLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BehaviorLogFindFirstArgs>(args?: SelectSubset<T, BehaviorLogFindFirstArgs<ExtArgs>>): Prisma__BehaviorLogClient<$Result.GetResult<Prisma.$BehaviorLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BehaviorLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorLogFindFirstOrThrowArgs} args - Arguments to find a BehaviorLog
     * @example
     * // Get one BehaviorLog
     * const behaviorLog = await prisma.behaviorLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BehaviorLogFindFirstOrThrowArgs>(args?: SelectSubset<T, BehaviorLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__BehaviorLogClient<$Result.GetResult<Prisma.$BehaviorLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BehaviorLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BehaviorLogs
     * const behaviorLogs = await prisma.behaviorLog.findMany()
     * 
     * // Get first 10 BehaviorLogs
     * const behaviorLogs = await prisma.behaviorLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const behaviorLogWithIdOnly = await prisma.behaviorLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BehaviorLogFindManyArgs>(args?: SelectSubset<T, BehaviorLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehaviorLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BehaviorLog.
     * @param {BehaviorLogCreateArgs} args - Arguments to create a BehaviorLog.
     * @example
     * // Create one BehaviorLog
     * const BehaviorLog = await prisma.behaviorLog.create({
     *   data: {
     *     // ... data to create a BehaviorLog
     *   }
     * })
     * 
     */
    create<T extends BehaviorLogCreateArgs>(args: SelectSubset<T, BehaviorLogCreateArgs<ExtArgs>>): Prisma__BehaviorLogClient<$Result.GetResult<Prisma.$BehaviorLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BehaviorLogs.
     * @param {BehaviorLogCreateManyArgs} args - Arguments to create many BehaviorLogs.
     * @example
     * // Create many BehaviorLogs
     * const behaviorLog = await prisma.behaviorLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BehaviorLogCreateManyArgs>(args?: SelectSubset<T, BehaviorLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BehaviorLogs and returns the data saved in the database.
     * @param {BehaviorLogCreateManyAndReturnArgs} args - Arguments to create many BehaviorLogs.
     * @example
     * // Create many BehaviorLogs
     * const behaviorLog = await prisma.behaviorLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BehaviorLogs and only return the `id`
     * const behaviorLogWithIdOnly = await prisma.behaviorLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BehaviorLogCreateManyAndReturnArgs>(args?: SelectSubset<T, BehaviorLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehaviorLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BehaviorLog.
     * @param {BehaviorLogDeleteArgs} args - Arguments to delete one BehaviorLog.
     * @example
     * // Delete one BehaviorLog
     * const BehaviorLog = await prisma.behaviorLog.delete({
     *   where: {
     *     // ... filter to delete one BehaviorLog
     *   }
     * })
     * 
     */
    delete<T extends BehaviorLogDeleteArgs>(args: SelectSubset<T, BehaviorLogDeleteArgs<ExtArgs>>): Prisma__BehaviorLogClient<$Result.GetResult<Prisma.$BehaviorLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BehaviorLog.
     * @param {BehaviorLogUpdateArgs} args - Arguments to update one BehaviorLog.
     * @example
     * // Update one BehaviorLog
     * const behaviorLog = await prisma.behaviorLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BehaviorLogUpdateArgs>(args: SelectSubset<T, BehaviorLogUpdateArgs<ExtArgs>>): Prisma__BehaviorLogClient<$Result.GetResult<Prisma.$BehaviorLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BehaviorLogs.
     * @param {BehaviorLogDeleteManyArgs} args - Arguments to filter BehaviorLogs to delete.
     * @example
     * // Delete a few BehaviorLogs
     * const { count } = await prisma.behaviorLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BehaviorLogDeleteManyArgs>(args?: SelectSubset<T, BehaviorLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BehaviorLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BehaviorLogs
     * const behaviorLog = await prisma.behaviorLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BehaviorLogUpdateManyArgs>(args: SelectSubset<T, BehaviorLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BehaviorLog.
     * @param {BehaviorLogUpsertArgs} args - Arguments to update or create a BehaviorLog.
     * @example
     * // Update or create a BehaviorLog
     * const behaviorLog = await prisma.behaviorLog.upsert({
     *   create: {
     *     // ... data to create a BehaviorLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BehaviorLog we want to update
     *   }
     * })
     */
    upsert<T extends BehaviorLogUpsertArgs>(args: SelectSubset<T, BehaviorLogUpsertArgs<ExtArgs>>): Prisma__BehaviorLogClient<$Result.GetResult<Prisma.$BehaviorLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BehaviorLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorLogCountArgs} args - Arguments to filter BehaviorLogs to count.
     * @example
     * // Count the number of BehaviorLogs
     * const count = await prisma.behaviorLog.count({
     *   where: {
     *     // ... the filter for the BehaviorLogs we want to count
     *   }
     * })
    **/
    count<T extends BehaviorLogCountArgs>(
      args?: Subset<T, BehaviorLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BehaviorLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BehaviorLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BehaviorLogAggregateArgs>(args: Subset<T, BehaviorLogAggregateArgs>): Prisma.PrismaPromise<GetBehaviorLogAggregateType<T>>

    /**
     * Group by BehaviorLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BehaviorLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BehaviorLogGroupByArgs['orderBy'] }
        : { orderBy?: BehaviorLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BehaviorLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBehaviorLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BehaviorLog model
   */
  readonly fields: BehaviorLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BehaviorLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BehaviorLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BehaviorLog model
   */ 
  interface BehaviorLogFieldRefs {
    readonly id: FieldRef<"BehaviorLog", 'String'>
    readonly userId: FieldRef<"BehaviorLog", 'String'>
    readonly behaviorType: FieldRef<"BehaviorLog", 'BehaviorType'>
    readonly metadata: FieldRef<"BehaviorLog", 'Json'>
    readonly score: FieldRef<"BehaviorLog", 'Int'>
    readonly createdAt: FieldRef<"BehaviorLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BehaviorLog findUnique
   */
  export type BehaviorLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorLog
     */
    select?: BehaviorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorLogInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorLog to fetch.
     */
    where: BehaviorLogWhereUniqueInput
  }

  /**
   * BehaviorLog findUniqueOrThrow
   */
  export type BehaviorLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorLog
     */
    select?: BehaviorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorLogInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorLog to fetch.
     */
    where: BehaviorLogWhereUniqueInput
  }

  /**
   * BehaviorLog findFirst
   */
  export type BehaviorLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorLog
     */
    select?: BehaviorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorLogInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorLog to fetch.
     */
    where?: BehaviorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehaviorLogs to fetch.
     */
    orderBy?: BehaviorLogOrderByWithRelationInput | BehaviorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BehaviorLogs.
     */
    cursor?: BehaviorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehaviorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehaviorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BehaviorLogs.
     */
    distinct?: BehaviorLogScalarFieldEnum | BehaviorLogScalarFieldEnum[]
  }

  /**
   * BehaviorLog findFirstOrThrow
   */
  export type BehaviorLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorLog
     */
    select?: BehaviorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorLogInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorLog to fetch.
     */
    where?: BehaviorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehaviorLogs to fetch.
     */
    orderBy?: BehaviorLogOrderByWithRelationInput | BehaviorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BehaviorLogs.
     */
    cursor?: BehaviorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehaviorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehaviorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BehaviorLogs.
     */
    distinct?: BehaviorLogScalarFieldEnum | BehaviorLogScalarFieldEnum[]
  }

  /**
   * BehaviorLog findMany
   */
  export type BehaviorLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorLog
     */
    select?: BehaviorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorLogInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorLogs to fetch.
     */
    where?: BehaviorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehaviorLogs to fetch.
     */
    orderBy?: BehaviorLogOrderByWithRelationInput | BehaviorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BehaviorLogs.
     */
    cursor?: BehaviorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehaviorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehaviorLogs.
     */
    skip?: number
    distinct?: BehaviorLogScalarFieldEnum | BehaviorLogScalarFieldEnum[]
  }

  /**
   * BehaviorLog create
   */
  export type BehaviorLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorLog
     */
    select?: BehaviorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorLogInclude<ExtArgs> | null
    /**
     * The data needed to create a BehaviorLog.
     */
    data: XOR<BehaviorLogCreateInput, BehaviorLogUncheckedCreateInput>
  }

  /**
   * BehaviorLog createMany
   */
  export type BehaviorLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BehaviorLogs.
     */
    data: BehaviorLogCreateManyInput | BehaviorLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BehaviorLog createManyAndReturn
   */
  export type BehaviorLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorLog
     */
    select?: BehaviorLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BehaviorLogs.
     */
    data: BehaviorLogCreateManyInput | BehaviorLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BehaviorLog update
   */
  export type BehaviorLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorLog
     */
    select?: BehaviorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorLogInclude<ExtArgs> | null
    /**
     * The data needed to update a BehaviorLog.
     */
    data: XOR<BehaviorLogUpdateInput, BehaviorLogUncheckedUpdateInput>
    /**
     * Choose, which BehaviorLog to update.
     */
    where: BehaviorLogWhereUniqueInput
  }

  /**
   * BehaviorLog updateMany
   */
  export type BehaviorLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BehaviorLogs.
     */
    data: XOR<BehaviorLogUpdateManyMutationInput, BehaviorLogUncheckedUpdateManyInput>
    /**
     * Filter which BehaviorLogs to update
     */
    where?: BehaviorLogWhereInput
  }

  /**
   * BehaviorLog upsert
   */
  export type BehaviorLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorLog
     */
    select?: BehaviorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorLogInclude<ExtArgs> | null
    /**
     * The filter to search for the BehaviorLog to update in case it exists.
     */
    where: BehaviorLogWhereUniqueInput
    /**
     * In case the BehaviorLog found by the `where` argument doesn't exist, create a new BehaviorLog with this data.
     */
    create: XOR<BehaviorLogCreateInput, BehaviorLogUncheckedCreateInput>
    /**
     * In case the BehaviorLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BehaviorLogUpdateInput, BehaviorLogUncheckedUpdateInput>
  }

  /**
   * BehaviorLog delete
   */
  export type BehaviorLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorLog
     */
    select?: BehaviorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorLogInclude<ExtArgs> | null
    /**
     * Filter which BehaviorLog to delete.
     */
    where: BehaviorLogWhereUniqueInput
  }

  /**
   * BehaviorLog deleteMany
   */
  export type BehaviorLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BehaviorLogs to delete
     */
    where?: BehaviorLogWhereInput
  }

  /**
   * BehaviorLog without action
   */
  export type BehaviorLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorLog
     */
    select?: BehaviorLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorLogInclude<ExtArgs> | null
  }


  /**
   * Model RiskAssessment
   */

  export type AggregateRiskAssessment = {
    _count: RiskAssessmentCountAggregateOutputType | null
    _avg: RiskAssessmentAvgAggregateOutputType | null
    _sum: RiskAssessmentSumAggregateOutputType | null
    _min: RiskAssessmentMinAggregateOutputType | null
    _max: RiskAssessmentMaxAggregateOutputType | null
  }

  export type RiskAssessmentAvgAggregateOutputType = {
    riskIndex: number | null
    reportScore: number | null
    messageRiskScore: number | null
    patternRiskScore: number | null
  }

  export type RiskAssessmentSumAggregateOutputType = {
    riskIndex: number | null
    reportScore: number | null
    messageRiskScore: number | null
    patternRiskScore: number | null
  }

  export type RiskAssessmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    riskIndex: number | null
    riskLevel: $Enums.RiskLevel | null
    reportScore: number | null
    messageRiskScore: number | null
    patternRiskScore: number | null
    isRestricted: boolean | null
    lastAssessedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RiskAssessmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    riskIndex: number | null
    riskLevel: $Enums.RiskLevel | null
    reportScore: number | null
    messageRiskScore: number | null
    patternRiskScore: number | null
    isRestricted: boolean | null
    lastAssessedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RiskAssessmentCountAggregateOutputType = {
    id: number
    userId: number
    riskIndex: number
    riskLevel: number
    reportScore: number
    messageRiskScore: number
    patternRiskScore: number
    isRestricted: number
    restrictions: number
    lastAssessedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RiskAssessmentAvgAggregateInputType = {
    riskIndex?: true
    reportScore?: true
    messageRiskScore?: true
    patternRiskScore?: true
  }

  export type RiskAssessmentSumAggregateInputType = {
    riskIndex?: true
    reportScore?: true
    messageRiskScore?: true
    patternRiskScore?: true
  }

  export type RiskAssessmentMinAggregateInputType = {
    id?: true
    userId?: true
    riskIndex?: true
    riskLevel?: true
    reportScore?: true
    messageRiskScore?: true
    patternRiskScore?: true
    isRestricted?: true
    lastAssessedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RiskAssessmentMaxAggregateInputType = {
    id?: true
    userId?: true
    riskIndex?: true
    riskLevel?: true
    reportScore?: true
    messageRiskScore?: true
    patternRiskScore?: true
    isRestricted?: true
    lastAssessedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RiskAssessmentCountAggregateInputType = {
    id?: true
    userId?: true
    riskIndex?: true
    riskLevel?: true
    reportScore?: true
    messageRiskScore?: true
    patternRiskScore?: true
    isRestricted?: true
    restrictions?: true
    lastAssessedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RiskAssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskAssessment to aggregate.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskAssessments
    **/
    _count?: true | RiskAssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RiskAssessmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RiskAssessmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskAssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskAssessmentMaxAggregateInputType
  }

  export type GetRiskAssessmentAggregateType<T extends RiskAssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskAssessment[P]>
      : GetScalarType<T[P], AggregateRiskAssessment[P]>
  }




  export type RiskAssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskAssessmentWhereInput
    orderBy?: RiskAssessmentOrderByWithAggregationInput | RiskAssessmentOrderByWithAggregationInput[]
    by: RiskAssessmentScalarFieldEnum[] | RiskAssessmentScalarFieldEnum
    having?: RiskAssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskAssessmentCountAggregateInputType | true
    _avg?: RiskAssessmentAvgAggregateInputType
    _sum?: RiskAssessmentSumAggregateInputType
    _min?: RiskAssessmentMinAggregateInputType
    _max?: RiskAssessmentMaxAggregateInputType
  }

  export type RiskAssessmentGroupByOutputType = {
    id: string
    userId: string
    riskIndex: number
    riskLevel: $Enums.RiskLevel
    reportScore: number
    messageRiskScore: number
    patternRiskScore: number
    isRestricted: boolean
    restrictions: JsonValue | null
    lastAssessedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: RiskAssessmentCountAggregateOutputType | null
    _avg: RiskAssessmentAvgAggregateOutputType | null
    _sum: RiskAssessmentSumAggregateOutputType | null
    _min: RiskAssessmentMinAggregateOutputType | null
    _max: RiskAssessmentMaxAggregateOutputType | null
  }

  type GetRiskAssessmentGroupByPayload<T extends RiskAssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskAssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskAssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskAssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], RiskAssessmentGroupByOutputType[P]>
        }
      >
    >


  export type RiskAssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    riskIndex?: boolean
    riskLevel?: boolean
    reportScore?: boolean
    messageRiskScore?: boolean
    patternRiskScore?: boolean
    isRestricted?: boolean
    restrictions?: boolean
    lastAssessedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskAssessment"]>

  export type RiskAssessmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    riskIndex?: boolean
    riskLevel?: boolean
    reportScore?: boolean
    messageRiskScore?: boolean
    patternRiskScore?: boolean
    isRestricted?: boolean
    restrictions?: boolean
    lastAssessedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["riskAssessment"]>

  export type RiskAssessmentSelectScalar = {
    id?: boolean
    userId?: boolean
    riskIndex?: boolean
    riskLevel?: boolean
    reportScore?: boolean
    messageRiskScore?: boolean
    patternRiskScore?: boolean
    isRestricted?: boolean
    restrictions?: boolean
    lastAssessedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RiskAssessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RiskAssessmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RiskAssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskAssessment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      riskIndex: number
      riskLevel: $Enums.RiskLevel
      reportScore: number
      messageRiskScore: number
      patternRiskScore: number
      isRestricted: boolean
      restrictions: Prisma.JsonValue | null
      lastAssessedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["riskAssessment"]>
    composites: {}
  }

  type RiskAssessmentGetPayload<S extends boolean | null | undefined | RiskAssessmentDefaultArgs> = $Result.GetResult<Prisma.$RiskAssessmentPayload, S>

  type RiskAssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RiskAssessmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RiskAssessmentCountAggregateInputType | true
    }

  export interface RiskAssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskAssessment'], meta: { name: 'RiskAssessment' } }
    /**
     * Find zero or one RiskAssessment that matches the filter.
     * @param {RiskAssessmentFindUniqueArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskAssessmentFindUniqueArgs>(args: SelectSubset<T, RiskAssessmentFindUniqueArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RiskAssessment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RiskAssessmentFindUniqueOrThrowArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskAssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskAssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RiskAssessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindFirstArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskAssessmentFindFirstArgs>(args?: SelectSubset<T, RiskAssessmentFindFirstArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RiskAssessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindFirstOrThrowArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskAssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskAssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RiskAssessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskAssessments
     * const riskAssessments = await prisma.riskAssessment.findMany()
     * 
     * // Get first 10 RiskAssessments
     * const riskAssessments = await prisma.riskAssessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskAssessmentWithIdOnly = await prisma.riskAssessment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskAssessmentFindManyArgs>(args?: SelectSubset<T, RiskAssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RiskAssessment.
     * @param {RiskAssessmentCreateArgs} args - Arguments to create a RiskAssessment.
     * @example
     * // Create one RiskAssessment
     * const RiskAssessment = await prisma.riskAssessment.create({
     *   data: {
     *     // ... data to create a RiskAssessment
     *   }
     * })
     * 
     */
    create<T extends RiskAssessmentCreateArgs>(args: SelectSubset<T, RiskAssessmentCreateArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RiskAssessments.
     * @param {RiskAssessmentCreateManyArgs} args - Arguments to create many RiskAssessments.
     * @example
     * // Create many RiskAssessments
     * const riskAssessment = await prisma.riskAssessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskAssessmentCreateManyArgs>(args?: SelectSubset<T, RiskAssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskAssessments and returns the data saved in the database.
     * @param {RiskAssessmentCreateManyAndReturnArgs} args - Arguments to create many RiskAssessments.
     * @example
     * // Create many RiskAssessments
     * const riskAssessment = await prisma.riskAssessment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskAssessments and only return the `id`
     * const riskAssessmentWithIdOnly = await prisma.riskAssessment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskAssessmentCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskAssessmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RiskAssessment.
     * @param {RiskAssessmentDeleteArgs} args - Arguments to delete one RiskAssessment.
     * @example
     * // Delete one RiskAssessment
     * const RiskAssessment = await prisma.riskAssessment.delete({
     *   where: {
     *     // ... filter to delete one RiskAssessment
     *   }
     * })
     * 
     */
    delete<T extends RiskAssessmentDeleteArgs>(args: SelectSubset<T, RiskAssessmentDeleteArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RiskAssessment.
     * @param {RiskAssessmentUpdateArgs} args - Arguments to update one RiskAssessment.
     * @example
     * // Update one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskAssessmentUpdateArgs>(args: SelectSubset<T, RiskAssessmentUpdateArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RiskAssessments.
     * @param {RiskAssessmentDeleteManyArgs} args - Arguments to filter RiskAssessments to delete.
     * @example
     * // Delete a few RiskAssessments
     * const { count } = await prisma.riskAssessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskAssessmentDeleteManyArgs>(args?: SelectSubset<T, RiskAssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskAssessments
     * const riskAssessment = await prisma.riskAssessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskAssessmentUpdateManyArgs>(args: SelectSubset<T, RiskAssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RiskAssessment.
     * @param {RiskAssessmentUpsertArgs} args - Arguments to update or create a RiskAssessment.
     * @example
     * // Update or create a RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.upsert({
     *   create: {
     *     // ... data to create a RiskAssessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskAssessment we want to update
     *   }
     * })
     */
    upsert<T extends RiskAssessmentUpsertArgs>(args: SelectSubset<T, RiskAssessmentUpsertArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RiskAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentCountArgs} args - Arguments to filter RiskAssessments to count.
     * @example
     * // Count the number of RiskAssessments
     * const count = await prisma.riskAssessment.count({
     *   where: {
     *     // ... the filter for the RiskAssessments we want to count
     *   }
     * })
    **/
    count<T extends RiskAssessmentCountArgs>(
      args?: Subset<T, RiskAssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskAssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskAssessmentAggregateArgs>(args: Subset<T, RiskAssessmentAggregateArgs>): Prisma.PrismaPromise<GetRiskAssessmentAggregateType<T>>

    /**
     * Group by RiskAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskAssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskAssessmentGroupByArgs['orderBy'] }
        : { orderBy?: RiskAssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskAssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskAssessment model
   */
  readonly fields: RiskAssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskAssessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskAssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskAssessment model
   */ 
  interface RiskAssessmentFieldRefs {
    readonly id: FieldRef<"RiskAssessment", 'String'>
    readonly userId: FieldRef<"RiskAssessment", 'String'>
    readonly riskIndex: FieldRef<"RiskAssessment", 'Int'>
    readonly riskLevel: FieldRef<"RiskAssessment", 'RiskLevel'>
    readonly reportScore: FieldRef<"RiskAssessment", 'Int'>
    readonly messageRiskScore: FieldRef<"RiskAssessment", 'Int'>
    readonly patternRiskScore: FieldRef<"RiskAssessment", 'Int'>
    readonly isRestricted: FieldRef<"RiskAssessment", 'Boolean'>
    readonly restrictions: FieldRef<"RiskAssessment", 'Json'>
    readonly lastAssessedAt: FieldRef<"RiskAssessment", 'DateTime'>
    readonly createdAt: FieldRef<"RiskAssessment", 'DateTime'>
    readonly updatedAt: FieldRef<"RiskAssessment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RiskAssessment findUnique
   */
  export type RiskAssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment findUniqueOrThrow
   */
  export type RiskAssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment findFirst
   */
  export type RiskAssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskAssessments.
     */
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }

  /**
   * RiskAssessment findFirstOrThrow
   */
  export type RiskAssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskAssessments.
     */
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }

  /**
   * RiskAssessment findMany
   */
  export type RiskAssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which RiskAssessments to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }

  /**
   * RiskAssessment create
   */
  export type RiskAssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a RiskAssessment.
     */
    data: XOR<RiskAssessmentCreateInput, RiskAssessmentUncheckedCreateInput>
  }

  /**
   * RiskAssessment createMany
   */
  export type RiskAssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskAssessments.
     */
    data: RiskAssessmentCreateManyInput | RiskAssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskAssessment createManyAndReturn
   */
  export type RiskAssessmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RiskAssessments.
     */
    data: RiskAssessmentCreateManyInput | RiskAssessmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RiskAssessment update
   */
  export type RiskAssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a RiskAssessment.
     */
    data: XOR<RiskAssessmentUpdateInput, RiskAssessmentUncheckedUpdateInput>
    /**
     * Choose, which RiskAssessment to update.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment updateMany
   */
  export type RiskAssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskAssessments.
     */
    data: XOR<RiskAssessmentUpdateManyMutationInput, RiskAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which RiskAssessments to update
     */
    where?: RiskAssessmentWhereInput
  }

  /**
   * RiskAssessment upsert
   */
  export type RiskAssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the RiskAssessment to update in case it exists.
     */
    where: RiskAssessmentWhereUniqueInput
    /**
     * In case the RiskAssessment found by the `where` argument doesn't exist, create a new RiskAssessment with this data.
     */
    create: XOR<RiskAssessmentCreateInput, RiskAssessmentUncheckedCreateInput>
    /**
     * In case the RiskAssessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskAssessmentUpdateInput, RiskAssessmentUncheckedUpdateInput>
  }

  /**
   * RiskAssessment delete
   */
  export type RiskAssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter which RiskAssessment to delete.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment deleteMany
   */
  export type RiskAssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskAssessments to delete
     */
    where?: RiskAssessmentWhereInput
  }

  /**
   * RiskAssessment without action
   */
  export type RiskAssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RiskAssessmentInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    reporterId: string | null
    reportedUserId: string | null
    type: $Enums.ReportType | null
    description: string | null
    status: $Enums.ReportStatus | null
    reviewNotes: string | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    reporterId: string | null
    reportedUserId: string | null
    type: $Enums.ReportType | null
    description: string | null
    status: $Enums.ReportStatus | null
    reviewNotes: string | null
    reviewedAt: Date | null
    createdAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    reporterId: number
    reportedUserId: number
    type: number
    description: number
    evidence: number
    status: number
    reviewNotes: number
    reviewedAt: number
    createdAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    reporterId?: true
    reportedUserId?: true
    type?: true
    description?: true
    status?: true
    reviewNotes?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    reporterId?: true
    reportedUserId?: true
    type?: true
    description?: true
    status?: true
    reviewNotes?: true
    reviewedAt?: true
    createdAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    reporterId?: true
    reportedUserId?: true
    type?: true
    description?: true
    evidence?: true
    status?: true
    reviewNotes?: true
    reviewedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    reporterId: string
    reportedUserId: string
    type: $Enums.ReportType
    description: string | null
    evidence: JsonValue | null
    status: $Enums.ReportStatus
    reviewNotes: string | null
    reviewedAt: Date | null
    createdAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    type?: boolean
    description?: boolean
    evidence?: boolean
    status?: boolean
    reviewNotes?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    reportedUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    type?: boolean
    description?: boolean
    evidence?: boolean
    status?: boolean
    reviewNotes?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    reportedUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    type?: boolean
    description?: boolean
    evidence?: boolean
    status?: boolean
    reviewNotes?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    reportedUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    reportedUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      reporter: Prisma.$UserPayload<ExtArgs>
      reportedUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reporterId: string
      reportedUserId: string
      type: $Enums.ReportType
      description: string | null
      evidence: Prisma.JsonValue | null
      status: $Enums.ReportStatus
      reviewNotes: string | null
      reviewedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reporter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reportedUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly reporterId: FieldRef<"Report", 'String'>
    readonly reportedUserId: FieldRef<"Report", 'String'>
    readonly type: FieldRef<"Report", 'ReportType'>
    readonly description: FieldRef<"Report", 'String'>
    readonly evidence: FieldRef<"Report", 'Json'>
    readonly status: FieldRef<"Report", 'ReportStatus'>
    readonly reviewNotes: FieldRef<"Report", 'String'>
    readonly reviewedAt: FieldRef<"Report", 'DateTime'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model SafetySignal
   */

  export type AggregateSafetySignal = {
    _count: SafetySignalCountAggregateOutputType | null
    _min: SafetySignalMinAggregateOutputType | null
    _max: SafetySignalMaxAggregateOutputType | null
  }

  export type SafetySignalMinAggregateOutputType = {
    id: string | null
    userId: string | null
    signalType: $Enums.SafetySignalType | null
    verifiedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SafetySignalMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    signalType: $Enums.SafetySignalType | null
    verifiedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SafetySignalCountAggregateOutputType = {
    id: number
    userId: number
    signalType: number
    verifiedAt: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SafetySignalMinAggregateInputType = {
    id?: true
    userId?: true
    signalType?: true
    verifiedAt?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SafetySignalMaxAggregateInputType = {
    id?: true
    userId?: true
    signalType?: true
    verifiedAt?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SafetySignalCountAggregateInputType = {
    id?: true
    userId?: true
    signalType?: true
    verifiedAt?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SafetySignalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SafetySignal to aggregate.
     */
    where?: SafetySignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetySignals to fetch.
     */
    orderBy?: SafetySignalOrderByWithRelationInput | SafetySignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SafetySignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetySignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetySignals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SafetySignals
    **/
    _count?: true | SafetySignalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SafetySignalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SafetySignalMaxAggregateInputType
  }

  export type GetSafetySignalAggregateType<T extends SafetySignalAggregateArgs> = {
        [P in keyof T & keyof AggregateSafetySignal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSafetySignal[P]>
      : GetScalarType<T[P], AggregateSafetySignal[P]>
  }




  export type SafetySignalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SafetySignalWhereInput
    orderBy?: SafetySignalOrderByWithAggregationInput | SafetySignalOrderByWithAggregationInput[]
    by: SafetySignalScalarFieldEnum[] | SafetySignalScalarFieldEnum
    having?: SafetySignalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SafetySignalCountAggregateInputType | true
    _min?: SafetySignalMinAggregateInputType
    _max?: SafetySignalMaxAggregateInputType
  }

  export type SafetySignalGroupByOutputType = {
    id: string
    userId: string
    signalType: $Enums.SafetySignalType
    verifiedAt: Date
    expiresAt: Date | null
    createdAt: Date
    _count: SafetySignalCountAggregateOutputType | null
    _min: SafetySignalMinAggregateOutputType | null
    _max: SafetySignalMaxAggregateOutputType | null
  }

  type GetSafetySignalGroupByPayload<T extends SafetySignalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SafetySignalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SafetySignalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SafetySignalGroupByOutputType[P]>
            : GetScalarType<T[P], SafetySignalGroupByOutputType[P]>
        }
      >
    >


  export type SafetySignalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    signalType?: boolean
    verifiedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["safetySignal"]>

  export type SafetySignalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    signalType?: boolean
    verifiedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["safetySignal"]>

  export type SafetySignalSelectScalar = {
    id?: boolean
    userId?: boolean
    signalType?: boolean
    verifiedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type SafetySignalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SafetySignalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SafetySignalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SafetySignal"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      signalType: $Enums.SafetySignalType
      verifiedAt: Date
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["safetySignal"]>
    composites: {}
  }

  type SafetySignalGetPayload<S extends boolean | null | undefined | SafetySignalDefaultArgs> = $Result.GetResult<Prisma.$SafetySignalPayload, S>

  type SafetySignalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SafetySignalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SafetySignalCountAggregateInputType | true
    }

  export interface SafetySignalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SafetySignal'], meta: { name: 'SafetySignal' } }
    /**
     * Find zero or one SafetySignal that matches the filter.
     * @param {SafetySignalFindUniqueArgs} args - Arguments to find a SafetySignal
     * @example
     * // Get one SafetySignal
     * const safetySignal = await prisma.safetySignal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SafetySignalFindUniqueArgs>(args: SelectSubset<T, SafetySignalFindUniqueArgs<ExtArgs>>): Prisma__SafetySignalClient<$Result.GetResult<Prisma.$SafetySignalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SafetySignal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SafetySignalFindUniqueOrThrowArgs} args - Arguments to find a SafetySignal
     * @example
     * // Get one SafetySignal
     * const safetySignal = await prisma.safetySignal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SafetySignalFindUniqueOrThrowArgs>(args: SelectSubset<T, SafetySignalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SafetySignalClient<$Result.GetResult<Prisma.$SafetySignalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SafetySignal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetySignalFindFirstArgs} args - Arguments to find a SafetySignal
     * @example
     * // Get one SafetySignal
     * const safetySignal = await prisma.safetySignal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SafetySignalFindFirstArgs>(args?: SelectSubset<T, SafetySignalFindFirstArgs<ExtArgs>>): Prisma__SafetySignalClient<$Result.GetResult<Prisma.$SafetySignalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SafetySignal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetySignalFindFirstOrThrowArgs} args - Arguments to find a SafetySignal
     * @example
     * // Get one SafetySignal
     * const safetySignal = await prisma.safetySignal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SafetySignalFindFirstOrThrowArgs>(args?: SelectSubset<T, SafetySignalFindFirstOrThrowArgs<ExtArgs>>): Prisma__SafetySignalClient<$Result.GetResult<Prisma.$SafetySignalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SafetySignals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetySignalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SafetySignals
     * const safetySignals = await prisma.safetySignal.findMany()
     * 
     * // Get first 10 SafetySignals
     * const safetySignals = await prisma.safetySignal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const safetySignalWithIdOnly = await prisma.safetySignal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SafetySignalFindManyArgs>(args?: SelectSubset<T, SafetySignalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetySignalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SafetySignal.
     * @param {SafetySignalCreateArgs} args - Arguments to create a SafetySignal.
     * @example
     * // Create one SafetySignal
     * const SafetySignal = await prisma.safetySignal.create({
     *   data: {
     *     // ... data to create a SafetySignal
     *   }
     * })
     * 
     */
    create<T extends SafetySignalCreateArgs>(args: SelectSubset<T, SafetySignalCreateArgs<ExtArgs>>): Prisma__SafetySignalClient<$Result.GetResult<Prisma.$SafetySignalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SafetySignals.
     * @param {SafetySignalCreateManyArgs} args - Arguments to create many SafetySignals.
     * @example
     * // Create many SafetySignals
     * const safetySignal = await prisma.safetySignal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SafetySignalCreateManyArgs>(args?: SelectSubset<T, SafetySignalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SafetySignals and returns the data saved in the database.
     * @param {SafetySignalCreateManyAndReturnArgs} args - Arguments to create many SafetySignals.
     * @example
     * // Create many SafetySignals
     * const safetySignal = await prisma.safetySignal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SafetySignals and only return the `id`
     * const safetySignalWithIdOnly = await prisma.safetySignal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SafetySignalCreateManyAndReturnArgs>(args?: SelectSubset<T, SafetySignalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetySignalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SafetySignal.
     * @param {SafetySignalDeleteArgs} args - Arguments to delete one SafetySignal.
     * @example
     * // Delete one SafetySignal
     * const SafetySignal = await prisma.safetySignal.delete({
     *   where: {
     *     // ... filter to delete one SafetySignal
     *   }
     * })
     * 
     */
    delete<T extends SafetySignalDeleteArgs>(args: SelectSubset<T, SafetySignalDeleteArgs<ExtArgs>>): Prisma__SafetySignalClient<$Result.GetResult<Prisma.$SafetySignalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SafetySignal.
     * @param {SafetySignalUpdateArgs} args - Arguments to update one SafetySignal.
     * @example
     * // Update one SafetySignal
     * const safetySignal = await prisma.safetySignal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SafetySignalUpdateArgs>(args: SelectSubset<T, SafetySignalUpdateArgs<ExtArgs>>): Prisma__SafetySignalClient<$Result.GetResult<Prisma.$SafetySignalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SafetySignals.
     * @param {SafetySignalDeleteManyArgs} args - Arguments to filter SafetySignals to delete.
     * @example
     * // Delete a few SafetySignals
     * const { count } = await prisma.safetySignal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SafetySignalDeleteManyArgs>(args?: SelectSubset<T, SafetySignalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SafetySignals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetySignalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SafetySignals
     * const safetySignal = await prisma.safetySignal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SafetySignalUpdateManyArgs>(args: SelectSubset<T, SafetySignalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SafetySignal.
     * @param {SafetySignalUpsertArgs} args - Arguments to update or create a SafetySignal.
     * @example
     * // Update or create a SafetySignal
     * const safetySignal = await prisma.safetySignal.upsert({
     *   create: {
     *     // ... data to create a SafetySignal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SafetySignal we want to update
     *   }
     * })
     */
    upsert<T extends SafetySignalUpsertArgs>(args: SelectSubset<T, SafetySignalUpsertArgs<ExtArgs>>): Prisma__SafetySignalClient<$Result.GetResult<Prisma.$SafetySignalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SafetySignals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetySignalCountArgs} args - Arguments to filter SafetySignals to count.
     * @example
     * // Count the number of SafetySignals
     * const count = await prisma.safetySignal.count({
     *   where: {
     *     // ... the filter for the SafetySignals we want to count
     *   }
     * })
    **/
    count<T extends SafetySignalCountArgs>(
      args?: Subset<T, SafetySignalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SafetySignalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SafetySignal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetySignalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SafetySignalAggregateArgs>(args: Subset<T, SafetySignalAggregateArgs>): Prisma.PrismaPromise<GetSafetySignalAggregateType<T>>

    /**
     * Group by SafetySignal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetySignalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SafetySignalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SafetySignalGroupByArgs['orderBy'] }
        : { orderBy?: SafetySignalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SafetySignalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSafetySignalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SafetySignal model
   */
  readonly fields: SafetySignalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SafetySignal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SafetySignalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SafetySignal model
   */ 
  interface SafetySignalFieldRefs {
    readonly id: FieldRef<"SafetySignal", 'String'>
    readonly userId: FieldRef<"SafetySignal", 'String'>
    readonly signalType: FieldRef<"SafetySignal", 'SafetySignalType'>
    readonly verifiedAt: FieldRef<"SafetySignal", 'DateTime'>
    readonly expiresAt: FieldRef<"SafetySignal", 'DateTime'>
    readonly createdAt: FieldRef<"SafetySignal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SafetySignal findUnique
   */
  export type SafetySignalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetySignal
     */
    select?: SafetySignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetySignalInclude<ExtArgs> | null
    /**
     * Filter, which SafetySignal to fetch.
     */
    where: SafetySignalWhereUniqueInput
  }

  /**
   * SafetySignal findUniqueOrThrow
   */
  export type SafetySignalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetySignal
     */
    select?: SafetySignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetySignalInclude<ExtArgs> | null
    /**
     * Filter, which SafetySignal to fetch.
     */
    where: SafetySignalWhereUniqueInput
  }

  /**
   * SafetySignal findFirst
   */
  export type SafetySignalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetySignal
     */
    select?: SafetySignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetySignalInclude<ExtArgs> | null
    /**
     * Filter, which SafetySignal to fetch.
     */
    where?: SafetySignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetySignals to fetch.
     */
    orderBy?: SafetySignalOrderByWithRelationInput | SafetySignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SafetySignals.
     */
    cursor?: SafetySignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetySignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetySignals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SafetySignals.
     */
    distinct?: SafetySignalScalarFieldEnum | SafetySignalScalarFieldEnum[]
  }

  /**
   * SafetySignal findFirstOrThrow
   */
  export type SafetySignalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetySignal
     */
    select?: SafetySignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetySignalInclude<ExtArgs> | null
    /**
     * Filter, which SafetySignal to fetch.
     */
    where?: SafetySignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetySignals to fetch.
     */
    orderBy?: SafetySignalOrderByWithRelationInput | SafetySignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SafetySignals.
     */
    cursor?: SafetySignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetySignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetySignals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SafetySignals.
     */
    distinct?: SafetySignalScalarFieldEnum | SafetySignalScalarFieldEnum[]
  }

  /**
   * SafetySignal findMany
   */
  export type SafetySignalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetySignal
     */
    select?: SafetySignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetySignalInclude<ExtArgs> | null
    /**
     * Filter, which SafetySignals to fetch.
     */
    where?: SafetySignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetySignals to fetch.
     */
    orderBy?: SafetySignalOrderByWithRelationInput | SafetySignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SafetySignals.
     */
    cursor?: SafetySignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetySignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetySignals.
     */
    skip?: number
    distinct?: SafetySignalScalarFieldEnum | SafetySignalScalarFieldEnum[]
  }

  /**
   * SafetySignal create
   */
  export type SafetySignalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetySignal
     */
    select?: SafetySignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetySignalInclude<ExtArgs> | null
    /**
     * The data needed to create a SafetySignal.
     */
    data: XOR<SafetySignalCreateInput, SafetySignalUncheckedCreateInput>
  }

  /**
   * SafetySignal createMany
   */
  export type SafetySignalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SafetySignals.
     */
    data: SafetySignalCreateManyInput | SafetySignalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SafetySignal createManyAndReturn
   */
  export type SafetySignalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetySignal
     */
    select?: SafetySignalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SafetySignals.
     */
    data: SafetySignalCreateManyInput | SafetySignalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetySignalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SafetySignal update
   */
  export type SafetySignalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetySignal
     */
    select?: SafetySignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetySignalInclude<ExtArgs> | null
    /**
     * The data needed to update a SafetySignal.
     */
    data: XOR<SafetySignalUpdateInput, SafetySignalUncheckedUpdateInput>
    /**
     * Choose, which SafetySignal to update.
     */
    where: SafetySignalWhereUniqueInput
  }

  /**
   * SafetySignal updateMany
   */
  export type SafetySignalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SafetySignals.
     */
    data: XOR<SafetySignalUpdateManyMutationInput, SafetySignalUncheckedUpdateManyInput>
    /**
     * Filter which SafetySignals to update
     */
    where?: SafetySignalWhereInput
  }

  /**
   * SafetySignal upsert
   */
  export type SafetySignalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetySignal
     */
    select?: SafetySignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetySignalInclude<ExtArgs> | null
    /**
     * The filter to search for the SafetySignal to update in case it exists.
     */
    where: SafetySignalWhereUniqueInput
    /**
     * In case the SafetySignal found by the `where` argument doesn't exist, create a new SafetySignal with this data.
     */
    create: XOR<SafetySignalCreateInput, SafetySignalUncheckedCreateInput>
    /**
     * In case the SafetySignal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SafetySignalUpdateInput, SafetySignalUncheckedUpdateInput>
  }

  /**
   * SafetySignal delete
   */
  export type SafetySignalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetySignal
     */
    select?: SafetySignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetySignalInclude<ExtArgs> | null
    /**
     * Filter which SafetySignal to delete.
     */
    where: SafetySignalWhereUniqueInput
  }

  /**
   * SafetySignal deleteMany
   */
  export type SafetySignalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SafetySignals to delete
     */
    where?: SafetySignalWhereInput
  }

  /**
   * SafetySignal without action
   */
  export type SafetySignalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetySignal
     */
    select?: SafetySignalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SafetySignalInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    status: string | null
    verifiedAt: Date | null
    createdAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    status: string | null
    verifiedAt: Date | null
    createdAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    status: number
    verificationData: number
    verifiedAt: number
    createdAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    verifiedAt?: true
    createdAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    verifiedAt?: true
    createdAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    verificationData?: true
    verifiedAt?: true
    createdAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    status: string
    verificationData: JsonValue | null
    verifiedAt: Date | null
    createdAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    verificationData?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    verificationData?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    verificationData?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
  }

  export type VerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      status: string
      verificationData: Prisma.JsonValue | null
      verifiedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */ 
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly userId: FieldRef<"Verification", 'String'>
    readonly type: FieldRef<"Verification", 'String'>
    readonly status: FieldRef<"Verification", 'String'>
    readonly verificationData: FieldRef<"Verification", 'Json'>
    readonly verifiedAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
  }


  /**
   * Model Block
   */

  export type AggregateBlock = {
    _count: BlockCountAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  export type BlockMinAggregateOutputType = {
    id: string | null
    blockerId: string | null
    blockedUserId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type BlockMaxAggregateOutputType = {
    id: string | null
    blockerId: string | null
    blockedUserId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type BlockCountAggregateOutputType = {
    id: number
    blockerId: number
    blockedUserId: number
    reason: number
    createdAt: number
    _all: number
  }


  export type BlockMinAggregateInputType = {
    id?: true
    blockerId?: true
    blockedUserId?: true
    reason?: true
    createdAt?: true
  }

  export type BlockMaxAggregateInputType = {
    id?: true
    blockerId?: true
    blockedUserId?: true
    reason?: true
    createdAt?: true
  }

  export type BlockCountAggregateInputType = {
    id?: true
    blockerId?: true
    blockedUserId?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type BlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Block to aggregate.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blocks
    **/
    _count?: true | BlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockMaxAggregateInputType
  }

  export type GetBlockAggregateType<T extends BlockAggregateArgs> = {
        [P in keyof T & keyof AggregateBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlock[P]>
      : GetScalarType<T[P], AggregateBlock[P]>
  }




  export type BlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithAggregationInput | BlockOrderByWithAggregationInput[]
    by: BlockScalarFieldEnum[] | BlockScalarFieldEnum
    having?: BlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockCountAggregateInputType | true
    _min?: BlockMinAggregateInputType
    _max?: BlockMaxAggregateInputType
  }

  export type BlockGroupByOutputType = {
    id: string
    blockerId: string
    blockedUserId: string
    reason: string | null
    createdAt: Date
    _count: BlockCountAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  type GetBlockGroupByPayload<T extends BlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockGroupByOutputType[P]>
            : GetScalarType<T[P], BlockGroupByOutputType[P]>
        }
      >
    >


  export type BlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockerId?: boolean
    blockedUserId?: boolean
    reason?: boolean
    createdAt?: boolean
    blocker?: boolean | UserDefaultArgs<ExtArgs>
    blockedUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockerId?: boolean
    blockedUserId?: boolean
    reason?: boolean
    createdAt?: boolean
    blocker?: boolean | UserDefaultArgs<ExtArgs>
    blockedUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectScalar = {
    id?: boolean
    blockerId?: boolean
    blockedUserId?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type BlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocker?: boolean | UserDefaultArgs<ExtArgs>
    blockedUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocker?: boolean | UserDefaultArgs<ExtArgs>
    blockedUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Block"
    objects: {
      blocker: Prisma.$UserPayload<ExtArgs>
      blockedUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      blockerId: string
      blockedUserId: string
      reason: string | null
      createdAt: Date
    }, ExtArgs["result"]["block"]>
    composites: {}
  }

  type BlockGetPayload<S extends boolean | null | undefined | BlockDefaultArgs> = $Result.GetResult<Prisma.$BlockPayload, S>

  type BlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlockFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlockCountAggregateInputType | true
    }

  export interface BlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Block'], meta: { name: 'Block' } }
    /**
     * Find zero or one Block that matches the filter.
     * @param {BlockFindUniqueArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockFindUniqueArgs>(args: SelectSubset<T, BlockFindUniqueArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Block that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlockFindUniqueOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Block that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockFindFirstArgs>(args?: SelectSubset<T, BlockFindFirstArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Block that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.block.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.block.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockWithIdOnly = await prisma.block.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockFindManyArgs>(args?: SelectSubset<T, BlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Block.
     * @param {BlockCreateArgs} args - Arguments to create a Block.
     * @example
     * // Create one Block
     * const Block = await prisma.block.create({
     *   data: {
     *     // ... data to create a Block
     *   }
     * })
     * 
     */
    create<T extends BlockCreateArgs>(args: SelectSubset<T, BlockCreateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Blocks.
     * @param {BlockCreateManyArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockCreateManyArgs>(args?: SelectSubset<T, BlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blocks and returns the data saved in the database.
     * @param {BlockCreateManyAndReturnArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blocks and only return the `id`
     * const blockWithIdOnly = await prisma.block.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Block.
     * @param {BlockDeleteArgs} args - Arguments to delete one Block.
     * @example
     * // Delete one Block
     * const Block = await prisma.block.delete({
     *   where: {
     *     // ... filter to delete one Block
     *   }
     * })
     * 
     */
    delete<T extends BlockDeleteArgs>(args: SelectSubset<T, BlockDeleteArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Block.
     * @param {BlockUpdateArgs} args - Arguments to update one Block.
     * @example
     * // Update one Block
     * const block = await prisma.block.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockUpdateArgs>(args: SelectSubset<T, BlockUpdateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Blocks.
     * @param {BlockDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.block.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockDeleteManyArgs>(args?: SelectSubset<T, BlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockUpdateManyArgs>(args: SelectSubset<T, BlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Block.
     * @param {BlockUpsertArgs} args - Arguments to update or create a Block.
     * @example
     * // Update or create a Block
     * const block = await prisma.block.upsert({
     *   create: {
     *     // ... data to create a Block
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Block we want to update
     *   }
     * })
     */
    upsert<T extends BlockUpsertArgs>(args: SelectSubset<T, BlockUpsertArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.block.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends BlockCountArgs>(
      args?: Subset<T, BlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockAggregateArgs>(args: Subset<T, BlockAggregateArgs>): Prisma.PrismaPromise<GetBlockAggregateType<T>>

    /**
     * Group by Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockGroupByArgs['orderBy'] }
        : { orderBy?: BlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Block model
   */
  readonly fields: BlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Block.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blocker<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    blockedUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Block model
   */ 
  interface BlockFieldRefs {
    readonly id: FieldRef<"Block", 'String'>
    readonly blockerId: FieldRef<"Block", 'String'>
    readonly blockedUserId: FieldRef<"Block", 'String'>
    readonly reason: FieldRef<"Block", 'String'>
    readonly createdAt: FieldRef<"Block", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Block findUnique
   */
  export type BlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findUniqueOrThrow
   */
  export type BlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findFirst
   */
  export type BlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findFirstOrThrow
   */
  export type BlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findMany
   */
  export type BlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Blocks to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block create
   */
  export type BlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to create a Block.
     */
    data: XOR<BlockCreateInput, BlockUncheckedCreateInput>
  }

  /**
   * Block createMany
   */
  export type BlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Block createManyAndReturn
   */
  export type BlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Block update
   */
  export type BlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to update a Block.
     */
    data: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
    /**
     * Choose, which Block to update.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block updateMany
   */
  export type BlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlockWhereInput
  }

  /**
   * Block upsert
   */
  export type BlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The filter to search for the Block to update in case it exists.
     */
    where: BlockWhereUniqueInput
    /**
     * In case the Block found by the `where` argument doesn't exist, create a new Block with this data.
     */
    create: XOR<BlockCreateInput, BlockUncheckedCreateInput>
    /**
     * In case the Block was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
  }

  /**
   * Block delete
   */
  export type BlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter which Block to delete.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block deleteMany
   */
  export type BlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blocks to delete
     */
    where?: BlockWhereInput
  }

  /**
   * Block without action
   */
  export type BlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
  }


  /**
   * Model IntentHistory
   */

  export type AggregateIntentHistory = {
    _count: IntentHistoryCountAggregateOutputType | null
    _avg: IntentHistoryAvgAggregateOutputType | null
    _sum: IntentHistorySumAggregateOutputType | null
    _min: IntentHistoryMinAggregateOutputType | null
    _max: IntentHistoryMaxAggregateOutputType | null
  }

  export type IntentHistoryAvgAggregateOutputType = {
    confidence: number | null
  }

  export type IntentHistorySumAggregateOutputType = {
    confidence: number | null
  }

  export type IntentHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    statedIntent: $Enums.RelationshipIntent | null
    behaviorIntent: $Enums.RelationshipIntent | null
    confidence: number | null
    driftDetected: boolean | null
    createdAt: Date | null
  }

  export type IntentHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    statedIntent: $Enums.RelationshipIntent | null
    behaviorIntent: $Enums.RelationshipIntent | null
    confidence: number | null
    driftDetected: boolean | null
    createdAt: Date | null
  }

  export type IntentHistoryCountAggregateOutputType = {
    id: number
    userId: number
    statedIntent: number
    behaviorIntent: number
    confidence: number
    driftDetected: number
    createdAt: number
    _all: number
  }


  export type IntentHistoryAvgAggregateInputType = {
    confidence?: true
  }

  export type IntentHistorySumAggregateInputType = {
    confidence?: true
  }

  export type IntentHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    statedIntent?: true
    behaviorIntent?: true
    confidence?: true
    driftDetected?: true
    createdAt?: true
  }

  export type IntentHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    statedIntent?: true
    behaviorIntent?: true
    confidence?: true
    driftDetected?: true
    createdAt?: true
  }

  export type IntentHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    statedIntent?: true
    behaviorIntent?: true
    confidence?: true
    driftDetected?: true
    createdAt?: true
    _all?: true
  }

  export type IntentHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntentHistory to aggregate.
     */
    where?: IntentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentHistories to fetch.
     */
    orderBy?: IntentHistoryOrderByWithRelationInput | IntentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntentHistories
    **/
    _count?: true | IntentHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntentHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntentHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntentHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntentHistoryMaxAggregateInputType
  }

  export type GetIntentHistoryAggregateType<T extends IntentHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateIntentHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntentHistory[P]>
      : GetScalarType<T[P], AggregateIntentHistory[P]>
  }




  export type IntentHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntentHistoryWhereInput
    orderBy?: IntentHistoryOrderByWithAggregationInput | IntentHistoryOrderByWithAggregationInput[]
    by: IntentHistoryScalarFieldEnum[] | IntentHistoryScalarFieldEnum
    having?: IntentHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntentHistoryCountAggregateInputType | true
    _avg?: IntentHistoryAvgAggregateInputType
    _sum?: IntentHistorySumAggregateInputType
    _min?: IntentHistoryMinAggregateInputType
    _max?: IntentHistoryMaxAggregateInputType
  }

  export type IntentHistoryGroupByOutputType = {
    id: string
    userId: string
    statedIntent: $Enums.RelationshipIntent
    behaviorIntent: $Enums.RelationshipIntent | null
    confidence: number
    driftDetected: boolean
    createdAt: Date
    _count: IntentHistoryCountAggregateOutputType | null
    _avg: IntentHistoryAvgAggregateOutputType | null
    _sum: IntentHistorySumAggregateOutputType | null
    _min: IntentHistoryMinAggregateOutputType | null
    _max: IntentHistoryMaxAggregateOutputType | null
  }

  type GetIntentHistoryGroupByPayload<T extends IntentHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntentHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntentHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntentHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], IntentHistoryGroupByOutputType[P]>
        }
      >
    >


  export type IntentHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    statedIntent?: boolean
    behaviorIntent?: boolean
    confidence?: boolean
    driftDetected?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intentHistory"]>

  export type IntentHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    statedIntent?: boolean
    behaviorIntent?: boolean
    confidence?: boolean
    driftDetected?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intentHistory"]>

  export type IntentHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    statedIntent?: boolean
    behaviorIntent?: boolean
    confidence?: boolean
    driftDetected?: boolean
    createdAt?: boolean
  }

  export type IntentHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IntentHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IntentHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntentHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      statedIntent: $Enums.RelationshipIntent
      behaviorIntent: $Enums.RelationshipIntent | null
      confidence: number
      driftDetected: boolean
      createdAt: Date
    }, ExtArgs["result"]["intentHistory"]>
    composites: {}
  }

  type IntentHistoryGetPayload<S extends boolean | null | undefined | IntentHistoryDefaultArgs> = $Result.GetResult<Prisma.$IntentHistoryPayload, S>

  type IntentHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IntentHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IntentHistoryCountAggregateInputType | true
    }

  export interface IntentHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntentHistory'], meta: { name: 'IntentHistory' } }
    /**
     * Find zero or one IntentHistory that matches the filter.
     * @param {IntentHistoryFindUniqueArgs} args - Arguments to find a IntentHistory
     * @example
     * // Get one IntentHistory
     * const intentHistory = await prisma.intentHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntentHistoryFindUniqueArgs>(args: SelectSubset<T, IntentHistoryFindUniqueArgs<ExtArgs>>): Prisma__IntentHistoryClient<$Result.GetResult<Prisma.$IntentHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IntentHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IntentHistoryFindUniqueOrThrowArgs} args - Arguments to find a IntentHistory
     * @example
     * // Get one IntentHistory
     * const intentHistory = await prisma.intentHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntentHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, IntentHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntentHistoryClient<$Result.GetResult<Prisma.$IntentHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IntentHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentHistoryFindFirstArgs} args - Arguments to find a IntentHistory
     * @example
     * // Get one IntentHistory
     * const intentHistory = await prisma.intentHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntentHistoryFindFirstArgs>(args?: SelectSubset<T, IntentHistoryFindFirstArgs<ExtArgs>>): Prisma__IntentHistoryClient<$Result.GetResult<Prisma.$IntentHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IntentHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentHistoryFindFirstOrThrowArgs} args - Arguments to find a IntentHistory
     * @example
     * // Get one IntentHistory
     * const intentHistory = await prisma.intentHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntentHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, IntentHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntentHistoryClient<$Result.GetResult<Prisma.$IntentHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IntentHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntentHistories
     * const intentHistories = await prisma.intentHistory.findMany()
     * 
     * // Get first 10 IntentHistories
     * const intentHistories = await prisma.intentHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const intentHistoryWithIdOnly = await prisma.intentHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntentHistoryFindManyArgs>(args?: SelectSubset<T, IntentHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntentHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IntentHistory.
     * @param {IntentHistoryCreateArgs} args - Arguments to create a IntentHistory.
     * @example
     * // Create one IntentHistory
     * const IntentHistory = await prisma.intentHistory.create({
     *   data: {
     *     // ... data to create a IntentHistory
     *   }
     * })
     * 
     */
    create<T extends IntentHistoryCreateArgs>(args: SelectSubset<T, IntentHistoryCreateArgs<ExtArgs>>): Prisma__IntentHistoryClient<$Result.GetResult<Prisma.$IntentHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IntentHistories.
     * @param {IntentHistoryCreateManyArgs} args - Arguments to create many IntentHistories.
     * @example
     * // Create many IntentHistories
     * const intentHistory = await prisma.intentHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntentHistoryCreateManyArgs>(args?: SelectSubset<T, IntentHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IntentHistories and returns the data saved in the database.
     * @param {IntentHistoryCreateManyAndReturnArgs} args - Arguments to create many IntentHistories.
     * @example
     * // Create many IntentHistories
     * const intentHistory = await prisma.intentHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IntentHistories and only return the `id`
     * const intentHistoryWithIdOnly = await prisma.intentHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntentHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, IntentHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntentHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IntentHistory.
     * @param {IntentHistoryDeleteArgs} args - Arguments to delete one IntentHistory.
     * @example
     * // Delete one IntentHistory
     * const IntentHistory = await prisma.intentHistory.delete({
     *   where: {
     *     // ... filter to delete one IntentHistory
     *   }
     * })
     * 
     */
    delete<T extends IntentHistoryDeleteArgs>(args: SelectSubset<T, IntentHistoryDeleteArgs<ExtArgs>>): Prisma__IntentHistoryClient<$Result.GetResult<Prisma.$IntentHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IntentHistory.
     * @param {IntentHistoryUpdateArgs} args - Arguments to update one IntentHistory.
     * @example
     * // Update one IntentHistory
     * const intentHistory = await prisma.intentHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntentHistoryUpdateArgs>(args: SelectSubset<T, IntentHistoryUpdateArgs<ExtArgs>>): Prisma__IntentHistoryClient<$Result.GetResult<Prisma.$IntentHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IntentHistories.
     * @param {IntentHistoryDeleteManyArgs} args - Arguments to filter IntentHistories to delete.
     * @example
     * // Delete a few IntentHistories
     * const { count } = await prisma.intentHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntentHistoryDeleteManyArgs>(args?: SelectSubset<T, IntentHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntentHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntentHistories
     * const intentHistory = await prisma.intentHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntentHistoryUpdateManyArgs>(args: SelectSubset<T, IntentHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IntentHistory.
     * @param {IntentHistoryUpsertArgs} args - Arguments to update or create a IntentHistory.
     * @example
     * // Update or create a IntentHistory
     * const intentHistory = await prisma.intentHistory.upsert({
     *   create: {
     *     // ... data to create a IntentHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntentHistory we want to update
     *   }
     * })
     */
    upsert<T extends IntentHistoryUpsertArgs>(args: SelectSubset<T, IntentHistoryUpsertArgs<ExtArgs>>): Prisma__IntentHistoryClient<$Result.GetResult<Prisma.$IntentHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IntentHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentHistoryCountArgs} args - Arguments to filter IntentHistories to count.
     * @example
     * // Count the number of IntentHistories
     * const count = await prisma.intentHistory.count({
     *   where: {
     *     // ... the filter for the IntentHistories we want to count
     *   }
     * })
    **/
    count<T extends IntentHistoryCountArgs>(
      args?: Subset<T, IntentHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntentHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntentHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntentHistoryAggregateArgs>(args: Subset<T, IntentHistoryAggregateArgs>): Prisma.PrismaPromise<GetIntentHistoryAggregateType<T>>

    /**
     * Group by IntentHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntentHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntentHistoryGroupByArgs['orderBy'] }
        : { orderBy?: IntentHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntentHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntentHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntentHistory model
   */
  readonly fields: IntentHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntentHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntentHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntentHistory model
   */ 
  interface IntentHistoryFieldRefs {
    readonly id: FieldRef<"IntentHistory", 'String'>
    readonly userId: FieldRef<"IntentHistory", 'String'>
    readonly statedIntent: FieldRef<"IntentHistory", 'RelationshipIntent'>
    readonly behaviorIntent: FieldRef<"IntentHistory", 'RelationshipIntent'>
    readonly confidence: FieldRef<"IntentHistory", 'Float'>
    readonly driftDetected: FieldRef<"IntentHistory", 'Boolean'>
    readonly createdAt: FieldRef<"IntentHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IntentHistory findUnique
   */
  export type IntentHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentHistory
     */
    select?: IntentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which IntentHistory to fetch.
     */
    where: IntentHistoryWhereUniqueInput
  }

  /**
   * IntentHistory findUniqueOrThrow
   */
  export type IntentHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentHistory
     */
    select?: IntentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which IntentHistory to fetch.
     */
    where: IntentHistoryWhereUniqueInput
  }

  /**
   * IntentHistory findFirst
   */
  export type IntentHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentHistory
     */
    select?: IntentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which IntentHistory to fetch.
     */
    where?: IntentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentHistories to fetch.
     */
    orderBy?: IntentHistoryOrderByWithRelationInput | IntentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntentHistories.
     */
    cursor?: IntentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntentHistories.
     */
    distinct?: IntentHistoryScalarFieldEnum | IntentHistoryScalarFieldEnum[]
  }

  /**
   * IntentHistory findFirstOrThrow
   */
  export type IntentHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentHistory
     */
    select?: IntentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which IntentHistory to fetch.
     */
    where?: IntentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentHistories to fetch.
     */
    orderBy?: IntentHistoryOrderByWithRelationInput | IntentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntentHistories.
     */
    cursor?: IntentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntentHistories.
     */
    distinct?: IntentHistoryScalarFieldEnum | IntentHistoryScalarFieldEnum[]
  }

  /**
   * IntentHistory findMany
   */
  export type IntentHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentHistory
     */
    select?: IntentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which IntentHistories to fetch.
     */
    where?: IntentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentHistories to fetch.
     */
    orderBy?: IntentHistoryOrderByWithRelationInput | IntentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntentHistories.
     */
    cursor?: IntentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentHistories.
     */
    skip?: number
    distinct?: IntentHistoryScalarFieldEnum | IntentHistoryScalarFieldEnum[]
  }

  /**
   * IntentHistory create
   */
  export type IntentHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentHistory
     */
    select?: IntentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a IntentHistory.
     */
    data: XOR<IntentHistoryCreateInput, IntentHistoryUncheckedCreateInput>
  }

  /**
   * IntentHistory createMany
   */
  export type IntentHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntentHistories.
     */
    data: IntentHistoryCreateManyInput | IntentHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntentHistory createManyAndReturn
   */
  export type IntentHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentHistory
     */
    select?: IntentHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IntentHistories.
     */
    data: IntentHistoryCreateManyInput | IntentHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntentHistory update
   */
  export type IntentHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentHistory
     */
    select?: IntentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a IntentHistory.
     */
    data: XOR<IntentHistoryUpdateInput, IntentHistoryUncheckedUpdateInput>
    /**
     * Choose, which IntentHistory to update.
     */
    where: IntentHistoryWhereUniqueInput
  }

  /**
   * IntentHistory updateMany
   */
  export type IntentHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntentHistories.
     */
    data: XOR<IntentHistoryUpdateManyMutationInput, IntentHistoryUncheckedUpdateManyInput>
    /**
     * Filter which IntentHistories to update
     */
    where?: IntentHistoryWhereInput
  }

  /**
   * IntentHistory upsert
   */
  export type IntentHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentHistory
     */
    select?: IntentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the IntentHistory to update in case it exists.
     */
    where: IntentHistoryWhereUniqueInput
    /**
     * In case the IntentHistory found by the `where` argument doesn't exist, create a new IntentHistory with this data.
     */
    create: XOR<IntentHistoryCreateInput, IntentHistoryUncheckedCreateInput>
    /**
     * In case the IntentHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntentHistoryUpdateInput, IntentHistoryUncheckedUpdateInput>
  }

  /**
   * IntentHistory delete
   */
  export type IntentHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentHistory
     */
    select?: IntentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentHistoryInclude<ExtArgs> | null
    /**
     * Filter which IntentHistory to delete.
     */
    where: IntentHistoryWhereUniqueInput
  }

  /**
   * IntentHistory deleteMany
   */
  export type IntentHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntentHistories to delete
     */
    where?: IntentHistoryWhereInput
  }

  /**
   * IntentHistory without action
   */
  export type IntentHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentHistory
     */
    select?: IntentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentHistoryInclude<ExtArgs> | null
  }


  /**
   * Model ScheduledDate
   */

  export type AggregateScheduledDate = {
    _count: ScheduledDateCountAggregateOutputType | null
    _avg: ScheduledDateAvgAggregateOutputType | null
    _sum: ScheduledDateSumAggregateOutputType | null
    _min: ScheduledDateMinAggregateOutputType | null
    _max: ScheduledDateMaxAggregateOutputType | null
  }

  export type ScheduledDateAvgAggregateOutputType = {
    safetyScore: number | null
  }

  export type ScheduledDateSumAggregateOutputType = {
    safetyScore: number | null
  }

  export type ScheduledDateMinAggregateOutputType = {
    id: string | null
    matchId: string | null
    schedulerId: string | null
    partnerId: string | null
    dateTime: Date | null
    location: string | null
    isPublicPlace: boolean | null
    safetyCheckIn: boolean | null
    checkInTime: Date | null
    locationSharing: boolean | null
    safetyScore: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledDateMaxAggregateOutputType = {
    id: string | null
    matchId: string | null
    schedulerId: string | null
    partnerId: string | null
    dateTime: Date | null
    location: string | null
    isPublicPlace: boolean | null
    safetyCheckIn: boolean | null
    checkInTime: Date | null
    locationSharing: boolean | null
    safetyScore: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledDateCountAggregateOutputType = {
    id: number
    matchId: number
    schedulerId: number
    partnerId: number
    dateTime: number
    location: number
    isPublicPlace: number
    safetyCheckIn: number
    checkInTime: number
    locationSharing: number
    safetyScore: number
    concerns: number
    suggestions: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduledDateAvgAggregateInputType = {
    safetyScore?: true
  }

  export type ScheduledDateSumAggregateInputType = {
    safetyScore?: true
  }

  export type ScheduledDateMinAggregateInputType = {
    id?: true
    matchId?: true
    schedulerId?: true
    partnerId?: true
    dateTime?: true
    location?: true
    isPublicPlace?: true
    safetyCheckIn?: true
    checkInTime?: true
    locationSharing?: true
    safetyScore?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledDateMaxAggregateInputType = {
    id?: true
    matchId?: true
    schedulerId?: true
    partnerId?: true
    dateTime?: true
    location?: true
    isPublicPlace?: true
    safetyCheckIn?: true
    checkInTime?: true
    locationSharing?: true
    safetyScore?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledDateCountAggregateInputType = {
    id?: true
    matchId?: true
    schedulerId?: true
    partnerId?: true
    dateTime?: true
    location?: true
    isPublicPlace?: true
    safetyCheckIn?: true
    checkInTime?: true
    locationSharing?: true
    safetyScore?: true
    concerns?: true
    suggestions?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduledDateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledDate to aggregate.
     */
    where?: ScheduledDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledDates to fetch.
     */
    orderBy?: ScheduledDateOrderByWithRelationInput | ScheduledDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledDates
    **/
    _count?: true | ScheduledDateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduledDateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduledDateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledDateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledDateMaxAggregateInputType
  }

  export type GetScheduledDateAggregateType<T extends ScheduledDateAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledDate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledDate[P]>
      : GetScalarType<T[P], AggregateScheduledDate[P]>
  }




  export type ScheduledDateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledDateWhereInput
    orderBy?: ScheduledDateOrderByWithAggregationInput | ScheduledDateOrderByWithAggregationInput[]
    by: ScheduledDateScalarFieldEnum[] | ScheduledDateScalarFieldEnum
    having?: ScheduledDateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledDateCountAggregateInputType | true
    _avg?: ScheduledDateAvgAggregateInputType
    _sum?: ScheduledDateSumAggregateInputType
    _min?: ScheduledDateMinAggregateInputType
    _max?: ScheduledDateMaxAggregateInputType
  }

  export type ScheduledDateGroupByOutputType = {
    id: string
    matchId: string
    schedulerId: string
    partnerId: string
    dateTime: Date
    location: string | null
    isPublicPlace: boolean
    safetyCheckIn: boolean
    checkInTime: Date | null
    locationSharing: boolean
    safetyScore: number | null
    concerns: string[]
    suggestions: string[]
    status: string
    createdAt: Date
    updatedAt: Date
    _count: ScheduledDateCountAggregateOutputType | null
    _avg: ScheduledDateAvgAggregateOutputType | null
    _sum: ScheduledDateSumAggregateOutputType | null
    _min: ScheduledDateMinAggregateOutputType | null
    _max: ScheduledDateMaxAggregateOutputType | null
  }

  type GetScheduledDateGroupByPayload<T extends ScheduledDateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledDateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledDateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledDateGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledDateGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledDateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    schedulerId?: boolean
    partnerId?: boolean
    dateTime?: boolean
    location?: boolean
    isPublicPlace?: boolean
    safetyCheckIn?: boolean
    checkInTime?: boolean
    locationSharing?: boolean
    safetyScore?: boolean
    concerns?: boolean
    suggestions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    scheduler?: boolean | UserDefaultArgs<ExtArgs>
    partner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledDate"]>

  export type ScheduledDateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    schedulerId?: boolean
    partnerId?: boolean
    dateTime?: boolean
    location?: boolean
    isPublicPlace?: boolean
    safetyCheckIn?: boolean
    checkInTime?: boolean
    locationSharing?: boolean
    safetyScore?: boolean
    concerns?: boolean
    suggestions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    scheduler?: boolean | UserDefaultArgs<ExtArgs>
    partner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledDate"]>

  export type ScheduledDateSelectScalar = {
    id?: boolean
    matchId?: boolean
    schedulerId?: boolean
    partnerId?: boolean
    dateTime?: boolean
    location?: boolean
    isPublicPlace?: boolean
    safetyCheckIn?: boolean
    checkInTime?: boolean
    locationSharing?: boolean
    safetyScore?: boolean
    concerns?: boolean
    suggestions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduledDateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    scheduler?: boolean | UserDefaultArgs<ExtArgs>
    partner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ScheduledDateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    scheduler?: boolean | UserDefaultArgs<ExtArgs>
    partner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ScheduledDatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledDate"
    objects: {
      match: Prisma.$MatchPayload<ExtArgs>
      scheduler: Prisma.$UserPayload<ExtArgs>
      partner: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      matchId: string
      schedulerId: string
      partnerId: string
      dateTime: Date
      location: string | null
      isPublicPlace: boolean
      safetyCheckIn: boolean
      checkInTime: Date | null
      locationSharing: boolean
      safetyScore: number | null
      concerns: string[]
      suggestions: string[]
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scheduledDate"]>
    composites: {}
  }

  type ScheduledDateGetPayload<S extends boolean | null | undefined | ScheduledDateDefaultArgs> = $Result.GetResult<Prisma.$ScheduledDatePayload, S>

  type ScheduledDateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScheduledDateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScheduledDateCountAggregateInputType | true
    }

  export interface ScheduledDateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledDate'], meta: { name: 'ScheduledDate' } }
    /**
     * Find zero or one ScheduledDate that matches the filter.
     * @param {ScheduledDateFindUniqueArgs} args - Arguments to find a ScheduledDate
     * @example
     * // Get one ScheduledDate
     * const scheduledDate = await prisma.scheduledDate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduledDateFindUniqueArgs>(args: SelectSubset<T, ScheduledDateFindUniqueArgs<ExtArgs>>): Prisma__ScheduledDateClient<$Result.GetResult<Prisma.$ScheduledDatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScheduledDate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScheduledDateFindUniqueOrThrowArgs} args - Arguments to find a ScheduledDate
     * @example
     * // Get one ScheduledDate
     * const scheduledDate = await prisma.scheduledDate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduledDateFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduledDateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduledDateClient<$Result.GetResult<Prisma.$ScheduledDatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScheduledDate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledDateFindFirstArgs} args - Arguments to find a ScheduledDate
     * @example
     * // Get one ScheduledDate
     * const scheduledDate = await prisma.scheduledDate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduledDateFindFirstArgs>(args?: SelectSubset<T, ScheduledDateFindFirstArgs<ExtArgs>>): Prisma__ScheduledDateClient<$Result.GetResult<Prisma.$ScheduledDatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScheduledDate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledDateFindFirstOrThrowArgs} args - Arguments to find a ScheduledDate
     * @example
     * // Get one ScheduledDate
     * const scheduledDate = await prisma.scheduledDate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduledDateFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduledDateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduledDateClient<$Result.GetResult<Prisma.$ScheduledDatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScheduledDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledDateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledDates
     * const scheduledDates = await prisma.scheduledDate.findMany()
     * 
     * // Get first 10 ScheduledDates
     * const scheduledDates = await prisma.scheduledDate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledDateWithIdOnly = await prisma.scheduledDate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduledDateFindManyArgs>(args?: SelectSubset<T, ScheduledDateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledDatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScheduledDate.
     * @param {ScheduledDateCreateArgs} args - Arguments to create a ScheduledDate.
     * @example
     * // Create one ScheduledDate
     * const ScheduledDate = await prisma.scheduledDate.create({
     *   data: {
     *     // ... data to create a ScheduledDate
     *   }
     * })
     * 
     */
    create<T extends ScheduledDateCreateArgs>(args: SelectSubset<T, ScheduledDateCreateArgs<ExtArgs>>): Prisma__ScheduledDateClient<$Result.GetResult<Prisma.$ScheduledDatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScheduledDates.
     * @param {ScheduledDateCreateManyArgs} args - Arguments to create many ScheduledDates.
     * @example
     * // Create many ScheduledDates
     * const scheduledDate = await prisma.scheduledDate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduledDateCreateManyArgs>(args?: SelectSubset<T, ScheduledDateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduledDates and returns the data saved in the database.
     * @param {ScheduledDateCreateManyAndReturnArgs} args - Arguments to create many ScheduledDates.
     * @example
     * // Create many ScheduledDates
     * const scheduledDate = await prisma.scheduledDate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduledDates and only return the `id`
     * const scheduledDateWithIdOnly = await prisma.scheduledDate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduledDateCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduledDateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledDatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScheduledDate.
     * @param {ScheduledDateDeleteArgs} args - Arguments to delete one ScheduledDate.
     * @example
     * // Delete one ScheduledDate
     * const ScheduledDate = await prisma.scheduledDate.delete({
     *   where: {
     *     // ... filter to delete one ScheduledDate
     *   }
     * })
     * 
     */
    delete<T extends ScheduledDateDeleteArgs>(args: SelectSubset<T, ScheduledDateDeleteArgs<ExtArgs>>): Prisma__ScheduledDateClient<$Result.GetResult<Prisma.$ScheduledDatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScheduledDate.
     * @param {ScheduledDateUpdateArgs} args - Arguments to update one ScheduledDate.
     * @example
     * // Update one ScheduledDate
     * const scheduledDate = await prisma.scheduledDate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduledDateUpdateArgs>(args: SelectSubset<T, ScheduledDateUpdateArgs<ExtArgs>>): Prisma__ScheduledDateClient<$Result.GetResult<Prisma.$ScheduledDatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScheduledDates.
     * @param {ScheduledDateDeleteManyArgs} args - Arguments to filter ScheduledDates to delete.
     * @example
     * // Delete a few ScheduledDates
     * const { count } = await prisma.scheduledDate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduledDateDeleteManyArgs>(args?: SelectSubset<T, ScheduledDateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledDateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledDates
     * const scheduledDate = await prisma.scheduledDate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduledDateUpdateManyArgs>(args: SelectSubset<T, ScheduledDateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScheduledDate.
     * @param {ScheduledDateUpsertArgs} args - Arguments to update or create a ScheduledDate.
     * @example
     * // Update or create a ScheduledDate
     * const scheduledDate = await prisma.scheduledDate.upsert({
     *   create: {
     *     // ... data to create a ScheduledDate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledDate we want to update
     *   }
     * })
     */
    upsert<T extends ScheduledDateUpsertArgs>(args: SelectSubset<T, ScheduledDateUpsertArgs<ExtArgs>>): Prisma__ScheduledDateClient<$Result.GetResult<Prisma.$ScheduledDatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScheduledDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledDateCountArgs} args - Arguments to filter ScheduledDates to count.
     * @example
     * // Count the number of ScheduledDates
     * const count = await prisma.scheduledDate.count({
     *   where: {
     *     // ... the filter for the ScheduledDates we want to count
     *   }
     * })
    **/
    count<T extends ScheduledDateCountArgs>(
      args?: Subset<T, ScheduledDateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledDateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledDateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledDateAggregateArgs>(args: Subset<T, ScheduledDateAggregateArgs>): Prisma.PrismaPromise<GetScheduledDateAggregateType<T>>

    /**
     * Group by ScheduledDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledDateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledDateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledDateGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledDateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledDateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledDateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledDate model
   */
  readonly fields: ScheduledDateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledDate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledDateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    match<T extends MatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatchDefaultArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    scheduler<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    partner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduledDate model
   */ 
  interface ScheduledDateFieldRefs {
    readonly id: FieldRef<"ScheduledDate", 'String'>
    readonly matchId: FieldRef<"ScheduledDate", 'String'>
    readonly schedulerId: FieldRef<"ScheduledDate", 'String'>
    readonly partnerId: FieldRef<"ScheduledDate", 'String'>
    readonly dateTime: FieldRef<"ScheduledDate", 'DateTime'>
    readonly location: FieldRef<"ScheduledDate", 'String'>
    readonly isPublicPlace: FieldRef<"ScheduledDate", 'Boolean'>
    readonly safetyCheckIn: FieldRef<"ScheduledDate", 'Boolean'>
    readonly checkInTime: FieldRef<"ScheduledDate", 'DateTime'>
    readonly locationSharing: FieldRef<"ScheduledDate", 'Boolean'>
    readonly safetyScore: FieldRef<"ScheduledDate", 'Int'>
    readonly concerns: FieldRef<"ScheduledDate", 'String[]'>
    readonly suggestions: FieldRef<"ScheduledDate", 'String[]'>
    readonly status: FieldRef<"ScheduledDate", 'String'>
    readonly createdAt: FieldRef<"ScheduledDate", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduledDate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledDate findUnique
   */
  export type ScheduledDateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledDate
     */
    select?: ScheduledDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledDateInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledDate to fetch.
     */
    where: ScheduledDateWhereUniqueInput
  }

  /**
   * ScheduledDate findUniqueOrThrow
   */
  export type ScheduledDateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledDate
     */
    select?: ScheduledDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledDateInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledDate to fetch.
     */
    where: ScheduledDateWhereUniqueInput
  }

  /**
   * ScheduledDate findFirst
   */
  export type ScheduledDateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledDate
     */
    select?: ScheduledDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledDateInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledDate to fetch.
     */
    where?: ScheduledDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledDates to fetch.
     */
    orderBy?: ScheduledDateOrderByWithRelationInput | ScheduledDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledDates.
     */
    cursor?: ScheduledDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledDates.
     */
    distinct?: ScheduledDateScalarFieldEnum | ScheduledDateScalarFieldEnum[]
  }

  /**
   * ScheduledDate findFirstOrThrow
   */
  export type ScheduledDateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledDate
     */
    select?: ScheduledDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledDateInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledDate to fetch.
     */
    where?: ScheduledDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledDates to fetch.
     */
    orderBy?: ScheduledDateOrderByWithRelationInput | ScheduledDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledDates.
     */
    cursor?: ScheduledDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledDates.
     */
    distinct?: ScheduledDateScalarFieldEnum | ScheduledDateScalarFieldEnum[]
  }

  /**
   * ScheduledDate findMany
   */
  export type ScheduledDateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledDate
     */
    select?: ScheduledDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledDateInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledDates to fetch.
     */
    where?: ScheduledDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledDates to fetch.
     */
    orderBy?: ScheduledDateOrderByWithRelationInput | ScheduledDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledDates.
     */
    cursor?: ScheduledDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledDates.
     */
    skip?: number
    distinct?: ScheduledDateScalarFieldEnum | ScheduledDateScalarFieldEnum[]
  }

  /**
   * ScheduledDate create
   */
  export type ScheduledDateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledDate
     */
    select?: ScheduledDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledDateInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduledDate.
     */
    data: XOR<ScheduledDateCreateInput, ScheduledDateUncheckedCreateInput>
  }

  /**
   * ScheduledDate createMany
   */
  export type ScheduledDateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledDates.
     */
    data: ScheduledDateCreateManyInput | ScheduledDateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledDate createManyAndReturn
   */
  export type ScheduledDateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledDate
     */
    select?: ScheduledDateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScheduledDates.
     */
    data: ScheduledDateCreateManyInput | ScheduledDateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledDateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduledDate update
   */
  export type ScheduledDateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledDate
     */
    select?: ScheduledDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledDateInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduledDate.
     */
    data: XOR<ScheduledDateUpdateInput, ScheduledDateUncheckedUpdateInput>
    /**
     * Choose, which ScheduledDate to update.
     */
    where: ScheduledDateWhereUniqueInput
  }

  /**
   * ScheduledDate updateMany
   */
  export type ScheduledDateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledDates.
     */
    data: XOR<ScheduledDateUpdateManyMutationInput, ScheduledDateUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledDates to update
     */
    where?: ScheduledDateWhereInput
  }

  /**
   * ScheduledDate upsert
   */
  export type ScheduledDateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledDate
     */
    select?: ScheduledDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledDateInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduledDate to update in case it exists.
     */
    where: ScheduledDateWhereUniqueInput
    /**
     * In case the ScheduledDate found by the `where` argument doesn't exist, create a new ScheduledDate with this data.
     */
    create: XOR<ScheduledDateCreateInput, ScheduledDateUncheckedCreateInput>
    /**
     * In case the ScheduledDate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledDateUpdateInput, ScheduledDateUncheckedUpdateInput>
  }

  /**
   * ScheduledDate delete
   */
  export type ScheduledDateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledDate
     */
    select?: ScheduledDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledDateInclude<ExtArgs> | null
    /**
     * Filter which ScheduledDate to delete.
     */
    where: ScheduledDateWhereUniqueInput
  }

  /**
   * ScheduledDate deleteMany
   */
  export type ScheduledDateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledDates to delete
     */
    where?: ScheduledDateWhereInput
  }

  /**
   * ScheduledDate without action
   */
  export type ScheduledDateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledDate
     */
    select?: ScheduledDateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledDateInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    status: 'status',
    onboardingCompleted: 'onboardingCompleted',
    emailVerified: 'emailVerified',
    phoneVerified: 'phoneVerified',
    lastActiveAt: 'lastActiveAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    displayName: 'displayName',
    birthDate: 'birthDate',
    gender: 'gender',
    genderPreferences: 'genderPreferences',
    city: 'city',
    state: 'state',
    country: 'country',
    latitude: 'latitude',
    longitude: 'longitude',
    bio: 'bio',
    height: 'height',
    relationshipIntent: 'relationshipIntent',
    values: 'values',
    lifestyle: 'lifestyle',
    dealbreakers: 'dealbreakers',
    profileStrengthScore: 'profileStrengthScore',
    completenessScore: 'completenessScore',
    specificityScore: 'specificityScore',
    consistencyScore: 'consistencyScore',
    stabilityScore: 'stabilityScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const PhotoScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    url: 'url',
    isMain: 'isMain',
    isVerified: 'isVerified',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type PhotoScalarFieldEnum = (typeof PhotoScalarFieldEnum)[keyof typeof PhotoScalarFieldEnum]


  export const ProfilePromptScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    question: 'question',
    answer: 'answer',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfilePromptScalarFieldEnum = (typeof ProfilePromptScalarFieldEnum)[keyof typeof ProfilePromptScalarFieldEnum]


  export const OnboardingQuestionScalarFieldEnum: {
    id: 'id',
    category: 'category',
    questionText: 'questionText',
    questionType: 'questionType',
    options: 'options',
    followUpLogic: 'followUpLogic',
    order: 'order',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type OnboardingQuestionScalarFieldEnum = (typeof OnboardingQuestionScalarFieldEnum)[keyof typeof OnboardingQuestionScalarFieldEnum]


  export const OnboardingAnswerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    questionId: 'questionId',
    answer: 'answer',
    followUpCount: 'followUpCount',
    confidence: 'confidence',
    consistency: 'consistency',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OnboardingAnswerScalarFieldEnum = (typeof OnboardingAnswerScalarFieldEnum)[keyof typeof OnboardingAnswerScalarFieldEnum]


  export const LikeScalarFieldEnum: {
    id: 'id',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    createdAt: 'createdAt'
  };

  export type LikeScalarFieldEnum = (typeof LikeScalarFieldEnum)[keyof typeof LikeScalarFieldEnum]


  export const MatchScalarFieldEnum: {
    id: 'id',
    userAId: 'userAId',
    userBId: 'userBId',
    overallScore: 'overallScore',
    valuesScore: 'valuesScore',
    lifestyleScore: 'lifestyleScore',
    intentScore: 'intentScore',
    communicationScore: 'communicationScore',
    logisticsScore: 'logisticsScore',
    topReasons: 'topReasons',
    frictionPoint: 'frictionPoint',
    confidenceLevel: 'confidenceLevel',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatchScalarFieldEnum = (typeof MatchScalarFieldEnum)[keyof typeof MatchScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    matchId: 'matchId',
    senderId: 'senderId',
    receiverId: 'receiverId',
    content: 'content',
    status: 'status',
    safetyScore: 'safetyScore',
    safetyFlags: 'safetyFlags',
    createdAt: 'createdAt',
    readAt: 'readAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const TrustScoreScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    overallScore: 'overallScore',
    replyPatternScore: 'replyPatternScore',
    commitmentScore: 'commitmentScore',
    respectScore: 'respectScore',
    toneConsistencyScore: 'toneConsistencyScore',
    lastCalculatedAt: 'lastCalculatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrustScoreScalarFieldEnum = (typeof TrustScoreScalarFieldEnum)[keyof typeof TrustScoreScalarFieldEnum]


  export const BehaviorLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    behaviorType: 'behaviorType',
    metadata: 'metadata',
    score: 'score',
    createdAt: 'createdAt'
  };

  export type BehaviorLogScalarFieldEnum = (typeof BehaviorLogScalarFieldEnum)[keyof typeof BehaviorLogScalarFieldEnum]


  export const RiskAssessmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    riskIndex: 'riskIndex',
    riskLevel: 'riskLevel',
    reportScore: 'reportScore',
    messageRiskScore: 'messageRiskScore',
    patternRiskScore: 'patternRiskScore',
    isRestricted: 'isRestricted',
    restrictions: 'restrictions',
    lastAssessedAt: 'lastAssessedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RiskAssessmentScalarFieldEnum = (typeof RiskAssessmentScalarFieldEnum)[keyof typeof RiskAssessmentScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    reporterId: 'reporterId',
    reportedUserId: 'reportedUserId',
    type: 'type',
    description: 'description',
    evidence: 'evidence',
    status: 'status',
    reviewNotes: 'reviewNotes',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const SafetySignalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    signalType: 'signalType',
    verifiedAt: 'verifiedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SafetySignalScalarFieldEnum = (typeof SafetySignalScalarFieldEnum)[keyof typeof SafetySignalScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    status: 'status',
    verificationData: 'verificationData',
    verifiedAt: 'verifiedAt',
    createdAt: 'createdAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const BlockScalarFieldEnum: {
    id: 'id',
    blockerId: 'blockerId',
    blockedUserId: 'blockedUserId',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type BlockScalarFieldEnum = (typeof BlockScalarFieldEnum)[keyof typeof BlockScalarFieldEnum]


  export const IntentHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    statedIntent: 'statedIntent',
    behaviorIntent: 'behaviorIntent',
    confidence: 'confidence',
    driftDetected: 'driftDetected',
    createdAt: 'createdAt'
  };

  export type IntentHistoryScalarFieldEnum = (typeof IntentHistoryScalarFieldEnum)[keyof typeof IntentHistoryScalarFieldEnum]


  export const ScheduledDateScalarFieldEnum: {
    id: 'id',
    matchId: 'matchId',
    schedulerId: 'schedulerId',
    partnerId: 'partnerId',
    dateTime: 'dateTime',
    location: 'location',
    isPublicPlace: 'isPublicPlace',
    safetyCheckIn: 'safetyCheckIn',
    checkInTime: 'checkInTime',
    locationSharing: 'locationSharing',
    safetyScore: 'safetyScore',
    concerns: 'concerns',
    suggestions: 'suggestions',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduledDateScalarFieldEnum = (typeof ScheduledDateScalarFieldEnum)[keyof typeof ScheduledDateScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'RelationshipIntent'
   */
  export type EnumRelationshipIntentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationshipIntent'>
    


  /**
   * Reference to a field of type 'RelationshipIntent[]'
   */
  export type ListEnumRelationshipIntentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationshipIntent[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QuestionCategory'
   */
  export type EnumQuestionCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionCategory'>
    


  /**
   * Reference to a field of type 'QuestionCategory[]'
   */
  export type ListEnumQuestionCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionCategory[]'>
    


  /**
   * Reference to a field of type 'QuestionType'
   */
  export type EnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType'>
    


  /**
   * Reference to a field of type 'QuestionType[]'
   */
  export type ListEnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType[]'>
    


  /**
   * Reference to a field of type 'MessageStatus'
   */
  export type EnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus'>
    


  /**
   * Reference to a field of type 'MessageStatus[]'
   */
  export type ListEnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus[]'>
    


  /**
   * Reference to a field of type 'BehaviorType'
   */
  export type EnumBehaviorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BehaviorType'>
    


  /**
   * Reference to a field of type 'BehaviorType[]'
   */
  export type ListEnumBehaviorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BehaviorType[]'>
    


  /**
   * Reference to a field of type 'RiskLevel'
   */
  export type EnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskLevel'>
    


  /**
   * Reference to a field of type 'RiskLevel[]'
   */
  export type ListEnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskLevel[]'>
    


  /**
   * Reference to a field of type 'ReportType'
   */
  export type EnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType'>
    


  /**
   * Reference to a field of type 'ReportType[]'
   */
  export type ListEnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType[]'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus[]'>
    


  /**
   * Reference to a field of type 'SafetySignalType'
   */
  export type EnumSafetySignalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SafetySignalType'>
    


  /**
   * Reference to a field of type 'SafetySignalType[]'
   */
  export type ListEnumSafetySignalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SafetySignalType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    onboardingCompleted?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    phoneVerified?: BoolFilter<"User"> | boolean
    lastActiveAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    onboardingAnswers?: OnboardingAnswerListRelationFilter
    likesGiven?: LikeListRelationFilter
    likesReceived?: LikeListRelationFilter
    matchesAsUserA?: MatchListRelationFilter
    matchesAsUserB?: MatchListRelationFilter
    messagesSent?: MessageListRelationFilter
    messagesReceived?: MessageListRelationFilter
    trustScore?: XOR<TrustScoreNullableRelationFilter, TrustScoreWhereInput> | null
    behaviorLogs?: BehaviorLogListRelationFilter
    riskAssessment?: XOR<RiskAssessmentNullableRelationFilter, RiskAssessmentWhereInput> | null
    reportsFiled?: ReportListRelationFilter
    reportsReceived?: ReportListRelationFilter
    safetySignals?: SafetySignalListRelationFilter
    verifications?: VerificationListRelationFilter
    intentHistory?: IntentHistoryListRelationFilter
    blocksCreated?: BlockListRelationFilter
    blocksReceived?: BlockListRelationFilter
    scheduledDates?: ScheduledDateListRelationFilter
    datesAsPartner?: ScheduledDateListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    onboardingCompleted?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    onboardingAnswers?: OnboardingAnswerOrderByRelationAggregateInput
    likesGiven?: LikeOrderByRelationAggregateInput
    likesReceived?: LikeOrderByRelationAggregateInput
    matchesAsUserA?: MatchOrderByRelationAggregateInput
    matchesAsUserB?: MatchOrderByRelationAggregateInput
    messagesSent?: MessageOrderByRelationAggregateInput
    messagesReceived?: MessageOrderByRelationAggregateInput
    trustScore?: TrustScoreOrderByWithRelationInput
    behaviorLogs?: BehaviorLogOrderByRelationAggregateInput
    riskAssessment?: RiskAssessmentOrderByWithRelationInput
    reportsFiled?: ReportOrderByRelationAggregateInput
    reportsReceived?: ReportOrderByRelationAggregateInput
    safetySignals?: SafetySignalOrderByRelationAggregateInput
    verifications?: VerificationOrderByRelationAggregateInput
    intentHistory?: IntentHistoryOrderByRelationAggregateInput
    blocksCreated?: BlockOrderByRelationAggregateInput
    blocksReceived?: BlockOrderByRelationAggregateInput
    scheduledDates?: ScheduledDateOrderByRelationAggregateInput
    datesAsPartner?: ScheduledDateOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    onboardingCompleted?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    phoneVerified?: BoolFilter<"User"> | boolean
    lastActiveAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    onboardingAnswers?: OnboardingAnswerListRelationFilter
    likesGiven?: LikeListRelationFilter
    likesReceived?: LikeListRelationFilter
    matchesAsUserA?: MatchListRelationFilter
    matchesAsUserB?: MatchListRelationFilter
    messagesSent?: MessageListRelationFilter
    messagesReceived?: MessageListRelationFilter
    trustScore?: XOR<TrustScoreNullableRelationFilter, TrustScoreWhereInput> | null
    behaviorLogs?: BehaviorLogListRelationFilter
    riskAssessment?: XOR<RiskAssessmentNullableRelationFilter, RiskAssessmentWhereInput> | null
    reportsFiled?: ReportListRelationFilter
    reportsReceived?: ReportListRelationFilter
    safetySignals?: SafetySignalListRelationFilter
    verifications?: VerificationListRelationFilter
    intentHistory?: IntentHistoryListRelationFilter
    blocksCreated?: BlockListRelationFilter
    blocksReceived?: BlockListRelationFilter
    scheduledDates?: ScheduledDateListRelationFilter
    datesAsPartner?: ScheduledDateListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    onboardingCompleted?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    onboardingCompleted?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    phoneVerified?: BoolWithAggregatesFilter<"User"> | boolean
    lastActiveAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    firstName?: StringFilter<"Profile"> | string
    displayName?: StringNullableFilter<"Profile"> | string | null
    birthDate?: DateTimeFilter<"Profile"> | Date | string
    gender?: EnumGenderFilter<"Profile"> | $Enums.Gender
    genderPreferences?: EnumGenderNullableListFilter<"Profile">
    city?: StringNullableFilter<"Profile"> | string | null
    state?: StringNullableFilter<"Profile"> | string | null
    country?: StringNullableFilter<"Profile"> | string | null
    latitude?: FloatNullableFilter<"Profile"> | number | null
    longitude?: FloatNullableFilter<"Profile"> | number | null
    bio?: StringNullableFilter<"Profile"> | string | null
    height?: IntNullableFilter<"Profile"> | number | null
    relationshipIntent?: EnumRelationshipIntentNullableFilter<"Profile"> | $Enums.RelationshipIntent | null
    values?: JsonNullableFilter<"Profile">
    lifestyle?: JsonNullableFilter<"Profile">
    dealbreakers?: JsonNullableFilter<"Profile">
    profileStrengthScore?: IntFilter<"Profile"> | number
    completenessScore?: IntFilter<"Profile"> | number
    specificityScore?: IntFilter<"Profile"> | number
    consistencyScore?: IntFilter<"Profile"> | number
    stabilityScore?: IntFilter<"Profile"> | number
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    photos?: PhotoListRelationFilter
    prompts?: ProfilePromptListRelationFilter
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    displayName?: SortOrderInput | SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    genderPreferences?: SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    relationshipIntent?: SortOrderInput | SortOrder
    values?: SortOrderInput | SortOrder
    lifestyle?: SortOrderInput | SortOrder
    dealbreakers?: SortOrderInput | SortOrder
    profileStrengthScore?: SortOrder
    completenessScore?: SortOrder
    specificityScore?: SortOrder
    consistencyScore?: SortOrder
    stabilityScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    photos?: PhotoOrderByRelationAggregateInput
    prompts?: ProfilePromptOrderByRelationAggregateInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    firstName?: StringFilter<"Profile"> | string
    displayName?: StringNullableFilter<"Profile"> | string | null
    birthDate?: DateTimeFilter<"Profile"> | Date | string
    gender?: EnumGenderFilter<"Profile"> | $Enums.Gender
    genderPreferences?: EnumGenderNullableListFilter<"Profile">
    city?: StringNullableFilter<"Profile"> | string | null
    state?: StringNullableFilter<"Profile"> | string | null
    country?: StringNullableFilter<"Profile"> | string | null
    latitude?: FloatNullableFilter<"Profile"> | number | null
    longitude?: FloatNullableFilter<"Profile"> | number | null
    bio?: StringNullableFilter<"Profile"> | string | null
    height?: IntNullableFilter<"Profile"> | number | null
    relationshipIntent?: EnumRelationshipIntentNullableFilter<"Profile"> | $Enums.RelationshipIntent | null
    values?: JsonNullableFilter<"Profile">
    lifestyle?: JsonNullableFilter<"Profile">
    dealbreakers?: JsonNullableFilter<"Profile">
    profileStrengthScore?: IntFilter<"Profile"> | number
    completenessScore?: IntFilter<"Profile"> | number
    specificityScore?: IntFilter<"Profile"> | number
    consistencyScore?: IntFilter<"Profile"> | number
    stabilityScore?: IntFilter<"Profile"> | number
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    photos?: PhotoListRelationFilter
    prompts?: ProfilePromptListRelationFilter
  }, "id" | "userId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    displayName?: SortOrderInput | SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    genderPreferences?: SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    relationshipIntent?: SortOrderInput | SortOrder
    values?: SortOrderInput | SortOrder
    lifestyle?: SortOrderInput | SortOrder
    dealbreakers?: SortOrderInput | SortOrder
    profileStrengthScore?: SortOrder
    completenessScore?: SortOrder
    specificityScore?: SortOrder
    consistencyScore?: SortOrder
    stabilityScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    userId?: StringWithAggregatesFilter<"Profile"> | string
    firstName?: StringWithAggregatesFilter<"Profile"> | string
    displayName?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    birthDate?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    gender?: EnumGenderWithAggregatesFilter<"Profile"> | $Enums.Gender
    genderPreferences?: EnumGenderNullableListFilter<"Profile">
    city?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    state?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    country?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Profile"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Profile"> | number | null
    bio?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    height?: IntNullableWithAggregatesFilter<"Profile"> | number | null
    relationshipIntent?: EnumRelationshipIntentNullableWithAggregatesFilter<"Profile"> | $Enums.RelationshipIntent | null
    values?: JsonNullableWithAggregatesFilter<"Profile">
    lifestyle?: JsonNullableWithAggregatesFilter<"Profile">
    dealbreakers?: JsonNullableWithAggregatesFilter<"Profile">
    profileStrengthScore?: IntWithAggregatesFilter<"Profile"> | number
    completenessScore?: IntWithAggregatesFilter<"Profile"> | number
    specificityScore?: IntWithAggregatesFilter<"Profile"> | number
    consistencyScore?: IntWithAggregatesFilter<"Profile"> | number
    stabilityScore?: IntWithAggregatesFilter<"Profile"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type PhotoWhereInput = {
    AND?: PhotoWhereInput | PhotoWhereInput[]
    OR?: PhotoWhereInput[]
    NOT?: PhotoWhereInput | PhotoWhereInput[]
    id?: StringFilter<"Photo"> | string
    profileId?: StringFilter<"Photo"> | string
    url?: StringFilter<"Photo"> | string
    isMain?: BoolFilter<"Photo"> | boolean
    isVerified?: BoolFilter<"Photo"> | boolean
    order?: IntFilter<"Photo"> | number
    createdAt?: DateTimeFilter<"Photo"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }

  export type PhotoOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    url?: SortOrder
    isMain?: SortOrder
    isVerified?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type PhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PhotoWhereInput | PhotoWhereInput[]
    OR?: PhotoWhereInput[]
    NOT?: PhotoWhereInput | PhotoWhereInput[]
    profileId?: StringFilter<"Photo"> | string
    url?: StringFilter<"Photo"> | string
    isMain?: BoolFilter<"Photo"> | boolean
    isVerified?: BoolFilter<"Photo"> | boolean
    order?: IntFilter<"Photo"> | number
    createdAt?: DateTimeFilter<"Photo"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }, "id">

  export type PhotoOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    url?: SortOrder
    isMain?: SortOrder
    isVerified?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: PhotoCountOrderByAggregateInput
    _avg?: PhotoAvgOrderByAggregateInput
    _max?: PhotoMaxOrderByAggregateInput
    _min?: PhotoMinOrderByAggregateInput
    _sum?: PhotoSumOrderByAggregateInput
  }

  export type PhotoScalarWhereWithAggregatesInput = {
    AND?: PhotoScalarWhereWithAggregatesInput | PhotoScalarWhereWithAggregatesInput[]
    OR?: PhotoScalarWhereWithAggregatesInput[]
    NOT?: PhotoScalarWhereWithAggregatesInput | PhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Photo"> | string
    profileId?: StringWithAggregatesFilter<"Photo"> | string
    url?: StringWithAggregatesFilter<"Photo"> | string
    isMain?: BoolWithAggregatesFilter<"Photo"> | boolean
    isVerified?: BoolWithAggregatesFilter<"Photo"> | boolean
    order?: IntWithAggregatesFilter<"Photo"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Photo"> | Date | string
  }

  export type ProfilePromptWhereInput = {
    AND?: ProfilePromptWhereInput | ProfilePromptWhereInput[]
    OR?: ProfilePromptWhereInput[]
    NOT?: ProfilePromptWhereInput | ProfilePromptWhereInput[]
    id?: StringFilter<"ProfilePrompt"> | string
    profileId?: StringFilter<"ProfilePrompt"> | string
    question?: StringFilter<"ProfilePrompt"> | string
    answer?: StringFilter<"ProfilePrompt"> | string
    order?: IntFilter<"ProfilePrompt"> | number
    createdAt?: DateTimeFilter<"ProfilePrompt"> | Date | string
    updatedAt?: DateTimeFilter<"ProfilePrompt"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }

  export type ProfilePromptOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type ProfilePromptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProfilePromptWhereInput | ProfilePromptWhereInput[]
    OR?: ProfilePromptWhereInput[]
    NOT?: ProfilePromptWhereInput | ProfilePromptWhereInput[]
    profileId?: StringFilter<"ProfilePrompt"> | string
    question?: StringFilter<"ProfilePrompt"> | string
    answer?: StringFilter<"ProfilePrompt"> | string
    order?: IntFilter<"ProfilePrompt"> | number
    createdAt?: DateTimeFilter<"ProfilePrompt"> | Date | string
    updatedAt?: DateTimeFilter<"ProfilePrompt"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }, "id">

  export type ProfilePromptOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfilePromptCountOrderByAggregateInput
    _avg?: ProfilePromptAvgOrderByAggregateInput
    _max?: ProfilePromptMaxOrderByAggregateInput
    _min?: ProfilePromptMinOrderByAggregateInput
    _sum?: ProfilePromptSumOrderByAggregateInput
  }

  export type ProfilePromptScalarWhereWithAggregatesInput = {
    AND?: ProfilePromptScalarWhereWithAggregatesInput | ProfilePromptScalarWhereWithAggregatesInput[]
    OR?: ProfilePromptScalarWhereWithAggregatesInput[]
    NOT?: ProfilePromptScalarWhereWithAggregatesInput | ProfilePromptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProfilePrompt"> | string
    profileId?: StringWithAggregatesFilter<"ProfilePrompt"> | string
    question?: StringWithAggregatesFilter<"ProfilePrompt"> | string
    answer?: StringWithAggregatesFilter<"ProfilePrompt"> | string
    order?: IntWithAggregatesFilter<"ProfilePrompt"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProfilePrompt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProfilePrompt"> | Date | string
  }

  export type OnboardingQuestionWhereInput = {
    AND?: OnboardingQuestionWhereInput | OnboardingQuestionWhereInput[]
    OR?: OnboardingQuestionWhereInput[]
    NOT?: OnboardingQuestionWhereInput | OnboardingQuestionWhereInput[]
    id?: StringFilter<"OnboardingQuestion"> | string
    category?: EnumQuestionCategoryFilter<"OnboardingQuestion"> | $Enums.QuestionCategory
    questionText?: StringFilter<"OnboardingQuestion"> | string
    questionType?: EnumQuestionTypeFilter<"OnboardingQuestion"> | $Enums.QuestionType
    options?: JsonNullableFilter<"OnboardingQuestion">
    followUpLogic?: JsonNullableFilter<"OnboardingQuestion">
    order?: IntFilter<"OnboardingQuestion"> | number
    isActive?: BoolFilter<"OnboardingQuestion"> | boolean
    createdAt?: DateTimeFilter<"OnboardingQuestion"> | Date | string
    answers?: OnboardingAnswerListRelationFilter
  }

  export type OnboardingQuestionOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    options?: SortOrderInput | SortOrder
    followUpLogic?: SortOrderInput | SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    answers?: OnboardingAnswerOrderByRelationAggregateInput
  }

  export type OnboardingQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OnboardingQuestionWhereInput | OnboardingQuestionWhereInput[]
    OR?: OnboardingQuestionWhereInput[]
    NOT?: OnboardingQuestionWhereInput | OnboardingQuestionWhereInput[]
    category?: EnumQuestionCategoryFilter<"OnboardingQuestion"> | $Enums.QuestionCategory
    questionText?: StringFilter<"OnboardingQuestion"> | string
    questionType?: EnumQuestionTypeFilter<"OnboardingQuestion"> | $Enums.QuestionType
    options?: JsonNullableFilter<"OnboardingQuestion">
    followUpLogic?: JsonNullableFilter<"OnboardingQuestion">
    order?: IntFilter<"OnboardingQuestion"> | number
    isActive?: BoolFilter<"OnboardingQuestion"> | boolean
    createdAt?: DateTimeFilter<"OnboardingQuestion"> | Date | string
    answers?: OnboardingAnswerListRelationFilter
  }, "id">

  export type OnboardingQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    options?: SortOrderInput | SortOrder
    followUpLogic?: SortOrderInput | SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: OnboardingQuestionCountOrderByAggregateInput
    _avg?: OnboardingQuestionAvgOrderByAggregateInput
    _max?: OnboardingQuestionMaxOrderByAggregateInput
    _min?: OnboardingQuestionMinOrderByAggregateInput
    _sum?: OnboardingQuestionSumOrderByAggregateInput
  }

  export type OnboardingQuestionScalarWhereWithAggregatesInput = {
    AND?: OnboardingQuestionScalarWhereWithAggregatesInput | OnboardingQuestionScalarWhereWithAggregatesInput[]
    OR?: OnboardingQuestionScalarWhereWithAggregatesInput[]
    NOT?: OnboardingQuestionScalarWhereWithAggregatesInput | OnboardingQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OnboardingQuestion"> | string
    category?: EnumQuestionCategoryWithAggregatesFilter<"OnboardingQuestion"> | $Enums.QuestionCategory
    questionText?: StringWithAggregatesFilter<"OnboardingQuestion"> | string
    questionType?: EnumQuestionTypeWithAggregatesFilter<"OnboardingQuestion"> | $Enums.QuestionType
    options?: JsonNullableWithAggregatesFilter<"OnboardingQuestion">
    followUpLogic?: JsonNullableWithAggregatesFilter<"OnboardingQuestion">
    order?: IntWithAggregatesFilter<"OnboardingQuestion"> | number
    isActive?: BoolWithAggregatesFilter<"OnboardingQuestion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OnboardingQuestion"> | Date | string
  }

  export type OnboardingAnswerWhereInput = {
    AND?: OnboardingAnswerWhereInput | OnboardingAnswerWhereInput[]
    OR?: OnboardingAnswerWhereInput[]
    NOT?: OnboardingAnswerWhereInput | OnboardingAnswerWhereInput[]
    id?: StringFilter<"OnboardingAnswer"> | string
    userId?: StringFilter<"OnboardingAnswer"> | string
    questionId?: StringFilter<"OnboardingAnswer"> | string
    answer?: JsonFilter<"OnboardingAnswer">
    followUpCount?: IntFilter<"OnboardingAnswer"> | number
    confidence?: FloatNullableFilter<"OnboardingAnswer"> | number | null
    consistency?: FloatNullableFilter<"OnboardingAnswer"> | number | null
    createdAt?: DateTimeFilter<"OnboardingAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"OnboardingAnswer"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    question?: XOR<OnboardingQuestionRelationFilter, OnboardingQuestionWhereInput>
  }

  export type OnboardingAnswerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    followUpCount?: SortOrder
    confidence?: SortOrderInput | SortOrder
    consistency?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    question?: OnboardingQuestionOrderByWithRelationInput
  }

  export type OnboardingAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_questionId?: OnboardingAnswerUserIdQuestionIdCompoundUniqueInput
    AND?: OnboardingAnswerWhereInput | OnboardingAnswerWhereInput[]
    OR?: OnboardingAnswerWhereInput[]
    NOT?: OnboardingAnswerWhereInput | OnboardingAnswerWhereInput[]
    userId?: StringFilter<"OnboardingAnswer"> | string
    questionId?: StringFilter<"OnboardingAnswer"> | string
    answer?: JsonFilter<"OnboardingAnswer">
    followUpCount?: IntFilter<"OnboardingAnswer"> | number
    confidence?: FloatNullableFilter<"OnboardingAnswer"> | number | null
    consistency?: FloatNullableFilter<"OnboardingAnswer"> | number | null
    createdAt?: DateTimeFilter<"OnboardingAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"OnboardingAnswer"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    question?: XOR<OnboardingQuestionRelationFilter, OnboardingQuestionWhereInput>
  }, "id" | "userId_questionId">

  export type OnboardingAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    followUpCount?: SortOrder
    confidence?: SortOrderInput | SortOrder
    consistency?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OnboardingAnswerCountOrderByAggregateInput
    _avg?: OnboardingAnswerAvgOrderByAggregateInput
    _max?: OnboardingAnswerMaxOrderByAggregateInput
    _min?: OnboardingAnswerMinOrderByAggregateInput
    _sum?: OnboardingAnswerSumOrderByAggregateInput
  }

  export type OnboardingAnswerScalarWhereWithAggregatesInput = {
    AND?: OnboardingAnswerScalarWhereWithAggregatesInput | OnboardingAnswerScalarWhereWithAggregatesInput[]
    OR?: OnboardingAnswerScalarWhereWithAggregatesInput[]
    NOT?: OnboardingAnswerScalarWhereWithAggregatesInput | OnboardingAnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OnboardingAnswer"> | string
    userId?: StringWithAggregatesFilter<"OnboardingAnswer"> | string
    questionId?: StringWithAggregatesFilter<"OnboardingAnswer"> | string
    answer?: JsonWithAggregatesFilter<"OnboardingAnswer">
    followUpCount?: IntWithAggregatesFilter<"OnboardingAnswer"> | number
    confidence?: FloatNullableWithAggregatesFilter<"OnboardingAnswer"> | number | null
    consistency?: FloatNullableWithAggregatesFilter<"OnboardingAnswer"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"OnboardingAnswer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OnboardingAnswer"> | Date | string
  }

  export type LikeWhereInput = {
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    id?: StringFilter<"Like"> | string
    fromUserId?: StringFilter<"Like"> | string
    toUserId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    fromUser?: XOR<UserRelationFilter, UserWhereInput>
    toUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LikeOrderByWithRelationInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    fromUser?: UserOrderByWithRelationInput
    toUser?: UserOrderByWithRelationInput
  }

  export type LikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fromUserId_toUserId?: LikeFromUserIdToUserIdCompoundUniqueInput
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    fromUserId?: StringFilter<"Like"> | string
    toUserId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    fromUser?: XOR<UserRelationFilter, UserWhereInput>
    toUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "fromUserId_toUserId">

  export type LikeOrderByWithAggregationInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
    _count?: LikeCountOrderByAggregateInput
    _max?: LikeMaxOrderByAggregateInput
    _min?: LikeMinOrderByAggregateInput
  }

  export type LikeScalarWhereWithAggregatesInput = {
    AND?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    OR?: LikeScalarWhereWithAggregatesInput[]
    NOT?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Like"> | string
    fromUserId?: StringWithAggregatesFilter<"Like"> | string
    toUserId?: StringWithAggregatesFilter<"Like"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Like"> | Date | string
  }

  export type MatchWhereInput = {
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    id?: StringFilter<"Match"> | string
    userAId?: StringFilter<"Match"> | string
    userBId?: StringFilter<"Match"> | string
    overallScore?: IntFilter<"Match"> | number
    valuesScore?: IntFilter<"Match"> | number
    lifestyleScore?: IntFilter<"Match"> | number
    intentScore?: IntFilter<"Match"> | number
    communicationScore?: IntFilter<"Match"> | number
    logisticsScore?: IntFilter<"Match"> | number
    topReasons?: StringNullableListFilter<"Match">
    frictionPoint?: StringNullableFilter<"Match"> | string | null
    confidenceLevel?: FloatNullableFilter<"Match"> | number | null
    isActive?: BoolFilter<"Match"> | boolean
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
    userA?: XOR<UserRelationFilter, UserWhereInput>
    userB?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
    scheduledDates?: ScheduledDateListRelationFilter
  }

  export type MatchOrderByWithRelationInput = {
    id?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
    overallScore?: SortOrder
    valuesScore?: SortOrder
    lifestyleScore?: SortOrder
    intentScore?: SortOrder
    communicationScore?: SortOrder
    logisticsScore?: SortOrder
    topReasons?: SortOrder
    frictionPoint?: SortOrderInput | SortOrder
    confidenceLevel?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userA?: UserOrderByWithRelationInput
    userB?: UserOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    scheduledDates?: ScheduledDateOrderByRelationAggregateInput
  }

  export type MatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userAId_userBId?: MatchUserAIdUserBIdCompoundUniqueInput
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    userAId?: StringFilter<"Match"> | string
    userBId?: StringFilter<"Match"> | string
    overallScore?: IntFilter<"Match"> | number
    valuesScore?: IntFilter<"Match"> | number
    lifestyleScore?: IntFilter<"Match"> | number
    intentScore?: IntFilter<"Match"> | number
    communicationScore?: IntFilter<"Match"> | number
    logisticsScore?: IntFilter<"Match"> | number
    topReasons?: StringNullableListFilter<"Match">
    frictionPoint?: StringNullableFilter<"Match"> | string | null
    confidenceLevel?: FloatNullableFilter<"Match"> | number | null
    isActive?: BoolFilter<"Match"> | boolean
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
    userA?: XOR<UserRelationFilter, UserWhereInput>
    userB?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
    scheduledDates?: ScheduledDateListRelationFilter
  }, "id" | "userAId_userBId">

  export type MatchOrderByWithAggregationInput = {
    id?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
    overallScore?: SortOrder
    valuesScore?: SortOrder
    lifestyleScore?: SortOrder
    intentScore?: SortOrder
    communicationScore?: SortOrder
    logisticsScore?: SortOrder
    topReasons?: SortOrder
    frictionPoint?: SortOrderInput | SortOrder
    confidenceLevel?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MatchCountOrderByAggregateInput
    _avg?: MatchAvgOrderByAggregateInput
    _max?: MatchMaxOrderByAggregateInput
    _min?: MatchMinOrderByAggregateInput
    _sum?: MatchSumOrderByAggregateInput
  }

  export type MatchScalarWhereWithAggregatesInput = {
    AND?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    OR?: MatchScalarWhereWithAggregatesInput[]
    NOT?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Match"> | string
    userAId?: StringWithAggregatesFilter<"Match"> | string
    userBId?: StringWithAggregatesFilter<"Match"> | string
    overallScore?: IntWithAggregatesFilter<"Match"> | number
    valuesScore?: IntWithAggregatesFilter<"Match"> | number
    lifestyleScore?: IntWithAggregatesFilter<"Match"> | number
    intentScore?: IntWithAggregatesFilter<"Match"> | number
    communicationScore?: IntWithAggregatesFilter<"Match"> | number
    logisticsScore?: IntWithAggregatesFilter<"Match"> | number
    topReasons?: StringNullableListFilter<"Match">
    frictionPoint?: StringNullableWithAggregatesFilter<"Match"> | string | null
    confidenceLevel?: FloatNullableWithAggregatesFilter<"Match"> | number | null
    isActive?: BoolWithAggregatesFilter<"Match"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Match"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Match"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    matchId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    safetyScore?: IntNullableFilter<"Message"> | number | null
    safetyFlags?: StringNullableListFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    match?: XOR<MatchRelationFilter, MatchWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    matchId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    safetyScore?: SortOrderInput | SortOrder
    safetyFlags?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    match?: MatchOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    matchId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    safetyScore?: IntNullableFilter<"Message"> | number | null
    safetyFlags?: StringNullableListFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    match?: XOR<MatchRelationFilter, MatchWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    matchId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    safetyScore?: SortOrderInput | SortOrder
    safetyFlags?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    matchId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    receiverId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    status?: EnumMessageStatusWithAggregatesFilter<"Message"> | $Enums.MessageStatus
    safetyScore?: IntNullableWithAggregatesFilter<"Message"> | number | null
    safetyFlags?: StringNullableListFilter<"Message">
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
  }

  export type TrustScoreWhereInput = {
    AND?: TrustScoreWhereInput | TrustScoreWhereInput[]
    OR?: TrustScoreWhereInput[]
    NOT?: TrustScoreWhereInput | TrustScoreWhereInput[]
    id?: StringFilter<"TrustScore"> | string
    userId?: StringFilter<"TrustScore"> | string
    overallScore?: IntFilter<"TrustScore"> | number
    replyPatternScore?: IntFilter<"TrustScore"> | number
    commitmentScore?: IntFilter<"TrustScore"> | number
    respectScore?: IntFilter<"TrustScore"> | number
    toneConsistencyScore?: IntFilter<"TrustScore"> | number
    lastCalculatedAt?: DateTimeFilter<"TrustScore"> | Date | string
    createdAt?: DateTimeFilter<"TrustScore"> | Date | string
    updatedAt?: DateTimeFilter<"TrustScore"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TrustScoreOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    overallScore?: SortOrder
    replyPatternScore?: SortOrder
    commitmentScore?: SortOrder
    respectScore?: SortOrder
    toneConsistencyScore?: SortOrder
    lastCalculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TrustScoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: TrustScoreWhereInput | TrustScoreWhereInput[]
    OR?: TrustScoreWhereInput[]
    NOT?: TrustScoreWhereInput | TrustScoreWhereInput[]
    overallScore?: IntFilter<"TrustScore"> | number
    replyPatternScore?: IntFilter<"TrustScore"> | number
    commitmentScore?: IntFilter<"TrustScore"> | number
    respectScore?: IntFilter<"TrustScore"> | number
    toneConsistencyScore?: IntFilter<"TrustScore"> | number
    lastCalculatedAt?: DateTimeFilter<"TrustScore"> | Date | string
    createdAt?: DateTimeFilter<"TrustScore"> | Date | string
    updatedAt?: DateTimeFilter<"TrustScore"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type TrustScoreOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    overallScore?: SortOrder
    replyPatternScore?: SortOrder
    commitmentScore?: SortOrder
    respectScore?: SortOrder
    toneConsistencyScore?: SortOrder
    lastCalculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrustScoreCountOrderByAggregateInput
    _avg?: TrustScoreAvgOrderByAggregateInput
    _max?: TrustScoreMaxOrderByAggregateInput
    _min?: TrustScoreMinOrderByAggregateInput
    _sum?: TrustScoreSumOrderByAggregateInput
  }

  export type TrustScoreScalarWhereWithAggregatesInput = {
    AND?: TrustScoreScalarWhereWithAggregatesInput | TrustScoreScalarWhereWithAggregatesInput[]
    OR?: TrustScoreScalarWhereWithAggregatesInput[]
    NOT?: TrustScoreScalarWhereWithAggregatesInput | TrustScoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrustScore"> | string
    userId?: StringWithAggregatesFilter<"TrustScore"> | string
    overallScore?: IntWithAggregatesFilter<"TrustScore"> | number
    replyPatternScore?: IntWithAggregatesFilter<"TrustScore"> | number
    commitmentScore?: IntWithAggregatesFilter<"TrustScore"> | number
    respectScore?: IntWithAggregatesFilter<"TrustScore"> | number
    toneConsistencyScore?: IntWithAggregatesFilter<"TrustScore"> | number
    lastCalculatedAt?: DateTimeWithAggregatesFilter<"TrustScore"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"TrustScore"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrustScore"> | Date | string
  }

  export type BehaviorLogWhereInput = {
    AND?: BehaviorLogWhereInput | BehaviorLogWhereInput[]
    OR?: BehaviorLogWhereInput[]
    NOT?: BehaviorLogWhereInput | BehaviorLogWhereInput[]
    id?: StringFilter<"BehaviorLog"> | string
    userId?: StringFilter<"BehaviorLog"> | string
    behaviorType?: EnumBehaviorTypeFilter<"BehaviorLog"> | $Enums.BehaviorType
    metadata?: JsonNullableFilter<"BehaviorLog">
    score?: IntNullableFilter<"BehaviorLog"> | number | null
    createdAt?: DateTimeFilter<"BehaviorLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BehaviorLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    behaviorType?: SortOrder
    metadata?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BehaviorLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BehaviorLogWhereInput | BehaviorLogWhereInput[]
    OR?: BehaviorLogWhereInput[]
    NOT?: BehaviorLogWhereInput | BehaviorLogWhereInput[]
    userId?: StringFilter<"BehaviorLog"> | string
    behaviorType?: EnumBehaviorTypeFilter<"BehaviorLog"> | $Enums.BehaviorType
    metadata?: JsonNullableFilter<"BehaviorLog">
    score?: IntNullableFilter<"BehaviorLog"> | number | null
    createdAt?: DateTimeFilter<"BehaviorLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type BehaviorLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    behaviorType?: SortOrder
    metadata?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BehaviorLogCountOrderByAggregateInput
    _avg?: BehaviorLogAvgOrderByAggregateInput
    _max?: BehaviorLogMaxOrderByAggregateInput
    _min?: BehaviorLogMinOrderByAggregateInput
    _sum?: BehaviorLogSumOrderByAggregateInput
  }

  export type BehaviorLogScalarWhereWithAggregatesInput = {
    AND?: BehaviorLogScalarWhereWithAggregatesInput | BehaviorLogScalarWhereWithAggregatesInput[]
    OR?: BehaviorLogScalarWhereWithAggregatesInput[]
    NOT?: BehaviorLogScalarWhereWithAggregatesInput | BehaviorLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BehaviorLog"> | string
    userId?: StringWithAggregatesFilter<"BehaviorLog"> | string
    behaviorType?: EnumBehaviorTypeWithAggregatesFilter<"BehaviorLog"> | $Enums.BehaviorType
    metadata?: JsonNullableWithAggregatesFilter<"BehaviorLog">
    score?: IntNullableWithAggregatesFilter<"BehaviorLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"BehaviorLog"> | Date | string
  }

  export type RiskAssessmentWhereInput = {
    AND?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    OR?: RiskAssessmentWhereInput[]
    NOT?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    id?: StringFilter<"RiskAssessment"> | string
    userId?: StringFilter<"RiskAssessment"> | string
    riskIndex?: IntFilter<"RiskAssessment"> | number
    riskLevel?: EnumRiskLevelFilter<"RiskAssessment"> | $Enums.RiskLevel
    reportScore?: IntFilter<"RiskAssessment"> | number
    messageRiskScore?: IntFilter<"RiskAssessment"> | number
    patternRiskScore?: IntFilter<"RiskAssessment"> | number
    isRestricted?: BoolFilter<"RiskAssessment"> | boolean
    restrictions?: JsonNullableFilter<"RiskAssessment">
    lastAssessedAt?: DateTimeFilter<"RiskAssessment"> | Date | string
    createdAt?: DateTimeFilter<"RiskAssessment"> | Date | string
    updatedAt?: DateTimeFilter<"RiskAssessment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RiskAssessmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    riskIndex?: SortOrder
    riskLevel?: SortOrder
    reportScore?: SortOrder
    messageRiskScore?: SortOrder
    patternRiskScore?: SortOrder
    isRestricted?: SortOrder
    restrictions?: SortOrderInput | SortOrder
    lastAssessedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RiskAssessmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    OR?: RiskAssessmentWhereInput[]
    NOT?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    riskIndex?: IntFilter<"RiskAssessment"> | number
    riskLevel?: EnumRiskLevelFilter<"RiskAssessment"> | $Enums.RiskLevel
    reportScore?: IntFilter<"RiskAssessment"> | number
    messageRiskScore?: IntFilter<"RiskAssessment"> | number
    patternRiskScore?: IntFilter<"RiskAssessment"> | number
    isRestricted?: BoolFilter<"RiskAssessment"> | boolean
    restrictions?: JsonNullableFilter<"RiskAssessment">
    lastAssessedAt?: DateTimeFilter<"RiskAssessment"> | Date | string
    createdAt?: DateTimeFilter<"RiskAssessment"> | Date | string
    updatedAt?: DateTimeFilter<"RiskAssessment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type RiskAssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    riskIndex?: SortOrder
    riskLevel?: SortOrder
    reportScore?: SortOrder
    messageRiskScore?: SortOrder
    patternRiskScore?: SortOrder
    isRestricted?: SortOrder
    restrictions?: SortOrderInput | SortOrder
    lastAssessedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RiskAssessmentCountOrderByAggregateInput
    _avg?: RiskAssessmentAvgOrderByAggregateInput
    _max?: RiskAssessmentMaxOrderByAggregateInput
    _min?: RiskAssessmentMinOrderByAggregateInput
    _sum?: RiskAssessmentSumOrderByAggregateInput
  }

  export type RiskAssessmentScalarWhereWithAggregatesInput = {
    AND?: RiskAssessmentScalarWhereWithAggregatesInput | RiskAssessmentScalarWhereWithAggregatesInput[]
    OR?: RiskAssessmentScalarWhereWithAggregatesInput[]
    NOT?: RiskAssessmentScalarWhereWithAggregatesInput | RiskAssessmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskAssessment"> | string
    userId?: StringWithAggregatesFilter<"RiskAssessment"> | string
    riskIndex?: IntWithAggregatesFilter<"RiskAssessment"> | number
    riskLevel?: EnumRiskLevelWithAggregatesFilter<"RiskAssessment"> | $Enums.RiskLevel
    reportScore?: IntWithAggregatesFilter<"RiskAssessment"> | number
    messageRiskScore?: IntWithAggregatesFilter<"RiskAssessment"> | number
    patternRiskScore?: IntWithAggregatesFilter<"RiskAssessment"> | number
    isRestricted?: BoolWithAggregatesFilter<"RiskAssessment"> | boolean
    restrictions?: JsonNullableWithAggregatesFilter<"RiskAssessment">
    lastAssessedAt?: DateTimeWithAggregatesFilter<"RiskAssessment"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RiskAssessment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RiskAssessment"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    reporterId?: StringFilter<"Report"> | string
    reportedUserId?: StringFilter<"Report"> | string
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    description?: StringNullableFilter<"Report"> | string | null
    evidence?: JsonNullableFilter<"Report">
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    reviewNotes?: StringNullableFilter<"Report"> | string | null
    reviewedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    reporter?: XOR<UserRelationFilter, UserWhereInput>
    reportedUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    reporter?: UserOrderByWithRelationInput
    reportedUser?: UserOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    reporterId?: StringFilter<"Report"> | string
    reportedUserId?: StringFilter<"Report"> | string
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    description?: StringNullableFilter<"Report"> | string | null
    evidence?: JsonNullableFilter<"Report">
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    reviewNotes?: StringNullableFilter<"Report"> | string | null
    reviewedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    reporter?: XOR<UserRelationFilter, UserWhereInput>
    reportedUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    reporterId?: StringWithAggregatesFilter<"Report"> | string
    reportedUserId?: StringWithAggregatesFilter<"Report"> | string
    type?: EnumReportTypeWithAggregatesFilter<"Report"> | $Enums.ReportType
    description?: StringNullableWithAggregatesFilter<"Report"> | string | null
    evidence?: JsonNullableWithAggregatesFilter<"Report">
    status?: EnumReportStatusWithAggregatesFilter<"Report"> | $Enums.ReportStatus
    reviewNotes?: StringNullableWithAggregatesFilter<"Report"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"Report"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type SafetySignalWhereInput = {
    AND?: SafetySignalWhereInput | SafetySignalWhereInput[]
    OR?: SafetySignalWhereInput[]
    NOT?: SafetySignalWhereInput | SafetySignalWhereInput[]
    id?: StringFilter<"SafetySignal"> | string
    userId?: StringFilter<"SafetySignal"> | string
    signalType?: EnumSafetySignalTypeFilter<"SafetySignal"> | $Enums.SafetySignalType
    verifiedAt?: DateTimeFilter<"SafetySignal"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SafetySignal"> | Date | string | null
    createdAt?: DateTimeFilter<"SafetySignal"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SafetySignalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    signalType?: SortOrder
    verifiedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SafetySignalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_signalType?: SafetySignalUserIdSignalTypeCompoundUniqueInput
    AND?: SafetySignalWhereInput | SafetySignalWhereInput[]
    OR?: SafetySignalWhereInput[]
    NOT?: SafetySignalWhereInput | SafetySignalWhereInput[]
    userId?: StringFilter<"SafetySignal"> | string
    signalType?: EnumSafetySignalTypeFilter<"SafetySignal"> | $Enums.SafetySignalType
    verifiedAt?: DateTimeFilter<"SafetySignal"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SafetySignal"> | Date | string | null
    createdAt?: DateTimeFilter<"SafetySignal"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_signalType">

  export type SafetySignalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    signalType?: SortOrder
    verifiedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SafetySignalCountOrderByAggregateInput
    _max?: SafetySignalMaxOrderByAggregateInput
    _min?: SafetySignalMinOrderByAggregateInput
  }

  export type SafetySignalScalarWhereWithAggregatesInput = {
    AND?: SafetySignalScalarWhereWithAggregatesInput | SafetySignalScalarWhereWithAggregatesInput[]
    OR?: SafetySignalScalarWhereWithAggregatesInput[]
    NOT?: SafetySignalScalarWhereWithAggregatesInput | SafetySignalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SafetySignal"> | string
    userId?: StringWithAggregatesFilter<"SafetySignal"> | string
    signalType?: EnumSafetySignalTypeWithAggregatesFilter<"SafetySignal"> | $Enums.SafetySignalType
    verifiedAt?: DateTimeWithAggregatesFilter<"SafetySignal"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"SafetySignal"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SafetySignal"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    userId?: StringFilter<"Verification"> | string
    type?: StringFilter<"Verification"> | string
    status?: StringFilter<"Verification"> | string
    verificationData?: JsonNullableFilter<"Verification">
    verifiedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    verificationData?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    userId?: StringFilter<"Verification"> | string
    type?: StringFilter<"Verification"> | string
    status?: StringFilter<"Verification"> | string
    verificationData?: JsonNullableFilter<"Verification">
    verifiedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    verificationData?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    userId?: StringWithAggregatesFilter<"Verification"> | string
    type?: StringWithAggregatesFilter<"Verification"> | string
    status?: StringWithAggregatesFilter<"Verification"> | string
    verificationData?: JsonNullableWithAggregatesFilter<"Verification">
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type BlockWhereInput = {
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    id?: StringFilter<"Block"> | string
    blockerId?: StringFilter<"Block"> | string
    blockedUserId?: StringFilter<"Block"> | string
    reason?: StringNullableFilter<"Block"> | string | null
    createdAt?: DateTimeFilter<"Block"> | Date | string
    blocker?: XOR<UserRelationFilter, UserWhereInput>
    blockedUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BlockOrderByWithRelationInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedUserId?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    blocker?: UserOrderByWithRelationInput
    blockedUser?: UserOrderByWithRelationInput
  }

  export type BlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    blockerId_blockedUserId?: BlockBlockerIdBlockedUserIdCompoundUniqueInput
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    blockerId?: StringFilter<"Block"> | string
    blockedUserId?: StringFilter<"Block"> | string
    reason?: StringNullableFilter<"Block"> | string | null
    createdAt?: DateTimeFilter<"Block"> | Date | string
    blocker?: XOR<UserRelationFilter, UserWhereInput>
    blockedUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "blockerId_blockedUserId">

  export type BlockOrderByWithAggregationInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedUserId?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BlockCountOrderByAggregateInput
    _max?: BlockMaxOrderByAggregateInput
    _min?: BlockMinOrderByAggregateInput
  }

  export type BlockScalarWhereWithAggregatesInput = {
    AND?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    OR?: BlockScalarWhereWithAggregatesInput[]
    NOT?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Block"> | string
    blockerId?: StringWithAggregatesFilter<"Block"> | string
    blockedUserId?: StringWithAggregatesFilter<"Block"> | string
    reason?: StringNullableWithAggregatesFilter<"Block"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Block"> | Date | string
  }

  export type IntentHistoryWhereInput = {
    AND?: IntentHistoryWhereInput | IntentHistoryWhereInput[]
    OR?: IntentHistoryWhereInput[]
    NOT?: IntentHistoryWhereInput | IntentHistoryWhereInput[]
    id?: StringFilter<"IntentHistory"> | string
    userId?: StringFilter<"IntentHistory"> | string
    statedIntent?: EnumRelationshipIntentFilter<"IntentHistory"> | $Enums.RelationshipIntent
    behaviorIntent?: EnumRelationshipIntentNullableFilter<"IntentHistory"> | $Enums.RelationshipIntent | null
    confidence?: FloatFilter<"IntentHistory"> | number
    driftDetected?: BoolFilter<"IntentHistory"> | boolean
    createdAt?: DateTimeFilter<"IntentHistory"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type IntentHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    statedIntent?: SortOrder
    behaviorIntent?: SortOrderInput | SortOrder
    confidence?: SortOrder
    driftDetected?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type IntentHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IntentHistoryWhereInput | IntentHistoryWhereInput[]
    OR?: IntentHistoryWhereInput[]
    NOT?: IntentHistoryWhereInput | IntentHistoryWhereInput[]
    userId?: StringFilter<"IntentHistory"> | string
    statedIntent?: EnumRelationshipIntentFilter<"IntentHistory"> | $Enums.RelationshipIntent
    behaviorIntent?: EnumRelationshipIntentNullableFilter<"IntentHistory"> | $Enums.RelationshipIntent | null
    confidence?: FloatFilter<"IntentHistory"> | number
    driftDetected?: BoolFilter<"IntentHistory"> | boolean
    createdAt?: DateTimeFilter<"IntentHistory"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type IntentHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    statedIntent?: SortOrder
    behaviorIntent?: SortOrderInput | SortOrder
    confidence?: SortOrder
    driftDetected?: SortOrder
    createdAt?: SortOrder
    _count?: IntentHistoryCountOrderByAggregateInput
    _avg?: IntentHistoryAvgOrderByAggregateInput
    _max?: IntentHistoryMaxOrderByAggregateInput
    _min?: IntentHistoryMinOrderByAggregateInput
    _sum?: IntentHistorySumOrderByAggregateInput
  }

  export type IntentHistoryScalarWhereWithAggregatesInput = {
    AND?: IntentHistoryScalarWhereWithAggregatesInput | IntentHistoryScalarWhereWithAggregatesInput[]
    OR?: IntentHistoryScalarWhereWithAggregatesInput[]
    NOT?: IntentHistoryScalarWhereWithAggregatesInput | IntentHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IntentHistory"> | string
    userId?: StringWithAggregatesFilter<"IntentHistory"> | string
    statedIntent?: EnumRelationshipIntentWithAggregatesFilter<"IntentHistory"> | $Enums.RelationshipIntent
    behaviorIntent?: EnumRelationshipIntentNullableWithAggregatesFilter<"IntentHistory"> | $Enums.RelationshipIntent | null
    confidence?: FloatWithAggregatesFilter<"IntentHistory"> | number
    driftDetected?: BoolWithAggregatesFilter<"IntentHistory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"IntentHistory"> | Date | string
  }

  export type ScheduledDateWhereInput = {
    AND?: ScheduledDateWhereInput | ScheduledDateWhereInput[]
    OR?: ScheduledDateWhereInput[]
    NOT?: ScheduledDateWhereInput | ScheduledDateWhereInput[]
    id?: StringFilter<"ScheduledDate"> | string
    matchId?: StringFilter<"ScheduledDate"> | string
    schedulerId?: StringFilter<"ScheduledDate"> | string
    partnerId?: StringFilter<"ScheduledDate"> | string
    dateTime?: DateTimeFilter<"ScheduledDate"> | Date | string
    location?: StringNullableFilter<"ScheduledDate"> | string | null
    isPublicPlace?: BoolFilter<"ScheduledDate"> | boolean
    safetyCheckIn?: BoolFilter<"ScheduledDate"> | boolean
    checkInTime?: DateTimeNullableFilter<"ScheduledDate"> | Date | string | null
    locationSharing?: BoolFilter<"ScheduledDate"> | boolean
    safetyScore?: IntNullableFilter<"ScheduledDate"> | number | null
    concerns?: StringNullableListFilter<"ScheduledDate">
    suggestions?: StringNullableListFilter<"ScheduledDate">
    status?: StringFilter<"ScheduledDate"> | string
    createdAt?: DateTimeFilter<"ScheduledDate"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledDate"> | Date | string
    match?: XOR<MatchRelationFilter, MatchWhereInput>
    scheduler?: XOR<UserRelationFilter, UserWhereInput>
    partner?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ScheduledDateOrderByWithRelationInput = {
    id?: SortOrder
    matchId?: SortOrder
    schedulerId?: SortOrder
    partnerId?: SortOrder
    dateTime?: SortOrder
    location?: SortOrderInput | SortOrder
    isPublicPlace?: SortOrder
    safetyCheckIn?: SortOrder
    checkInTime?: SortOrderInput | SortOrder
    locationSharing?: SortOrder
    safetyScore?: SortOrderInput | SortOrder
    concerns?: SortOrder
    suggestions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    match?: MatchOrderByWithRelationInput
    scheduler?: UserOrderByWithRelationInput
    partner?: UserOrderByWithRelationInput
  }

  export type ScheduledDateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduledDateWhereInput | ScheduledDateWhereInput[]
    OR?: ScheduledDateWhereInput[]
    NOT?: ScheduledDateWhereInput | ScheduledDateWhereInput[]
    matchId?: StringFilter<"ScheduledDate"> | string
    schedulerId?: StringFilter<"ScheduledDate"> | string
    partnerId?: StringFilter<"ScheduledDate"> | string
    dateTime?: DateTimeFilter<"ScheduledDate"> | Date | string
    location?: StringNullableFilter<"ScheduledDate"> | string | null
    isPublicPlace?: BoolFilter<"ScheduledDate"> | boolean
    safetyCheckIn?: BoolFilter<"ScheduledDate"> | boolean
    checkInTime?: DateTimeNullableFilter<"ScheduledDate"> | Date | string | null
    locationSharing?: BoolFilter<"ScheduledDate"> | boolean
    safetyScore?: IntNullableFilter<"ScheduledDate"> | number | null
    concerns?: StringNullableListFilter<"ScheduledDate">
    suggestions?: StringNullableListFilter<"ScheduledDate">
    status?: StringFilter<"ScheduledDate"> | string
    createdAt?: DateTimeFilter<"ScheduledDate"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledDate"> | Date | string
    match?: XOR<MatchRelationFilter, MatchWhereInput>
    scheduler?: XOR<UserRelationFilter, UserWhereInput>
    partner?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ScheduledDateOrderByWithAggregationInput = {
    id?: SortOrder
    matchId?: SortOrder
    schedulerId?: SortOrder
    partnerId?: SortOrder
    dateTime?: SortOrder
    location?: SortOrderInput | SortOrder
    isPublicPlace?: SortOrder
    safetyCheckIn?: SortOrder
    checkInTime?: SortOrderInput | SortOrder
    locationSharing?: SortOrder
    safetyScore?: SortOrderInput | SortOrder
    concerns?: SortOrder
    suggestions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduledDateCountOrderByAggregateInput
    _avg?: ScheduledDateAvgOrderByAggregateInput
    _max?: ScheduledDateMaxOrderByAggregateInput
    _min?: ScheduledDateMinOrderByAggregateInput
    _sum?: ScheduledDateSumOrderByAggregateInput
  }

  export type ScheduledDateScalarWhereWithAggregatesInput = {
    AND?: ScheduledDateScalarWhereWithAggregatesInput | ScheduledDateScalarWhereWithAggregatesInput[]
    OR?: ScheduledDateScalarWhereWithAggregatesInput[]
    NOT?: ScheduledDateScalarWhereWithAggregatesInput | ScheduledDateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduledDate"> | string
    matchId?: StringWithAggregatesFilter<"ScheduledDate"> | string
    schedulerId?: StringWithAggregatesFilter<"ScheduledDate"> | string
    partnerId?: StringWithAggregatesFilter<"ScheduledDate"> | string
    dateTime?: DateTimeWithAggregatesFilter<"ScheduledDate"> | Date | string
    location?: StringNullableWithAggregatesFilter<"ScheduledDate"> | string | null
    isPublicPlace?: BoolWithAggregatesFilter<"ScheduledDate"> | boolean
    safetyCheckIn?: BoolWithAggregatesFilter<"ScheduledDate"> | boolean
    checkInTime?: DateTimeNullableWithAggregatesFilter<"ScheduledDate"> | Date | string | null
    locationSharing?: BoolWithAggregatesFilter<"ScheduledDate"> | boolean
    safetyScore?: IntNullableWithAggregatesFilter<"ScheduledDate"> | number | null
    concerns?: StringNullableListFilter<"ScheduledDate">
    suggestions?: StringNullableListFilter<"ScheduledDate">
    status?: StringWithAggregatesFilter<"ScheduledDate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ScheduledDate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduledDate"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    firstName: string
    displayName?: string | null
    birthDate: Date | string
    gender: $Enums.Gender
    genderPreferences?: ProfileCreategenderPreferencesInput | $Enums.Gender[]
    city?: string | null
    state?: string | null
    country?: string | null
    latitude?: number | null
    longitude?: number | null
    bio?: string | null
    height?: number | null
    relationshipIntent?: $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: number
    completenessScore?: number
    specificityScore?: number
    consistencyScore?: number
    stabilityScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    photos?: PhotoCreateNestedManyWithoutProfileInput
    prompts?: ProfilePromptCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    firstName: string
    displayName?: string | null
    birthDate: Date | string
    gender: $Enums.Gender
    genderPreferences?: ProfileCreategenderPreferencesInput | $Enums.Gender[]
    city?: string | null
    state?: string | null
    country?: string | null
    latitude?: number | null
    longitude?: number | null
    bio?: string | null
    height?: number | null
    relationshipIntent?: $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: number
    completenessScore?: number
    specificityScore?: number
    consistencyScore?: number
    stabilityScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoUncheckedCreateNestedManyWithoutProfileInput
    prompts?: ProfilePromptUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    genderPreferences?: ProfileUpdategenderPreferencesInput | $Enums.Gender[]
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipIntent?: NullableEnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    specificityScore?: IntFieldUpdateOperationsInput | number
    consistencyScore?: IntFieldUpdateOperationsInput | number
    stabilityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    photos?: PhotoUpdateManyWithoutProfileNestedInput
    prompts?: ProfilePromptUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    genderPreferences?: ProfileUpdategenderPreferencesInput | $Enums.Gender[]
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipIntent?: NullableEnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    specificityScore?: IntFieldUpdateOperationsInput | number
    consistencyScore?: IntFieldUpdateOperationsInput | number
    stabilityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUncheckedUpdateManyWithoutProfileNestedInput
    prompts?: ProfilePromptUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    firstName: string
    displayName?: string | null
    birthDate: Date | string
    gender: $Enums.Gender
    genderPreferences?: ProfileCreategenderPreferencesInput | $Enums.Gender[]
    city?: string | null
    state?: string | null
    country?: string | null
    latitude?: number | null
    longitude?: number | null
    bio?: string | null
    height?: number | null
    relationshipIntent?: $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: number
    completenessScore?: number
    specificityScore?: number
    consistencyScore?: number
    stabilityScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    genderPreferences?: ProfileUpdategenderPreferencesInput | $Enums.Gender[]
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipIntent?: NullableEnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    specificityScore?: IntFieldUpdateOperationsInput | number
    consistencyScore?: IntFieldUpdateOperationsInput | number
    stabilityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    genderPreferences?: ProfileUpdategenderPreferencesInput | $Enums.Gender[]
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipIntent?: NullableEnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    specificityScore?: IntFieldUpdateOperationsInput | number
    consistencyScore?: IntFieldUpdateOperationsInput | number
    stabilityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoCreateInput = {
    id?: string
    url: string
    isMain?: boolean
    isVerified?: boolean
    order?: number
    createdAt?: Date | string
    profile: ProfileCreateNestedOneWithoutPhotosInput
  }

  export type PhotoUncheckedCreateInput = {
    id?: string
    profileId: string
    url: string
    isMain?: boolean
    isVerified?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type PhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type PhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoCreateManyInput = {
    id?: string
    profileId: string
    url: string
    isMain?: boolean
    isVerified?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type PhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfilePromptCreateInput = {
    id?: string
    question: string
    answer: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutPromptsInput
  }

  export type ProfilePromptUncheckedCreateInput = {
    id?: string
    profileId: string
    question: string
    answer: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfilePromptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPromptsNestedInput
  }

  export type ProfilePromptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfilePromptCreateManyInput = {
    id?: string
    profileId: string
    question: string
    answer: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfilePromptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfilePromptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingQuestionCreateInput = {
    id?: string
    category: $Enums.QuestionCategory
    questionText: string
    questionType: $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    followUpLogic?: NullableJsonNullValueInput | InputJsonValue
    order: number
    isActive?: boolean
    createdAt?: Date | string
    answers?: OnboardingAnswerCreateNestedManyWithoutQuestionInput
  }

  export type OnboardingQuestionUncheckedCreateInput = {
    id?: string
    category: $Enums.QuestionCategory
    questionText: string
    questionType: $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    followUpLogic?: NullableJsonNullValueInput | InputJsonValue
    order: number
    isActive?: boolean
    createdAt?: Date | string
    answers?: OnboardingAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type OnboardingQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumQuestionCategoryFieldUpdateOperationsInput | $Enums.QuestionCategory
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    followUpLogic?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: OnboardingAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type OnboardingQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumQuestionCategoryFieldUpdateOperationsInput | $Enums.QuestionCategory
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    followUpLogic?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: OnboardingAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type OnboardingQuestionCreateManyInput = {
    id?: string
    category: $Enums.QuestionCategory
    questionText: string
    questionType: $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    followUpLogic?: NullableJsonNullValueInput | InputJsonValue
    order: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type OnboardingQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumQuestionCategoryFieldUpdateOperationsInput | $Enums.QuestionCategory
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    followUpLogic?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumQuestionCategoryFieldUpdateOperationsInput | $Enums.QuestionCategory
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    followUpLogic?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingAnswerCreateInput = {
    id?: string
    answer: JsonNullValueInput | InputJsonValue
    followUpCount?: number
    confidence?: number | null
    consistency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOnboardingAnswersInput
    question: OnboardingQuestionCreateNestedOneWithoutAnswersInput
  }

  export type OnboardingAnswerUncheckedCreateInput = {
    id?: string
    userId: string
    questionId: string
    answer: JsonNullValueInput | InputJsonValue
    followUpCount?: number
    confidence?: number | null
    consistency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnboardingAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: JsonNullValueInput | InputJsonValue
    followUpCount?: IntFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    consistency?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOnboardingAnswersNestedInput
    question?: OnboardingQuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type OnboardingAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: JsonNullValueInput | InputJsonValue
    followUpCount?: IntFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    consistency?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingAnswerCreateManyInput = {
    id?: string
    userId: string
    questionId: string
    answer: JsonNullValueInput | InputJsonValue
    followUpCount?: number
    confidence?: number | null
    consistency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnboardingAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: JsonNullValueInput | InputJsonValue
    followUpCount?: IntFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    consistency?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: JsonNullValueInput | InputJsonValue
    followUpCount?: IntFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    consistency?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateInput = {
    id?: string
    createdAt?: Date | string
    fromUser: UserCreateNestedOneWithoutLikesGivenInput
    toUser: UserCreateNestedOneWithoutLikesReceivedInput
  }

  export type LikeUncheckedCreateInput = {
    id?: string
    fromUserId: string
    toUserId: string
    createdAt?: Date | string
  }

  export type LikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUser?: UserUpdateOneRequiredWithoutLikesGivenNestedInput
    toUser?: UserUpdateOneRequiredWithoutLikesReceivedNestedInput
  }

  export type LikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateManyInput = {
    id?: string
    fromUserId: string
    toUserId: string
    createdAt?: Date | string
  }

  export type LikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchCreateInput = {
    id?: string
    overallScore?: number
    valuesScore?: number
    lifestyleScore?: number
    intentScore?: number
    communicationScore?: number
    logisticsScore?: number
    topReasons?: MatchCreatetopReasonsInput | string[]
    frictionPoint?: string | null
    confidenceLevel?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userA: UserCreateNestedOneWithoutMatchesAsUserAInput
    userB: UserCreateNestedOneWithoutMatchesAsUserBInput
    messages?: MessageCreateNestedManyWithoutMatchInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateInput = {
    id?: string
    userAId: string
    userBId: string
    overallScore?: number
    valuesScore?: number
    lifestyleScore?: number
    intentScore?: number
    communicationScore?: number
    logisticsScore?: number
    topReasons?: MatchCreatetopReasonsInput | string[]
    frictionPoint?: string | null
    confidenceLevel?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutMatchInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    valuesScore?: IntFieldUpdateOperationsInput | number
    lifestyleScore?: IntFieldUpdateOperationsInput | number
    intentScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    logisticsScore?: IntFieldUpdateOperationsInput | number
    topReasons?: MatchUpdatetopReasonsInput | string[]
    frictionPoint?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userA?: UserUpdateOneRequiredWithoutMatchesAsUserANestedInput
    userB?: UserUpdateOneRequiredWithoutMatchesAsUserBNestedInput
    messages?: MessageUpdateManyWithoutMatchNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    valuesScore?: IntFieldUpdateOperationsInput | number
    lifestyleScore?: IntFieldUpdateOperationsInput | number
    intentScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    logisticsScore?: IntFieldUpdateOperationsInput | number
    topReasons?: MatchUpdatetopReasonsInput | string[]
    frictionPoint?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutMatchNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchCreateManyInput = {
    id?: string
    userAId: string
    userBId: string
    overallScore?: number
    valuesScore?: number
    lifestyleScore?: number
    intentScore?: number
    communicationScore?: number
    logisticsScore?: number
    topReasons?: MatchCreatetopReasonsInput | string[]
    frictionPoint?: string | null
    confidenceLevel?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    valuesScore?: IntFieldUpdateOperationsInput | number
    lifestyleScore?: IntFieldUpdateOperationsInput | number
    intentScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    logisticsScore?: IntFieldUpdateOperationsInput | number
    topReasons?: MatchUpdatetopReasonsInput | string[]
    frictionPoint?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    valuesScore?: IntFieldUpdateOperationsInput | number
    lifestyleScore?: IntFieldUpdateOperationsInput | number
    intentScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    logisticsScore?: IntFieldUpdateOperationsInput | number
    topReasons?: MatchUpdatetopReasonsInput | string[]
    frictionPoint?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    status?: $Enums.MessageStatus
    safetyScore?: number | null
    safetyFlags?: MessageCreatesafetyFlagsInput | string[]
    createdAt?: Date | string
    readAt?: Date | string | null
    match: MatchCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesSentInput
    receiver: UserCreateNestedOneWithoutMessagesReceivedInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    matchId: string
    senderId: string
    receiverId: string
    content: string
    status?: $Enums.MessageStatus
    safetyScore?: number | null
    safetyFlags?: MessageCreatesafetyFlagsInput | string[]
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    safetyFlags?: MessageUpdatesafetyFlagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    match?: MatchUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    receiver?: UserUpdateOneRequiredWithoutMessagesReceivedNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    safetyFlags?: MessageUpdatesafetyFlagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateManyInput = {
    id?: string
    matchId: string
    senderId: string
    receiverId: string
    content: string
    status?: $Enums.MessageStatus
    safetyScore?: number | null
    safetyFlags?: MessageCreatesafetyFlagsInput | string[]
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    safetyFlags?: MessageUpdatesafetyFlagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    safetyFlags?: MessageUpdatesafetyFlagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrustScoreCreateInput = {
    id?: string
    overallScore?: number
    replyPatternScore?: number
    commitmentScore?: number
    respectScore?: number
    toneConsistencyScore?: number
    lastCalculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTrustScoreInput
  }

  export type TrustScoreUncheckedCreateInput = {
    id?: string
    userId: string
    overallScore?: number
    replyPatternScore?: number
    commitmentScore?: number
    respectScore?: number
    toneConsistencyScore?: number
    lastCalculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrustScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    replyPatternScore?: IntFieldUpdateOperationsInput | number
    commitmentScore?: IntFieldUpdateOperationsInput | number
    respectScore?: IntFieldUpdateOperationsInput | number
    toneConsistencyScore?: IntFieldUpdateOperationsInput | number
    lastCalculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrustScoreNestedInput
  }

  export type TrustScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    replyPatternScore?: IntFieldUpdateOperationsInput | number
    commitmentScore?: IntFieldUpdateOperationsInput | number
    respectScore?: IntFieldUpdateOperationsInput | number
    toneConsistencyScore?: IntFieldUpdateOperationsInput | number
    lastCalculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustScoreCreateManyInput = {
    id?: string
    userId: string
    overallScore?: number
    replyPatternScore?: number
    commitmentScore?: number
    respectScore?: number
    toneConsistencyScore?: number
    lastCalculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrustScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    replyPatternScore?: IntFieldUpdateOperationsInput | number
    commitmentScore?: IntFieldUpdateOperationsInput | number
    respectScore?: IntFieldUpdateOperationsInput | number
    toneConsistencyScore?: IntFieldUpdateOperationsInput | number
    lastCalculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    replyPatternScore?: IntFieldUpdateOperationsInput | number
    commitmentScore?: IntFieldUpdateOperationsInput | number
    respectScore?: IntFieldUpdateOperationsInput | number
    toneConsistencyScore?: IntFieldUpdateOperationsInput | number
    lastCalculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorLogCreateInput = {
    id?: string
    behaviorType: $Enums.BehaviorType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBehaviorLogsInput
  }

  export type BehaviorLogUncheckedCreateInput = {
    id?: string
    userId: string
    behaviorType: $Enums.BehaviorType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    createdAt?: Date | string
  }

  export type BehaviorLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    behaviorType?: EnumBehaviorTypeFieldUpdateOperationsInput | $Enums.BehaviorType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBehaviorLogsNestedInput
  }

  export type BehaviorLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    behaviorType?: EnumBehaviorTypeFieldUpdateOperationsInput | $Enums.BehaviorType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorLogCreateManyInput = {
    id?: string
    userId: string
    behaviorType: $Enums.BehaviorType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    createdAt?: Date | string
  }

  export type BehaviorLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    behaviorType?: EnumBehaviorTypeFieldUpdateOperationsInput | $Enums.BehaviorType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    behaviorType?: EnumBehaviorTypeFieldUpdateOperationsInput | $Enums.BehaviorType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAssessmentCreateInput = {
    id?: string
    riskIndex?: number
    riskLevel?: $Enums.RiskLevel
    reportScore?: number
    messageRiskScore?: number
    patternRiskScore?: number
    isRestricted?: boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    lastAssessedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRiskAssessmentInput
  }

  export type RiskAssessmentUncheckedCreateInput = {
    id?: string
    userId: string
    riskIndex?: number
    riskLevel?: $Enums.RiskLevel
    reportScore?: number
    messageRiskScore?: number
    patternRiskScore?: number
    isRestricted?: boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    lastAssessedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskAssessmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskIndex?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    reportScore?: IntFieldUpdateOperationsInput | number
    messageRiskScore?: IntFieldUpdateOperationsInput | number
    patternRiskScore?: IntFieldUpdateOperationsInput | number
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    lastAssessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRiskAssessmentNestedInput
  }

  export type RiskAssessmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    riskIndex?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    reportScore?: IntFieldUpdateOperationsInput | number
    messageRiskScore?: IntFieldUpdateOperationsInput | number
    patternRiskScore?: IntFieldUpdateOperationsInput | number
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    lastAssessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAssessmentCreateManyInput = {
    id?: string
    userId: string
    riskIndex?: number
    riskLevel?: $Enums.RiskLevel
    reportScore?: number
    messageRiskScore?: number
    patternRiskScore?: number
    isRestricted?: boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    lastAssessedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskAssessmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskIndex?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    reportScore?: IntFieldUpdateOperationsInput | number
    messageRiskScore?: IntFieldUpdateOperationsInput | number
    patternRiskScore?: IntFieldUpdateOperationsInput | number
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    lastAssessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAssessmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    riskIndex?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    reportScore?: IntFieldUpdateOperationsInput | number
    messageRiskScore?: IntFieldUpdateOperationsInput | number
    patternRiskScore?: IntFieldUpdateOperationsInput | number
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    lastAssessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    type: $Enums.ReportType
    description?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    reviewNotes?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportsFiledInput
    reportedUser: UserCreateNestedOneWithoutReportsReceivedInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    reporterId: string
    reportedUserId: string
    type: $Enums.ReportType
    description?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    reviewNotes?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportsFiledNestedInput
    reportedUser?: UserUpdateOneRequiredWithoutReportsReceivedNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: string
    reporterId: string
    reportedUserId: string
    type: $Enums.ReportType
    description?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    reviewNotes?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetySignalCreateInput = {
    id?: string
    signalType: $Enums.SafetySignalType
    verifiedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSafetySignalsInput
  }

  export type SafetySignalUncheckedCreateInput = {
    id?: string
    userId: string
    signalType: $Enums.SafetySignalType
    verifiedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SafetySignalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    signalType?: EnumSafetySignalTypeFieldUpdateOperationsInput | $Enums.SafetySignalType
    verifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSafetySignalsNestedInput
  }

  export type SafetySignalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    signalType?: EnumSafetySignalTypeFieldUpdateOperationsInput | $Enums.SafetySignalType
    verifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetySignalCreateManyInput = {
    id?: string
    userId: string
    signalType: $Enums.SafetySignalType
    verifiedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SafetySignalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    signalType?: EnumSafetySignalTypeFieldUpdateOperationsInput | $Enums.SafetySignalType
    verifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetySignalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    signalType?: EnumSafetySignalTypeFieldUpdateOperationsInput | $Enums.SafetySignalType
    verifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    type: string
    status?: string
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutVerificationsInput
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    status?: string
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    verifiedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVerificationsNestedInput
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    status?: string
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    verifiedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateInput = {
    id?: string
    reason?: string | null
    createdAt?: Date | string
    blocker: UserCreateNestedOneWithoutBlocksCreatedInput
    blockedUser: UserCreateNestedOneWithoutBlocksReceivedInput
  }

  export type BlockUncheckedCreateInput = {
    id?: string
    blockerId: string
    blockedUserId: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type BlockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocker?: UserUpdateOneRequiredWithoutBlocksCreatedNestedInput
    blockedUser?: UserUpdateOneRequiredWithoutBlocksReceivedNestedInput
  }

  export type BlockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    blockedUserId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateManyInput = {
    id?: string
    blockerId: string
    blockedUserId: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type BlockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    blockedUserId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentHistoryCreateInput = {
    id?: string
    statedIntent: $Enums.RelationshipIntent
    behaviorIntent?: $Enums.RelationshipIntent | null
    confidence?: number
    driftDetected?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutIntentHistoryInput
  }

  export type IntentHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    statedIntent: $Enums.RelationshipIntent
    behaviorIntent?: $Enums.RelationshipIntent | null
    confidence?: number
    driftDetected?: boolean
    createdAt?: Date | string
  }

  export type IntentHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    statedIntent?: EnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent
    behaviorIntent?: NullableEnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent | null
    confidence?: FloatFieldUpdateOperationsInput | number
    driftDetected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIntentHistoryNestedInput
  }

  export type IntentHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statedIntent?: EnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent
    behaviorIntent?: NullableEnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent | null
    confidence?: FloatFieldUpdateOperationsInput | number
    driftDetected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentHistoryCreateManyInput = {
    id?: string
    userId: string
    statedIntent: $Enums.RelationshipIntent
    behaviorIntent?: $Enums.RelationshipIntent | null
    confidence?: number
    driftDetected?: boolean
    createdAt?: Date | string
  }

  export type IntentHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    statedIntent?: EnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent
    behaviorIntent?: NullableEnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent | null
    confidence?: FloatFieldUpdateOperationsInput | number
    driftDetected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statedIntent?: EnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent
    behaviorIntent?: NullableEnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent | null
    confidence?: FloatFieldUpdateOperationsInput | number
    driftDetected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledDateCreateInput = {
    id?: string
    dateTime: Date | string
    location?: string | null
    isPublicPlace?: boolean
    safetyCheckIn?: boolean
    checkInTime?: Date | string | null
    locationSharing?: boolean
    safetyScore?: number | null
    concerns?: ScheduledDateCreateconcernsInput | string[]
    suggestions?: ScheduledDateCreatesuggestionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    match: MatchCreateNestedOneWithoutScheduledDatesInput
    scheduler: UserCreateNestedOneWithoutScheduledDatesInput
    partner: UserCreateNestedOneWithoutDatesAsPartnerInput
  }

  export type ScheduledDateUncheckedCreateInput = {
    id?: string
    matchId: string
    schedulerId: string
    partnerId: string
    dateTime: Date | string
    location?: string | null
    isPublicPlace?: boolean
    safetyCheckIn?: boolean
    checkInTime?: Date | string | null
    locationSharing?: boolean
    safetyScore?: number | null
    concerns?: ScheduledDateCreateconcernsInput | string[]
    suggestions?: ScheduledDateCreatesuggestionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledDateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublicPlace?: BoolFieldUpdateOperationsInput | boolean
    safetyCheckIn?: BoolFieldUpdateOperationsInput | boolean
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    concerns?: ScheduledDateUpdateconcernsInput | string[]
    suggestions?: ScheduledDateUpdatesuggestionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutScheduledDatesNestedInput
    scheduler?: UserUpdateOneRequiredWithoutScheduledDatesNestedInput
    partner?: UserUpdateOneRequiredWithoutDatesAsPartnerNestedInput
  }

  export type ScheduledDateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    schedulerId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublicPlace?: BoolFieldUpdateOperationsInput | boolean
    safetyCheckIn?: BoolFieldUpdateOperationsInput | boolean
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    concerns?: ScheduledDateUpdateconcernsInput | string[]
    suggestions?: ScheduledDateUpdatesuggestionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledDateCreateManyInput = {
    id?: string
    matchId: string
    schedulerId: string
    partnerId: string
    dateTime: Date | string
    location?: string | null
    isPublicPlace?: boolean
    safetyCheckIn?: boolean
    checkInTime?: Date | string | null
    locationSharing?: boolean
    safetyScore?: number | null
    concerns?: ScheduledDateCreateconcernsInput | string[]
    suggestions?: ScheduledDateCreatesuggestionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledDateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublicPlace?: BoolFieldUpdateOperationsInput | boolean
    safetyCheckIn?: BoolFieldUpdateOperationsInput | boolean
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    concerns?: ScheduledDateUpdateconcernsInput | string[]
    suggestions?: ScheduledDateUpdatesuggestionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledDateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    schedulerId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublicPlace?: BoolFieldUpdateOperationsInput | boolean
    safetyCheckIn?: BoolFieldUpdateOperationsInput | boolean
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    concerns?: ScheduledDateUpdateconcernsInput | string[]
    suggestions?: ScheduledDateUpdatesuggestionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProfileNullableRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type OnboardingAnswerListRelationFilter = {
    every?: OnboardingAnswerWhereInput
    some?: OnboardingAnswerWhereInput
    none?: OnboardingAnswerWhereInput
  }

  export type LikeListRelationFilter = {
    every?: LikeWhereInput
    some?: LikeWhereInput
    none?: LikeWhereInput
  }

  export type MatchListRelationFilter = {
    every?: MatchWhereInput
    some?: MatchWhereInput
    none?: MatchWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type TrustScoreNullableRelationFilter = {
    is?: TrustScoreWhereInput | null
    isNot?: TrustScoreWhereInput | null
  }

  export type BehaviorLogListRelationFilter = {
    every?: BehaviorLogWhereInput
    some?: BehaviorLogWhereInput
    none?: BehaviorLogWhereInput
  }

  export type RiskAssessmentNullableRelationFilter = {
    is?: RiskAssessmentWhereInput | null
    isNot?: RiskAssessmentWhereInput | null
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type SafetySignalListRelationFilter = {
    every?: SafetySignalWhereInput
    some?: SafetySignalWhereInput
    none?: SafetySignalWhereInput
  }

  export type VerificationListRelationFilter = {
    every?: VerificationWhereInput
    some?: VerificationWhereInput
    none?: VerificationWhereInput
  }

  export type IntentHistoryListRelationFilter = {
    every?: IntentHistoryWhereInput
    some?: IntentHistoryWhereInput
    none?: IntentHistoryWhereInput
  }

  export type BlockListRelationFilter = {
    every?: BlockWhereInput
    some?: BlockWhereInput
    none?: BlockWhereInput
  }

  export type ScheduledDateListRelationFilter = {
    every?: ScheduledDateWhereInput
    some?: ScheduledDateWhereInput
    none?: ScheduledDateWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OnboardingAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BehaviorLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SafetySignalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntentHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduledDateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    onboardingCompleted?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    onboardingCompleted?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    onboardingCompleted?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type EnumGenderNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    has?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumRelationshipIntentNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipIntent | EnumRelationshipIntentFieldRefInput<$PrismaModel> | null
    in?: $Enums.RelationshipIntent[] | ListEnumRelationshipIntentFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RelationshipIntent[] | ListEnumRelationshipIntentFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRelationshipIntentNullableFilter<$PrismaModel> | $Enums.RelationshipIntent | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PhotoListRelationFilter = {
    every?: PhotoWhereInput
    some?: PhotoWhereInput
    none?: PhotoWhereInput
  }

  export type ProfilePromptListRelationFilter = {
    every?: ProfilePromptWhereInput
    some?: ProfilePromptWhereInput
    none?: ProfilePromptWhereInput
  }

  export type PhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfilePromptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    displayName?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    genderPreferences?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    bio?: SortOrder
    height?: SortOrder
    relationshipIntent?: SortOrder
    values?: SortOrder
    lifestyle?: SortOrder
    dealbreakers?: SortOrder
    profileStrengthScore?: SortOrder
    completenessScore?: SortOrder
    specificityScore?: SortOrder
    consistencyScore?: SortOrder
    stabilityScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    height?: SortOrder
    profileStrengthScore?: SortOrder
    completenessScore?: SortOrder
    specificityScore?: SortOrder
    consistencyScore?: SortOrder
    stabilityScore?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    displayName?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    bio?: SortOrder
    height?: SortOrder
    relationshipIntent?: SortOrder
    profileStrengthScore?: SortOrder
    completenessScore?: SortOrder
    specificityScore?: SortOrder
    consistencyScore?: SortOrder
    stabilityScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    displayName?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    bio?: SortOrder
    height?: SortOrder
    relationshipIntent?: SortOrder
    profileStrengthScore?: SortOrder
    completenessScore?: SortOrder
    specificityScore?: SortOrder
    consistencyScore?: SortOrder
    stabilityScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    height?: SortOrder
    profileStrengthScore?: SortOrder
    completenessScore?: SortOrder
    specificityScore?: SortOrder
    consistencyScore?: SortOrder
    stabilityScore?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumRelationshipIntentNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipIntent | EnumRelationshipIntentFieldRefInput<$PrismaModel> | null
    in?: $Enums.RelationshipIntent[] | ListEnumRelationshipIntentFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RelationshipIntent[] | ListEnumRelationshipIntentFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRelationshipIntentNullableWithAggregatesFilter<$PrismaModel> | $Enums.RelationshipIntent | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRelationshipIntentNullableFilter<$PrismaModel>
    _max?: NestedEnumRelationshipIntentNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ProfileRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type PhotoCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    url?: SortOrder
    isMain?: SortOrder
    isVerified?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type PhotoAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type PhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    url?: SortOrder
    isMain?: SortOrder
    isVerified?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type PhotoMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    url?: SortOrder
    isMain?: SortOrder
    isVerified?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type PhotoSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ProfilePromptCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfilePromptAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ProfilePromptMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfilePromptMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfilePromptSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumQuestionCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionCategory | EnumQuestionCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionCategory[] | ListEnumQuestionCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionCategory[] | ListEnumQuestionCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionCategoryFilter<$PrismaModel> | $Enums.QuestionCategory
  }

  export type EnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type OnboardingQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    options?: SortOrder
    followUpLogic?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type OnboardingQuestionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type OnboardingQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type OnboardingQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type OnboardingQuestionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumQuestionCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionCategory | EnumQuestionCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionCategory[] | ListEnumQuestionCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionCategory[] | ListEnumQuestionCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionCategoryWithAggregatesFilter<$PrismaModel> | $Enums.QuestionCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionCategoryFilter<$PrismaModel>
    _max?: NestedEnumQuestionCategoryFilter<$PrismaModel>
  }

  export type EnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type OnboardingQuestionRelationFilter = {
    is?: OnboardingQuestionWhereInput
    isNot?: OnboardingQuestionWhereInput
  }

  export type OnboardingAnswerUserIdQuestionIdCompoundUniqueInput = {
    userId: string
    questionId: string
  }

  export type OnboardingAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    followUpCount?: SortOrder
    confidence?: SortOrder
    consistency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OnboardingAnswerAvgOrderByAggregateInput = {
    followUpCount?: SortOrder
    confidence?: SortOrder
    consistency?: SortOrder
  }

  export type OnboardingAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    followUpCount?: SortOrder
    confidence?: SortOrder
    consistency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OnboardingAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    followUpCount?: SortOrder
    confidence?: SortOrder
    consistency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OnboardingAnswerSumOrderByAggregateInput = {
    followUpCount?: SortOrder
    confidence?: SortOrder
    consistency?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type LikeFromUserIdToUserIdCompoundUniqueInput = {
    fromUserId: string
    toUserId: string
  }

  export type LikeCountOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMaxOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMinOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type MatchUserAIdUserBIdCompoundUniqueInput = {
    userAId: string
    userBId: string
  }

  export type MatchCountOrderByAggregateInput = {
    id?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
    overallScore?: SortOrder
    valuesScore?: SortOrder
    lifestyleScore?: SortOrder
    intentScore?: SortOrder
    communicationScore?: SortOrder
    logisticsScore?: SortOrder
    topReasons?: SortOrder
    frictionPoint?: SortOrder
    confidenceLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchAvgOrderByAggregateInput = {
    overallScore?: SortOrder
    valuesScore?: SortOrder
    lifestyleScore?: SortOrder
    intentScore?: SortOrder
    communicationScore?: SortOrder
    logisticsScore?: SortOrder
    confidenceLevel?: SortOrder
  }

  export type MatchMaxOrderByAggregateInput = {
    id?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
    overallScore?: SortOrder
    valuesScore?: SortOrder
    lifestyleScore?: SortOrder
    intentScore?: SortOrder
    communicationScore?: SortOrder
    logisticsScore?: SortOrder
    frictionPoint?: SortOrder
    confidenceLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchMinOrderByAggregateInput = {
    id?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
    overallScore?: SortOrder
    valuesScore?: SortOrder
    lifestyleScore?: SortOrder
    intentScore?: SortOrder
    communicationScore?: SortOrder
    logisticsScore?: SortOrder
    frictionPoint?: SortOrder
    confidenceLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchSumOrderByAggregateInput = {
    overallScore?: SortOrder
    valuesScore?: SortOrder
    lifestyleScore?: SortOrder
    intentScore?: SortOrder
    communicationScore?: SortOrder
    logisticsScore?: SortOrder
    confidenceLevel?: SortOrder
  }

  export type EnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type MatchRelationFilter = {
    is?: MatchWhereInput
    isNot?: MatchWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    safetyScore?: SortOrder
    safetyFlags?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    safetyScore?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    safetyScore?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    status?: SortOrder
    safetyScore?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    safetyScore?: SortOrder
  }

  export type EnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type TrustScoreCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    overallScore?: SortOrder
    replyPatternScore?: SortOrder
    commitmentScore?: SortOrder
    respectScore?: SortOrder
    toneConsistencyScore?: SortOrder
    lastCalculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrustScoreAvgOrderByAggregateInput = {
    overallScore?: SortOrder
    replyPatternScore?: SortOrder
    commitmentScore?: SortOrder
    respectScore?: SortOrder
    toneConsistencyScore?: SortOrder
  }

  export type TrustScoreMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    overallScore?: SortOrder
    replyPatternScore?: SortOrder
    commitmentScore?: SortOrder
    respectScore?: SortOrder
    toneConsistencyScore?: SortOrder
    lastCalculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrustScoreMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    overallScore?: SortOrder
    replyPatternScore?: SortOrder
    commitmentScore?: SortOrder
    respectScore?: SortOrder
    toneConsistencyScore?: SortOrder
    lastCalculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrustScoreSumOrderByAggregateInput = {
    overallScore?: SortOrder
    replyPatternScore?: SortOrder
    commitmentScore?: SortOrder
    respectScore?: SortOrder
    toneConsistencyScore?: SortOrder
  }

  export type EnumBehaviorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BehaviorType | EnumBehaviorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BehaviorType[] | ListEnumBehaviorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehaviorType[] | ListEnumBehaviorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBehaviorTypeFilter<$PrismaModel> | $Enums.BehaviorType
  }

  export type BehaviorLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    behaviorType?: SortOrder
    metadata?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
  }

  export type BehaviorLogAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type BehaviorLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    behaviorType?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
  }

  export type BehaviorLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    behaviorType?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
  }

  export type BehaviorLogSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type EnumBehaviorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BehaviorType | EnumBehaviorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BehaviorType[] | ListEnumBehaviorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehaviorType[] | ListEnumBehaviorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBehaviorTypeWithAggregatesFilter<$PrismaModel> | $Enums.BehaviorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBehaviorTypeFilter<$PrismaModel>
    _max?: NestedEnumBehaviorTypeFilter<$PrismaModel>
  }

  export type EnumRiskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelFilter<$PrismaModel> | $Enums.RiskLevel
  }

  export type RiskAssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    riskIndex?: SortOrder
    riskLevel?: SortOrder
    reportScore?: SortOrder
    messageRiskScore?: SortOrder
    patternRiskScore?: SortOrder
    isRestricted?: SortOrder
    restrictions?: SortOrder
    lastAssessedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskAssessmentAvgOrderByAggregateInput = {
    riskIndex?: SortOrder
    reportScore?: SortOrder
    messageRiskScore?: SortOrder
    patternRiskScore?: SortOrder
  }

  export type RiskAssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    riskIndex?: SortOrder
    riskLevel?: SortOrder
    reportScore?: SortOrder
    messageRiskScore?: SortOrder
    patternRiskScore?: SortOrder
    isRestricted?: SortOrder
    lastAssessedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskAssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    riskIndex?: SortOrder
    riskLevel?: SortOrder
    reportScore?: SortOrder
    messageRiskScore?: SortOrder
    patternRiskScore?: SortOrder
    isRestricted?: SortOrder
    lastAssessedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskAssessmentSumOrderByAggregateInput = {
    riskIndex?: SortOrder
    reportScore?: SortOrder
    messageRiskScore?: SortOrder
    patternRiskScore?: SortOrder
  }

  export type EnumRiskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel> | $Enums.RiskLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskLevelFilter<$PrismaModel>
    _max?: NestedEnumRiskLevelFilter<$PrismaModel>
  }

  export type EnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    evidence?: SortOrder
    status?: SortOrder
    reviewNotes?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    reviewNotes?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    reviewNotes?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type EnumSafetySignalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SafetySignalType | EnumSafetySignalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SafetySignalType[] | ListEnumSafetySignalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SafetySignalType[] | ListEnumSafetySignalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSafetySignalTypeFilter<$PrismaModel> | $Enums.SafetySignalType
  }

  export type SafetySignalUserIdSignalTypeCompoundUniqueInput = {
    userId: string
    signalType: $Enums.SafetySignalType
  }

  export type SafetySignalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    signalType?: SortOrder
    verifiedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SafetySignalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    signalType?: SortOrder
    verifiedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SafetySignalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    signalType?: SortOrder
    verifiedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSafetySignalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SafetySignalType | EnumSafetySignalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SafetySignalType[] | ListEnumSafetySignalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SafetySignalType[] | ListEnumSafetySignalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSafetySignalTypeWithAggregatesFilter<$PrismaModel> | $Enums.SafetySignalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSafetySignalTypeFilter<$PrismaModel>
    _max?: NestedEnumSafetySignalTypeFilter<$PrismaModel>
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    verificationData?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockBlockerIdBlockedUserIdCompoundUniqueInput = {
    blockerId: string
    blockedUserId: string
  }

  export type BlockCountOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedUserId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockMaxOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedUserId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockMinOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedUserId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRelationshipIntentFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipIntent | EnumRelationshipIntentFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipIntent[] | ListEnumRelationshipIntentFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipIntent[] | ListEnumRelationshipIntentFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipIntentFilter<$PrismaModel> | $Enums.RelationshipIntent
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntentHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    statedIntent?: SortOrder
    behaviorIntent?: SortOrder
    confidence?: SortOrder
    driftDetected?: SortOrder
    createdAt?: SortOrder
  }

  export type IntentHistoryAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type IntentHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    statedIntent?: SortOrder
    behaviorIntent?: SortOrder
    confidence?: SortOrder
    driftDetected?: SortOrder
    createdAt?: SortOrder
  }

  export type IntentHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    statedIntent?: SortOrder
    behaviorIntent?: SortOrder
    confidence?: SortOrder
    driftDetected?: SortOrder
    createdAt?: SortOrder
  }

  export type IntentHistorySumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type EnumRelationshipIntentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipIntent | EnumRelationshipIntentFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipIntent[] | ListEnumRelationshipIntentFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipIntent[] | ListEnumRelationshipIntentFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipIntentWithAggregatesFilter<$PrismaModel> | $Enums.RelationshipIntent
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationshipIntentFilter<$PrismaModel>
    _max?: NestedEnumRelationshipIntentFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ScheduledDateCountOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    schedulerId?: SortOrder
    partnerId?: SortOrder
    dateTime?: SortOrder
    location?: SortOrder
    isPublicPlace?: SortOrder
    safetyCheckIn?: SortOrder
    checkInTime?: SortOrder
    locationSharing?: SortOrder
    safetyScore?: SortOrder
    concerns?: SortOrder
    suggestions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledDateAvgOrderByAggregateInput = {
    safetyScore?: SortOrder
  }

  export type ScheduledDateMaxOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    schedulerId?: SortOrder
    partnerId?: SortOrder
    dateTime?: SortOrder
    location?: SortOrder
    isPublicPlace?: SortOrder
    safetyCheckIn?: SortOrder
    checkInTime?: SortOrder
    locationSharing?: SortOrder
    safetyScore?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledDateMinOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    schedulerId?: SortOrder
    partnerId?: SortOrder
    dateTime?: SortOrder
    location?: SortOrder
    isPublicPlace?: SortOrder
    safetyCheckIn?: SortOrder
    checkInTime?: SortOrder
    locationSharing?: SortOrder
    safetyScore?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledDateSumOrderByAggregateInput = {
    safetyScore?: SortOrder
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type OnboardingAnswerCreateNestedManyWithoutUserInput = {
    create?: XOR<OnboardingAnswerCreateWithoutUserInput, OnboardingAnswerUncheckedCreateWithoutUserInput> | OnboardingAnswerCreateWithoutUserInput[] | OnboardingAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OnboardingAnswerCreateOrConnectWithoutUserInput | OnboardingAnswerCreateOrConnectWithoutUserInput[]
    createMany?: OnboardingAnswerCreateManyUserInputEnvelope
    connect?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutFromUserInput = {
    create?: XOR<LikeCreateWithoutFromUserInput, LikeUncheckedCreateWithoutFromUserInput> | LikeCreateWithoutFromUserInput[] | LikeUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutFromUserInput | LikeCreateOrConnectWithoutFromUserInput[]
    createMany?: LikeCreateManyFromUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutToUserInput = {
    create?: XOR<LikeCreateWithoutToUserInput, LikeUncheckedCreateWithoutToUserInput> | LikeCreateWithoutToUserInput[] | LikeUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutToUserInput | LikeCreateOrConnectWithoutToUserInput[]
    createMany?: LikeCreateManyToUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type MatchCreateNestedManyWithoutUserAInput = {
    create?: XOR<MatchCreateWithoutUserAInput, MatchUncheckedCreateWithoutUserAInput> | MatchCreateWithoutUserAInput[] | MatchUncheckedCreateWithoutUserAInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutUserAInput | MatchCreateOrConnectWithoutUserAInput[]
    createMany?: MatchCreateManyUserAInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MatchCreateNestedManyWithoutUserBInput = {
    create?: XOR<MatchCreateWithoutUserBInput, MatchUncheckedCreateWithoutUserBInput> | MatchCreateWithoutUserBInput[] | MatchUncheckedCreateWithoutUserBInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutUserBInput | MatchCreateOrConnectWithoutUserBInput[]
    createMany?: MatchCreateManyUserBInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type TrustScoreCreateNestedOneWithoutUserInput = {
    create?: XOR<TrustScoreCreateWithoutUserInput, TrustScoreUncheckedCreateWithoutUserInput>
    connectOrCreate?: TrustScoreCreateOrConnectWithoutUserInput
    connect?: TrustScoreWhereUniqueInput
  }

  export type BehaviorLogCreateNestedManyWithoutUserInput = {
    create?: XOR<BehaviorLogCreateWithoutUserInput, BehaviorLogUncheckedCreateWithoutUserInput> | BehaviorLogCreateWithoutUserInput[] | BehaviorLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BehaviorLogCreateOrConnectWithoutUserInput | BehaviorLogCreateOrConnectWithoutUserInput[]
    createMany?: BehaviorLogCreateManyUserInputEnvelope
    connect?: BehaviorLogWhereUniqueInput | BehaviorLogWhereUniqueInput[]
  }

  export type RiskAssessmentCreateNestedOneWithoutUserInput = {
    create?: XOR<RiskAssessmentCreateWithoutUserInput, RiskAssessmentUncheckedCreateWithoutUserInput>
    connectOrCreate?: RiskAssessmentCreateOrConnectWithoutUserInput
    connect?: RiskAssessmentWhereUniqueInput
  }

  export type ReportCreateNestedManyWithoutReporterInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutReportedUserInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type SafetySignalCreateNestedManyWithoutUserInput = {
    create?: XOR<SafetySignalCreateWithoutUserInput, SafetySignalUncheckedCreateWithoutUserInput> | SafetySignalCreateWithoutUserInput[] | SafetySignalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SafetySignalCreateOrConnectWithoutUserInput | SafetySignalCreateOrConnectWithoutUserInput[]
    createMany?: SafetySignalCreateManyUserInputEnvelope
    connect?: SafetySignalWhereUniqueInput | SafetySignalWhereUniqueInput[]
  }

  export type VerificationCreateNestedManyWithoutUserInput = {
    create?: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput> | VerificationCreateWithoutUserInput[] | VerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCreateOrConnectWithoutUserInput | VerificationCreateOrConnectWithoutUserInput[]
    createMany?: VerificationCreateManyUserInputEnvelope
    connect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
  }

  export type IntentHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<IntentHistoryCreateWithoutUserInput, IntentHistoryUncheckedCreateWithoutUserInput> | IntentHistoryCreateWithoutUserInput[] | IntentHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntentHistoryCreateOrConnectWithoutUserInput | IntentHistoryCreateOrConnectWithoutUserInput[]
    createMany?: IntentHistoryCreateManyUserInputEnvelope
    connect?: IntentHistoryWhereUniqueInput | IntentHistoryWhereUniqueInput[]
  }

  export type BlockCreateNestedManyWithoutBlockerInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type BlockCreateNestedManyWithoutBlockedUserInput = {
    create?: XOR<BlockCreateWithoutBlockedUserInput, BlockUncheckedCreateWithoutBlockedUserInput> | BlockCreateWithoutBlockedUserInput[] | BlockUncheckedCreateWithoutBlockedUserInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedUserInput | BlockCreateOrConnectWithoutBlockedUserInput[]
    createMany?: BlockCreateManyBlockedUserInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type ScheduledDateCreateNestedManyWithoutSchedulerInput = {
    create?: XOR<ScheduledDateCreateWithoutSchedulerInput, ScheduledDateUncheckedCreateWithoutSchedulerInput> | ScheduledDateCreateWithoutSchedulerInput[] | ScheduledDateUncheckedCreateWithoutSchedulerInput[]
    connectOrCreate?: ScheduledDateCreateOrConnectWithoutSchedulerInput | ScheduledDateCreateOrConnectWithoutSchedulerInput[]
    createMany?: ScheduledDateCreateManySchedulerInputEnvelope
    connect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
  }

  export type ScheduledDateCreateNestedManyWithoutPartnerInput = {
    create?: XOR<ScheduledDateCreateWithoutPartnerInput, ScheduledDateUncheckedCreateWithoutPartnerInput> | ScheduledDateCreateWithoutPartnerInput[] | ScheduledDateUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: ScheduledDateCreateOrConnectWithoutPartnerInput | ScheduledDateCreateOrConnectWithoutPartnerInput[]
    createMany?: ScheduledDateCreateManyPartnerInputEnvelope
    connect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OnboardingAnswerCreateWithoutUserInput, OnboardingAnswerUncheckedCreateWithoutUserInput> | OnboardingAnswerCreateWithoutUserInput[] | OnboardingAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OnboardingAnswerCreateOrConnectWithoutUserInput | OnboardingAnswerCreateOrConnectWithoutUserInput[]
    createMany?: OnboardingAnswerCreateManyUserInputEnvelope
    connect?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutFromUserInput = {
    create?: XOR<LikeCreateWithoutFromUserInput, LikeUncheckedCreateWithoutFromUserInput> | LikeCreateWithoutFromUserInput[] | LikeUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutFromUserInput | LikeCreateOrConnectWithoutFromUserInput[]
    createMany?: LikeCreateManyFromUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutToUserInput = {
    create?: XOR<LikeCreateWithoutToUserInput, LikeUncheckedCreateWithoutToUserInput> | LikeCreateWithoutToUserInput[] | LikeUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutToUserInput | LikeCreateOrConnectWithoutToUserInput[]
    createMany?: LikeCreateManyToUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutUserAInput = {
    create?: XOR<MatchCreateWithoutUserAInput, MatchUncheckedCreateWithoutUserAInput> | MatchCreateWithoutUserAInput[] | MatchUncheckedCreateWithoutUserAInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutUserAInput | MatchCreateOrConnectWithoutUserAInput[]
    createMany?: MatchCreateManyUserAInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutUserBInput = {
    create?: XOR<MatchCreateWithoutUserBInput, MatchUncheckedCreateWithoutUserBInput> | MatchCreateWithoutUserBInput[] | MatchUncheckedCreateWithoutUserBInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutUserBInput | MatchCreateOrConnectWithoutUserBInput[]
    createMany?: MatchCreateManyUserBInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type TrustScoreUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TrustScoreCreateWithoutUserInput, TrustScoreUncheckedCreateWithoutUserInput>
    connectOrCreate?: TrustScoreCreateOrConnectWithoutUserInput
    connect?: TrustScoreWhereUniqueInput
  }

  export type BehaviorLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BehaviorLogCreateWithoutUserInput, BehaviorLogUncheckedCreateWithoutUserInput> | BehaviorLogCreateWithoutUserInput[] | BehaviorLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BehaviorLogCreateOrConnectWithoutUserInput | BehaviorLogCreateOrConnectWithoutUserInput[]
    createMany?: BehaviorLogCreateManyUserInputEnvelope
    connect?: BehaviorLogWhereUniqueInput | BehaviorLogWhereUniqueInput[]
  }

  export type RiskAssessmentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<RiskAssessmentCreateWithoutUserInput, RiskAssessmentUncheckedCreateWithoutUserInput>
    connectOrCreate?: RiskAssessmentCreateOrConnectWithoutUserInput
    connect?: RiskAssessmentWhereUniqueInput
  }

  export type ReportUncheckedCreateNestedManyWithoutReporterInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReportedUserInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type SafetySignalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SafetySignalCreateWithoutUserInput, SafetySignalUncheckedCreateWithoutUserInput> | SafetySignalCreateWithoutUserInput[] | SafetySignalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SafetySignalCreateOrConnectWithoutUserInput | SafetySignalCreateOrConnectWithoutUserInput[]
    createMany?: SafetySignalCreateManyUserInputEnvelope
    connect?: SafetySignalWhereUniqueInput | SafetySignalWhereUniqueInput[]
  }

  export type VerificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput> | VerificationCreateWithoutUserInput[] | VerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCreateOrConnectWithoutUserInput | VerificationCreateOrConnectWithoutUserInput[]
    createMany?: VerificationCreateManyUserInputEnvelope
    connect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
  }

  export type IntentHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IntentHistoryCreateWithoutUserInput, IntentHistoryUncheckedCreateWithoutUserInput> | IntentHistoryCreateWithoutUserInput[] | IntentHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntentHistoryCreateOrConnectWithoutUserInput | IntentHistoryCreateOrConnectWithoutUserInput[]
    createMany?: IntentHistoryCreateManyUserInputEnvelope
    connect?: IntentHistoryWhereUniqueInput | IntentHistoryWhereUniqueInput[]
  }

  export type BlockUncheckedCreateNestedManyWithoutBlockerInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type BlockUncheckedCreateNestedManyWithoutBlockedUserInput = {
    create?: XOR<BlockCreateWithoutBlockedUserInput, BlockUncheckedCreateWithoutBlockedUserInput> | BlockCreateWithoutBlockedUserInput[] | BlockUncheckedCreateWithoutBlockedUserInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedUserInput | BlockCreateOrConnectWithoutBlockedUserInput[]
    createMany?: BlockCreateManyBlockedUserInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput = {
    create?: XOR<ScheduledDateCreateWithoutSchedulerInput, ScheduledDateUncheckedCreateWithoutSchedulerInput> | ScheduledDateCreateWithoutSchedulerInput[] | ScheduledDateUncheckedCreateWithoutSchedulerInput[]
    connectOrCreate?: ScheduledDateCreateOrConnectWithoutSchedulerInput | ScheduledDateCreateOrConnectWithoutSchedulerInput[]
    createMany?: ScheduledDateCreateManySchedulerInputEnvelope
    connect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
  }

  export type ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<ScheduledDateCreateWithoutPartnerInput, ScheduledDateUncheckedCreateWithoutPartnerInput> | ScheduledDateCreateWithoutPartnerInput[] | ScheduledDateUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: ScheduledDateCreateOrConnectWithoutPartnerInput | ScheduledDateCreateOrConnectWithoutPartnerInput[]
    createMany?: ScheduledDateCreateManyPartnerInputEnvelope
    connect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type OnboardingAnswerUpdateManyWithoutUserNestedInput = {
    create?: XOR<OnboardingAnswerCreateWithoutUserInput, OnboardingAnswerUncheckedCreateWithoutUserInput> | OnboardingAnswerCreateWithoutUserInput[] | OnboardingAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OnboardingAnswerCreateOrConnectWithoutUserInput | OnboardingAnswerCreateOrConnectWithoutUserInput[]
    upsert?: OnboardingAnswerUpsertWithWhereUniqueWithoutUserInput | OnboardingAnswerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OnboardingAnswerCreateManyUserInputEnvelope
    set?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
    disconnect?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
    delete?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
    connect?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
    update?: OnboardingAnswerUpdateWithWhereUniqueWithoutUserInput | OnboardingAnswerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OnboardingAnswerUpdateManyWithWhereWithoutUserInput | OnboardingAnswerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OnboardingAnswerScalarWhereInput | OnboardingAnswerScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<LikeCreateWithoutFromUserInput, LikeUncheckedCreateWithoutFromUserInput> | LikeCreateWithoutFromUserInput[] | LikeUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutFromUserInput | LikeCreateOrConnectWithoutFromUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutFromUserInput | LikeUpsertWithWhereUniqueWithoutFromUserInput[]
    createMany?: LikeCreateManyFromUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutFromUserInput | LikeUpdateWithWhereUniqueWithoutFromUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutFromUserInput | LikeUpdateManyWithWhereWithoutFromUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutToUserNestedInput = {
    create?: XOR<LikeCreateWithoutToUserInput, LikeUncheckedCreateWithoutToUserInput> | LikeCreateWithoutToUserInput[] | LikeUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutToUserInput | LikeCreateOrConnectWithoutToUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutToUserInput | LikeUpsertWithWhereUniqueWithoutToUserInput[]
    createMany?: LikeCreateManyToUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutToUserInput | LikeUpdateWithWhereUniqueWithoutToUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutToUserInput | LikeUpdateManyWithWhereWithoutToUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type MatchUpdateManyWithoutUserANestedInput = {
    create?: XOR<MatchCreateWithoutUserAInput, MatchUncheckedCreateWithoutUserAInput> | MatchCreateWithoutUserAInput[] | MatchUncheckedCreateWithoutUserAInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutUserAInput | MatchCreateOrConnectWithoutUserAInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutUserAInput | MatchUpsertWithWhereUniqueWithoutUserAInput[]
    createMany?: MatchCreateManyUserAInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutUserAInput | MatchUpdateWithWhereUniqueWithoutUserAInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutUserAInput | MatchUpdateManyWithWhereWithoutUserAInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type MatchUpdateManyWithoutUserBNestedInput = {
    create?: XOR<MatchCreateWithoutUserBInput, MatchUncheckedCreateWithoutUserBInput> | MatchCreateWithoutUserBInput[] | MatchUncheckedCreateWithoutUserBInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutUserBInput | MatchCreateOrConnectWithoutUserBInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutUserBInput | MatchUpsertWithWhereUniqueWithoutUserBInput[]
    createMany?: MatchCreateManyUserBInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutUserBInput | MatchUpdateWithWhereUniqueWithoutUserBInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutUserBInput | MatchUpdateManyWithWhereWithoutUserBInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TrustScoreUpdateOneWithoutUserNestedInput = {
    create?: XOR<TrustScoreCreateWithoutUserInput, TrustScoreUncheckedCreateWithoutUserInput>
    connectOrCreate?: TrustScoreCreateOrConnectWithoutUserInput
    upsert?: TrustScoreUpsertWithoutUserInput
    disconnect?: TrustScoreWhereInput | boolean
    delete?: TrustScoreWhereInput | boolean
    connect?: TrustScoreWhereUniqueInput
    update?: XOR<XOR<TrustScoreUpdateToOneWithWhereWithoutUserInput, TrustScoreUpdateWithoutUserInput>, TrustScoreUncheckedUpdateWithoutUserInput>
  }

  export type BehaviorLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<BehaviorLogCreateWithoutUserInput, BehaviorLogUncheckedCreateWithoutUserInput> | BehaviorLogCreateWithoutUserInput[] | BehaviorLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BehaviorLogCreateOrConnectWithoutUserInput | BehaviorLogCreateOrConnectWithoutUserInput[]
    upsert?: BehaviorLogUpsertWithWhereUniqueWithoutUserInput | BehaviorLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BehaviorLogCreateManyUserInputEnvelope
    set?: BehaviorLogWhereUniqueInput | BehaviorLogWhereUniqueInput[]
    disconnect?: BehaviorLogWhereUniqueInput | BehaviorLogWhereUniqueInput[]
    delete?: BehaviorLogWhereUniqueInput | BehaviorLogWhereUniqueInput[]
    connect?: BehaviorLogWhereUniqueInput | BehaviorLogWhereUniqueInput[]
    update?: BehaviorLogUpdateWithWhereUniqueWithoutUserInput | BehaviorLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BehaviorLogUpdateManyWithWhereWithoutUserInput | BehaviorLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BehaviorLogScalarWhereInput | BehaviorLogScalarWhereInput[]
  }

  export type RiskAssessmentUpdateOneWithoutUserNestedInput = {
    create?: XOR<RiskAssessmentCreateWithoutUserInput, RiskAssessmentUncheckedCreateWithoutUserInput>
    connectOrCreate?: RiskAssessmentCreateOrConnectWithoutUserInput
    upsert?: RiskAssessmentUpsertWithoutUserInput
    disconnect?: RiskAssessmentWhereInput | boolean
    delete?: RiskAssessmentWhereInput | boolean
    connect?: RiskAssessmentWhereUniqueInput
    update?: XOR<XOR<RiskAssessmentUpdateToOneWithWhereWithoutUserInput, RiskAssessmentUpdateWithoutUserInput>, RiskAssessmentUncheckedUpdateWithoutUserInput>
  }

  export type ReportUpdateManyWithoutReporterNestedInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReporterInput | ReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReporterInput | ReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReporterInput | ReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutReportedUserNestedInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedUserInput | ReportUpsertWithWhereUniqueWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedUserInput | ReportUpdateWithWhereUniqueWithoutReportedUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedUserInput | ReportUpdateManyWithWhereWithoutReportedUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type SafetySignalUpdateManyWithoutUserNestedInput = {
    create?: XOR<SafetySignalCreateWithoutUserInput, SafetySignalUncheckedCreateWithoutUserInput> | SafetySignalCreateWithoutUserInput[] | SafetySignalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SafetySignalCreateOrConnectWithoutUserInput | SafetySignalCreateOrConnectWithoutUserInput[]
    upsert?: SafetySignalUpsertWithWhereUniqueWithoutUserInput | SafetySignalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SafetySignalCreateManyUserInputEnvelope
    set?: SafetySignalWhereUniqueInput | SafetySignalWhereUniqueInput[]
    disconnect?: SafetySignalWhereUniqueInput | SafetySignalWhereUniqueInput[]
    delete?: SafetySignalWhereUniqueInput | SafetySignalWhereUniqueInput[]
    connect?: SafetySignalWhereUniqueInput | SafetySignalWhereUniqueInput[]
    update?: SafetySignalUpdateWithWhereUniqueWithoutUserInput | SafetySignalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SafetySignalUpdateManyWithWhereWithoutUserInput | SafetySignalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SafetySignalScalarWhereInput | SafetySignalScalarWhereInput[]
  }

  export type VerificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput> | VerificationCreateWithoutUserInput[] | VerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCreateOrConnectWithoutUserInput | VerificationCreateOrConnectWithoutUserInput[]
    upsert?: VerificationUpsertWithWhereUniqueWithoutUserInput | VerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VerificationCreateManyUserInputEnvelope
    set?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    disconnect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    delete?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    connect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    update?: VerificationUpdateWithWhereUniqueWithoutUserInput | VerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VerificationUpdateManyWithWhereWithoutUserInput | VerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VerificationScalarWhereInput | VerificationScalarWhereInput[]
  }

  export type IntentHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<IntentHistoryCreateWithoutUserInput, IntentHistoryUncheckedCreateWithoutUserInput> | IntentHistoryCreateWithoutUserInput[] | IntentHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntentHistoryCreateOrConnectWithoutUserInput | IntentHistoryCreateOrConnectWithoutUserInput[]
    upsert?: IntentHistoryUpsertWithWhereUniqueWithoutUserInput | IntentHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IntentHistoryCreateManyUserInputEnvelope
    set?: IntentHistoryWhereUniqueInput | IntentHistoryWhereUniqueInput[]
    disconnect?: IntentHistoryWhereUniqueInput | IntentHistoryWhereUniqueInput[]
    delete?: IntentHistoryWhereUniqueInput | IntentHistoryWhereUniqueInput[]
    connect?: IntentHistoryWhereUniqueInput | IntentHistoryWhereUniqueInput[]
    update?: IntentHistoryUpdateWithWhereUniqueWithoutUserInput | IntentHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IntentHistoryUpdateManyWithWhereWithoutUserInput | IntentHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IntentHistoryScalarWhereInput | IntentHistoryScalarWhereInput[]
  }

  export type BlockUpdateManyWithoutBlockerNestedInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockerInput | BlockUpsertWithWhereUniqueWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockerInput | BlockUpdateWithWhereUniqueWithoutBlockerInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockerInput | BlockUpdateManyWithWhereWithoutBlockerInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type BlockUpdateManyWithoutBlockedUserNestedInput = {
    create?: XOR<BlockCreateWithoutBlockedUserInput, BlockUncheckedCreateWithoutBlockedUserInput> | BlockCreateWithoutBlockedUserInput[] | BlockUncheckedCreateWithoutBlockedUserInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedUserInput | BlockCreateOrConnectWithoutBlockedUserInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockedUserInput | BlockUpsertWithWhereUniqueWithoutBlockedUserInput[]
    createMany?: BlockCreateManyBlockedUserInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockedUserInput | BlockUpdateWithWhereUniqueWithoutBlockedUserInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockedUserInput | BlockUpdateManyWithWhereWithoutBlockedUserInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type ScheduledDateUpdateManyWithoutSchedulerNestedInput = {
    create?: XOR<ScheduledDateCreateWithoutSchedulerInput, ScheduledDateUncheckedCreateWithoutSchedulerInput> | ScheduledDateCreateWithoutSchedulerInput[] | ScheduledDateUncheckedCreateWithoutSchedulerInput[]
    connectOrCreate?: ScheduledDateCreateOrConnectWithoutSchedulerInput | ScheduledDateCreateOrConnectWithoutSchedulerInput[]
    upsert?: ScheduledDateUpsertWithWhereUniqueWithoutSchedulerInput | ScheduledDateUpsertWithWhereUniqueWithoutSchedulerInput[]
    createMany?: ScheduledDateCreateManySchedulerInputEnvelope
    set?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    disconnect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    delete?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    connect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    update?: ScheduledDateUpdateWithWhereUniqueWithoutSchedulerInput | ScheduledDateUpdateWithWhereUniqueWithoutSchedulerInput[]
    updateMany?: ScheduledDateUpdateManyWithWhereWithoutSchedulerInput | ScheduledDateUpdateManyWithWhereWithoutSchedulerInput[]
    deleteMany?: ScheduledDateScalarWhereInput | ScheduledDateScalarWhereInput[]
  }

  export type ScheduledDateUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<ScheduledDateCreateWithoutPartnerInput, ScheduledDateUncheckedCreateWithoutPartnerInput> | ScheduledDateCreateWithoutPartnerInput[] | ScheduledDateUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: ScheduledDateCreateOrConnectWithoutPartnerInput | ScheduledDateCreateOrConnectWithoutPartnerInput[]
    upsert?: ScheduledDateUpsertWithWhereUniqueWithoutPartnerInput | ScheduledDateUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: ScheduledDateCreateManyPartnerInputEnvelope
    set?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    disconnect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    delete?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    connect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    update?: ScheduledDateUpdateWithWhereUniqueWithoutPartnerInput | ScheduledDateUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: ScheduledDateUpdateManyWithWhereWithoutPartnerInput | ScheduledDateUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: ScheduledDateScalarWhereInput | ScheduledDateScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OnboardingAnswerCreateWithoutUserInput, OnboardingAnswerUncheckedCreateWithoutUserInput> | OnboardingAnswerCreateWithoutUserInput[] | OnboardingAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OnboardingAnswerCreateOrConnectWithoutUserInput | OnboardingAnswerCreateOrConnectWithoutUserInput[]
    upsert?: OnboardingAnswerUpsertWithWhereUniqueWithoutUserInput | OnboardingAnswerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OnboardingAnswerCreateManyUserInputEnvelope
    set?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
    disconnect?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
    delete?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
    connect?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
    update?: OnboardingAnswerUpdateWithWhereUniqueWithoutUserInput | OnboardingAnswerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OnboardingAnswerUpdateManyWithWhereWithoutUserInput | OnboardingAnswerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OnboardingAnswerScalarWhereInput | OnboardingAnswerScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<LikeCreateWithoutFromUserInput, LikeUncheckedCreateWithoutFromUserInput> | LikeCreateWithoutFromUserInput[] | LikeUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutFromUserInput | LikeCreateOrConnectWithoutFromUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutFromUserInput | LikeUpsertWithWhereUniqueWithoutFromUserInput[]
    createMany?: LikeCreateManyFromUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutFromUserInput | LikeUpdateWithWhereUniqueWithoutFromUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutFromUserInput | LikeUpdateManyWithWhereWithoutFromUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutToUserNestedInput = {
    create?: XOR<LikeCreateWithoutToUserInput, LikeUncheckedCreateWithoutToUserInput> | LikeCreateWithoutToUserInput[] | LikeUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutToUserInput | LikeCreateOrConnectWithoutToUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutToUserInput | LikeUpsertWithWhereUniqueWithoutToUserInput[]
    createMany?: LikeCreateManyToUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutToUserInput | LikeUpdateWithWhereUniqueWithoutToUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutToUserInput | LikeUpdateManyWithWhereWithoutToUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutUserANestedInput = {
    create?: XOR<MatchCreateWithoutUserAInput, MatchUncheckedCreateWithoutUserAInput> | MatchCreateWithoutUserAInput[] | MatchUncheckedCreateWithoutUserAInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutUserAInput | MatchCreateOrConnectWithoutUserAInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutUserAInput | MatchUpsertWithWhereUniqueWithoutUserAInput[]
    createMany?: MatchCreateManyUserAInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutUserAInput | MatchUpdateWithWhereUniqueWithoutUserAInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutUserAInput | MatchUpdateManyWithWhereWithoutUserAInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutUserBNestedInput = {
    create?: XOR<MatchCreateWithoutUserBInput, MatchUncheckedCreateWithoutUserBInput> | MatchCreateWithoutUserBInput[] | MatchUncheckedCreateWithoutUserBInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutUserBInput | MatchCreateOrConnectWithoutUserBInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutUserBInput | MatchUpsertWithWhereUniqueWithoutUserBInput[]
    createMany?: MatchCreateManyUserBInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutUserBInput | MatchUpdateWithWhereUniqueWithoutUserBInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutUserBInput | MatchUpdateManyWithWhereWithoutUserBInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TrustScoreUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TrustScoreCreateWithoutUserInput, TrustScoreUncheckedCreateWithoutUserInput>
    connectOrCreate?: TrustScoreCreateOrConnectWithoutUserInput
    upsert?: TrustScoreUpsertWithoutUserInput
    disconnect?: TrustScoreWhereInput | boolean
    delete?: TrustScoreWhereInput | boolean
    connect?: TrustScoreWhereUniqueInput
    update?: XOR<XOR<TrustScoreUpdateToOneWithWhereWithoutUserInput, TrustScoreUpdateWithoutUserInput>, TrustScoreUncheckedUpdateWithoutUserInput>
  }

  export type BehaviorLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BehaviorLogCreateWithoutUserInput, BehaviorLogUncheckedCreateWithoutUserInput> | BehaviorLogCreateWithoutUserInput[] | BehaviorLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BehaviorLogCreateOrConnectWithoutUserInput | BehaviorLogCreateOrConnectWithoutUserInput[]
    upsert?: BehaviorLogUpsertWithWhereUniqueWithoutUserInput | BehaviorLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BehaviorLogCreateManyUserInputEnvelope
    set?: BehaviorLogWhereUniqueInput | BehaviorLogWhereUniqueInput[]
    disconnect?: BehaviorLogWhereUniqueInput | BehaviorLogWhereUniqueInput[]
    delete?: BehaviorLogWhereUniqueInput | BehaviorLogWhereUniqueInput[]
    connect?: BehaviorLogWhereUniqueInput | BehaviorLogWhereUniqueInput[]
    update?: BehaviorLogUpdateWithWhereUniqueWithoutUserInput | BehaviorLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BehaviorLogUpdateManyWithWhereWithoutUserInput | BehaviorLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BehaviorLogScalarWhereInput | BehaviorLogScalarWhereInput[]
  }

  export type RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<RiskAssessmentCreateWithoutUserInput, RiskAssessmentUncheckedCreateWithoutUserInput>
    connectOrCreate?: RiskAssessmentCreateOrConnectWithoutUserInput
    upsert?: RiskAssessmentUpsertWithoutUserInput
    disconnect?: RiskAssessmentWhereInput | boolean
    delete?: RiskAssessmentWhereInput | boolean
    connect?: RiskAssessmentWhereUniqueInput
    update?: XOR<XOR<RiskAssessmentUpdateToOneWithWhereWithoutUserInput, RiskAssessmentUpdateWithoutUserInput>, RiskAssessmentUncheckedUpdateWithoutUserInput>
  }

  export type ReportUncheckedUpdateManyWithoutReporterNestedInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReporterInput | ReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReporterInput | ReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReporterInput | ReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReportedUserNestedInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedUserInput | ReportUpsertWithWhereUniqueWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedUserInput | ReportUpdateWithWhereUniqueWithoutReportedUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedUserInput | ReportUpdateManyWithWhereWithoutReportedUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type SafetySignalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SafetySignalCreateWithoutUserInput, SafetySignalUncheckedCreateWithoutUserInput> | SafetySignalCreateWithoutUserInput[] | SafetySignalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SafetySignalCreateOrConnectWithoutUserInput | SafetySignalCreateOrConnectWithoutUserInput[]
    upsert?: SafetySignalUpsertWithWhereUniqueWithoutUserInput | SafetySignalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SafetySignalCreateManyUserInputEnvelope
    set?: SafetySignalWhereUniqueInput | SafetySignalWhereUniqueInput[]
    disconnect?: SafetySignalWhereUniqueInput | SafetySignalWhereUniqueInput[]
    delete?: SafetySignalWhereUniqueInput | SafetySignalWhereUniqueInput[]
    connect?: SafetySignalWhereUniqueInput | SafetySignalWhereUniqueInput[]
    update?: SafetySignalUpdateWithWhereUniqueWithoutUserInput | SafetySignalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SafetySignalUpdateManyWithWhereWithoutUserInput | SafetySignalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SafetySignalScalarWhereInput | SafetySignalScalarWhereInput[]
  }

  export type VerificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput> | VerificationCreateWithoutUserInput[] | VerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCreateOrConnectWithoutUserInput | VerificationCreateOrConnectWithoutUserInput[]
    upsert?: VerificationUpsertWithWhereUniqueWithoutUserInput | VerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VerificationCreateManyUserInputEnvelope
    set?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    disconnect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    delete?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    connect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    update?: VerificationUpdateWithWhereUniqueWithoutUserInput | VerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VerificationUpdateManyWithWhereWithoutUserInput | VerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VerificationScalarWhereInput | VerificationScalarWhereInput[]
  }

  export type IntentHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IntentHistoryCreateWithoutUserInput, IntentHistoryUncheckedCreateWithoutUserInput> | IntentHistoryCreateWithoutUserInput[] | IntentHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntentHistoryCreateOrConnectWithoutUserInput | IntentHistoryCreateOrConnectWithoutUserInput[]
    upsert?: IntentHistoryUpsertWithWhereUniqueWithoutUserInput | IntentHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IntentHistoryCreateManyUserInputEnvelope
    set?: IntentHistoryWhereUniqueInput | IntentHistoryWhereUniqueInput[]
    disconnect?: IntentHistoryWhereUniqueInput | IntentHistoryWhereUniqueInput[]
    delete?: IntentHistoryWhereUniqueInput | IntentHistoryWhereUniqueInput[]
    connect?: IntentHistoryWhereUniqueInput | IntentHistoryWhereUniqueInput[]
    update?: IntentHistoryUpdateWithWhereUniqueWithoutUserInput | IntentHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IntentHistoryUpdateManyWithWhereWithoutUserInput | IntentHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IntentHistoryScalarWhereInput | IntentHistoryScalarWhereInput[]
  }

  export type BlockUncheckedUpdateManyWithoutBlockerNestedInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockerInput | BlockUpsertWithWhereUniqueWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockerInput | BlockUpdateWithWhereUniqueWithoutBlockerInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockerInput | BlockUpdateManyWithWhereWithoutBlockerInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type BlockUncheckedUpdateManyWithoutBlockedUserNestedInput = {
    create?: XOR<BlockCreateWithoutBlockedUserInput, BlockUncheckedCreateWithoutBlockedUserInput> | BlockCreateWithoutBlockedUserInput[] | BlockUncheckedCreateWithoutBlockedUserInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedUserInput | BlockCreateOrConnectWithoutBlockedUserInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockedUserInput | BlockUpsertWithWhereUniqueWithoutBlockedUserInput[]
    createMany?: BlockCreateManyBlockedUserInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockedUserInput | BlockUpdateWithWhereUniqueWithoutBlockedUserInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockedUserInput | BlockUpdateManyWithWhereWithoutBlockedUserInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput = {
    create?: XOR<ScheduledDateCreateWithoutSchedulerInput, ScheduledDateUncheckedCreateWithoutSchedulerInput> | ScheduledDateCreateWithoutSchedulerInput[] | ScheduledDateUncheckedCreateWithoutSchedulerInput[]
    connectOrCreate?: ScheduledDateCreateOrConnectWithoutSchedulerInput | ScheduledDateCreateOrConnectWithoutSchedulerInput[]
    upsert?: ScheduledDateUpsertWithWhereUniqueWithoutSchedulerInput | ScheduledDateUpsertWithWhereUniqueWithoutSchedulerInput[]
    createMany?: ScheduledDateCreateManySchedulerInputEnvelope
    set?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    disconnect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    delete?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    connect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    update?: ScheduledDateUpdateWithWhereUniqueWithoutSchedulerInput | ScheduledDateUpdateWithWhereUniqueWithoutSchedulerInput[]
    updateMany?: ScheduledDateUpdateManyWithWhereWithoutSchedulerInput | ScheduledDateUpdateManyWithWhereWithoutSchedulerInput[]
    deleteMany?: ScheduledDateScalarWhereInput | ScheduledDateScalarWhereInput[]
  }

  export type ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<ScheduledDateCreateWithoutPartnerInput, ScheduledDateUncheckedCreateWithoutPartnerInput> | ScheduledDateCreateWithoutPartnerInput[] | ScheduledDateUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: ScheduledDateCreateOrConnectWithoutPartnerInput | ScheduledDateCreateOrConnectWithoutPartnerInput[]
    upsert?: ScheduledDateUpsertWithWhereUniqueWithoutPartnerInput | ScheduledDateUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: ScheduledDateCreateManyPartnerInputEnvelope
    set?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    disconnect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    delete?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    connect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    update?: ScheduledDateUpdateWithWhereUniqueWithoutPartnerInput | ScheduledDateUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: ScheduledDateUpdateManyWithWhereWithoutPartnerInput | ScheduledDateUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: ScheduledDateScalarWhereInput | ScheduledDateScalarWhereInput[]
  }

  export type ProfileCreategenderPreferencesInput = {
    set: $Enums.Gender[]
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type PhotoCreateNestedManyWithoutProfileInput = {
    create?: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput> | PhotoCreateWithoutProfileInput[] | PhotoUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutProfileInput | PhotoCreateOrConnectWithoutProfileInput[]
    createMany?: PhotoCreateManyProfileInputEnvelope
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
  }

  export type ProfilePromptCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfilePromptCreateWithoutProfileInput, ProfilePromptUncheckedCreateWithoutProfileInput> | ProfilePromptCreateWithoutProfileInput[] | ProfilePromptUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfilePromptCreateOrConnectWithoutProfileInput | ProfilePromptCreateOrConnectWithoutProfileInput[]
    createMany?: ProfilePromptCreateManyProfileInputEnvelope
    connect?: ProfilePromptWhereUniqueInput | ProfilePromptWhereUniqueInput[]
  }

  export type PhotoUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput> | PhotoCreateWithoutProfileInput[] | PhotoUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutProfileInput | PhotoCreateOrConnectWithoutProfileInput[]
    createMany?: PhotoCreateManyProfileInputEnvelope
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
  }

  export type ProfilePromptUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfilePromptCreateWithoutProfileInput, ProfilePromptUncheckedCreateWithoutProfileInput> | ProfilePromptCreateWithoutProfileInput[] | ProfilePromptUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfilePromptCreateOrConnectWithoutProfileInput | ProfilePromptCreateOrConnectWithoutProfileInput[]
    createMany?: ProfilePromptCreateManyProfileInputEnvelope
    connect?: ProfilePromptWhereUniqueInput | ProfilePromptWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type ProfileUpdategenderPreferencesInput = {
    set?: $Enums.Gender[]
    push?: $Enums.Gender | $Enums.Gender[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumRelationshipIntentFieldUpdateOperationsInput = {
    set?: $Enums.RelationshipIntent | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type PhotoUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput> | PhotoCreateWithoutProfileInput[] | PhotoUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutProfileInput | PhotoCreateOrConnectWithoutProfileInput[]
    upsert?: PhotoUpsertWithWhereUniqueWithoutProfileInput | PhotoUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PhotoCreateManyProfileInputEnvelope
    set?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    disconnect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    delete?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    update?: PhotoUpdateWithWhereUniqueWithoutProfileInput | PhotoUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PhotoUpdateManyWithWhereWithoutProfileInput | PhotoUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
  }

  export type ProfilePromptUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfilePromptCreateWithoutProfileInput, ProfilePromptUncheckedCreateWithoutProfileInput> | ProfilePromptCreateWithoutProfileInput[] | ProfilePromptUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfilePromptCreateOrConnectWithoutProfileInput | ProfilePromptCreateOrConnectWithoutProfileInput[]
    upsert?: ProfilePromptUpsertWithWhereUniqueWithoutProfileInput | ProfilePromptUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfilePromptCreateManyProfileInputEnvelope
    set?: ProfilePromptWhereUniqueInput | ProfilePromptWhereUniqueInput[]
    disconnect?: ProfilePromptWhereUniqueInput | ProfilePromptWhereUniqueInput[]
    delete?: ProfilePromptWhereUniqueInput | ProfilePromptWhereUniqueInput[]
    connect?: ProfilePromptWhereUniqueInput | ProfilePromptWhereUniqueInput[]
    update?: ProfilePromptUpdateWithWhereUniqueWithoutProfileInput | ProfilePromptUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfilePromptUpdateManyWithWhereWithoutProfileInput | ProfilePromptUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfilePromptScalarWhereInput | ProfilePromptScalarWhereInput[]
  }

  export type PhotoUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput> | PhotoCreateWithoutProfileInput[] | PhotoUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutProfileInput | PhotoCreateOrConnectWithoutProfileInput[]
    upsert?: PhotoUpsertWithWhereUniqueWithoutProfileInput | PhotoUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PhotoCreateManyProfileInputEnvelope
    set?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    disconnect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    delete?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    update?: PhotoUpdateWithWhereUniqueWithoutProfileInput | PhotoUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PhotoUpdateManyWithWhereWithoutProfileInput | PhotoUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
  }

  export type ProfilePromptUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfilePromptCreateWithoutProfileInput, ProfilePromptUncheckedCreateWithoutProfileInput> | ProfilePromptCreateWithoutProfileInput[] | ProfilePromptUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfilePromptCreateOrConnectWithoutProfileInput | ProfilePromptCreateOrConnectWithoutProfileInput[]
    upsert?: ProfilePromptUpsertWithWhereUniqueWithoutProfileInput | ProfilePromptUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfilePromptCreateManyProfileInputEnvelope
    set?: ProfilePromptWhereUniqueInput | ProfilePromptWhereUniqueInput[]
    disconnect?: ProfilePromptWhereUniqueInput | ProfilePromptWhereUniqueInput[]
    delete?: ProfilePromptWhereUniqueInput | ProfilePromptWhereUniqueInput[]
    connect?: ProfilePromptWhereUniqueInput | ProfilePromptWhereUniqueInput[]
    update?: ProfilePromptUpdateWithWhereUniqueWithoutProfileInput | ProfilePromptUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfilePromptUpdateManyWithWhereWithoutProfileInput | ProfilePromptUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfilePromptScalarWhereInput | ProfilePromptScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutPhotosInput = {
    create?: XOR<ProfileCreateWithoutPhotosInput, ProfileUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPhotosInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<ProfileCreateWithoutPhotosInput, ProfileUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPhotosInput
    upsert?: ProfileUpsertWithoutPhotosInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutPhotosInput, ProfileUpdateWithoutPhotosInput>, ProfileUncheckedUpdateWithoutPhotosInput>
  }

  export type ProfileCreateNestedOneWithoutPromptsInput = {
    create?: XOR<ProfileCreateWithoutPromptsInput, ProfileUncheckedCreateWithoutPromptsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPromptsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutPromptsNestedInput = {
    create?: XOR<ProfileCreateWithoutPromptsInput, ProfileUncheckedCreateWithoutPromptsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPromptsInput
    upsert?: ProfileUpsertWithoutPromptsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutPromptsInput, ProfileUpdateWithoutPromptsInput>, ProfileUncheckedUpdateWithoutPromptsInput>
  }

  export type OnboardingAnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<OnboardingAnswerCreateWithoutQuestionInput, OnboardingAnswerUncheckedCreateWithoutQuestionInput> | OnboardingAnswerCreateWithoutQuestionInput[] | OnboardingAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: OnboardingAnswerCreateOrConnectWithoutQuestionInput | OnboardingAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: OnboardingAnswerCreateManyQuestionInputEnvelope
    connect?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
  }

  export type OnboardingAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<OnboardingAnswerCreateWithoutQuestionInput, OnboardingAnswerUncheckedCreateWithoutQuestionInput> | OnboardingAnswerCreateWithoutQuestionInput[] | OnboardingAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: OnboardingAnswerCreateOrConnectWithoutQuestionInput | OnboardingAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: OnboardingAnswerCreateManyQuestionInputEnvelope
    connect?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
  }

  export type EnumQuestionCategoryFieldUpdateOperationsInput = {
    set?: $Enums.QuestionCategory
  }

  export type EnumQuestionTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuestionType
  }

  export type OnboardingAnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<OnboardingAnswerCreateWithoutQuestionInput, OnboardingAnswerUncheckedCreateWithoutQuestionInput> | OnboardingAnswerCreateWithoutQuestionInput[] | OnboardingAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: OnboardingAnswerCreateOrConnectWithoutQuestionInput | OnboardingAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: OnboardingAnswerUpsertWithWhereUniqueWithoutQuestionInput | OnboardingAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: OnboardingAnswerCreateManyQuestionInputEnvelope
    set?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
    disconnect?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
    delete?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
    connect?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
    update?: OnboardingAnswerUpdateWithWhereUniqueWithoutQuestionInput | OnboardingAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: OnboardingAnswerUpdateManyWithWhereWithoutQuestionInput | OnboardingAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: OnboardingAnswerScalarWhereInput | OnboardingAnswerScalarWhereInput[]
  }

  export type OnboardingAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<OnboardingAnswerCreateWithoutQuestionInput, OnboardingAnswerUncheckedCreateWithoutQuestionInput> | OnboardingAnswerCreateWithoutQuestionInput[] | OnboardingAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: OnboardingAnswerCreateOrConnectWithoutQuestionInput | OnboardingAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: OnboardingAnswerUpsertWithWhereUniqueWithoutQuestionInput | OnboardingAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: OnboardingAnswerCreateManyQuestionInputEnvelope
    set?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
    disconnect?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
    delete?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
    connect?: OnboardingAnswerWhereUniqueInput | OnboardingAnswerWhereUniqueInput[]
    update?: OnboardingAnswerUpdateWithWhereUniqueWithoutQuestionInput | OnboardingAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: OnboardingAnswerUpdateManyWithWhereWithoutQuestionInput | OnboardingAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: OnboardingAnswerScalarWhereInput | OnboardingAnswerScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOnboardingAnswersInput = {
    create?: XOR<UserCreateWithoutOnboardingAnswersInput, UserUncheckedCreateWithoutOnboardingAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOnboardingAnswersInput
    connect?: UserWhereUniqueInput
  }

  export type OnboardingQuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<OnboardingQuestionCreateWithoutAnswersInput, OnboardingQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: OnboardingQuestionCreateOrConnectWithoutAnswersInput
    connect?: OnboardingQuestionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOnboardingAnswersNestedInput = {
    create?: XOR<UserCreateWithoutOnboardingAnswersInput, UserUncheckedCreateWithoutOnboardingAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOnboardingAnswersInput
    upsert?: UserUpsertWithoutOnboardingAnswersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOnboardingAnswersInput, UserUpdateWithoutOnboardingAnswersInput>, UserUncheckedUpdateWithoutOnboardingAnswersInput>
  }

  export type OnboardingQuestionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<OnboardingQuestionCreateWithoutAnswersInput, OnboardingQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: OnboardingQuestionCreateOrConnectWithoutAnswersInput
    upsert?: OnboardingQuestionUpsertWithoutAnswersInput
    connect?: OnboardingQuestionWhereUniqueInput
    update?: XOR<XOR<OnboardingQuestionUpdateToOneWithWhereWithoutAnswersInput, OnboardingQuestionUpdateWithoutAnswersInput>, OnboardingQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type UserCreateNestedOneWithoutLikesGivenInput = {
    create?: XOR<UserCreateWithoutLikesGivenInput, UserUncheckedCreateWithoutLikesGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesGivenInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLikesReceivedInput = {
    create?: XOR<UserCreateWithoutLikesReceivedInput, UserUncheckedCreateWithoutLikesReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLikesGivenNestedInput = {
    create?: XOR<UserCreateWithoutLikesGivenInput, UserUncheckedCreateWithoutLikesGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesGivenInput
    upsert?: UserUpsertWithoutLikesGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikesGivenInput, UserUpdateWithoutLikesGivenInput>, UserUncheckedUpdateWithoutLikesGivenInput>
  }

  export type UserUpdateOneRequiredWithoutLikesReceivedNestedInput = {
    create?: XOR<UserCreateWithoutLikesReceivedInput, UserUncheckedCreateWithoutLikesReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesReceivedInput
    upsert?: UserUpsertWithoutLikesReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikesReceivedInput, UserUpdateWithoutLikesReceivedInput>, UserUncheckedUpdateWithoutLikesReceivedInput>
  }

  export type MatchCreatetopReasonsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutMatchesAsUserAInput = {
    create?: XOR<UserCreateWithoutMatchesAsUserAInput, UserUncheckedCreateWithoutMatchesAsUserAInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchesAsUserAInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMatchesAsUserBInput = {
    create?: XOR<UserCreateWithoutMatchesAsUserBInput, UserUncheckedCreateWithoutMatchesAsUserBInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchesAsUserBInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutMatchInput = {
    create?: XOR<MessageCreateWithoutMatchInput, MessageUncheckedCreateWithoutMatchInput> | MessageCreateWithoutMatchInput[] | MessageUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutMatchInput | MessageCreateOrConnectWithoutMatchInput[]
    createMany?: MessageCreateManyMatchInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ScheduledDateCreateNestedManyWithoutMatchInput = {
    create?: XOR<ScheduledDateCreateWithoutMatchInput, ScheduledDateUncheckedCreateWithoutMatchInput> | ScheduledDateCreateWithoutMatchInput[] | ScheduledDateUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: ScheduledDateCreateOrConnectWithoutMatchInput | ScheduledDateCreateOrConnectWithoutMatchInput[]
    createMany?: ScheduledDateCreateManyMatchInputEnvelope
    connect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<MessageCreateWithoutMatchInput, MessageUncheckedCreateWithoutMatchInput> | MessageCreateWithoutMatchInput[] | MessageUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutMatchInput | MessageCreateOrConnectWithoutMatchInput[]
    createMany?: MessageCreateManyMatchInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ScheduledDateUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<ScheduledDateCreateWithoutMatchInput, ScheduledDateUncheckedCreateWithoutMatchInput> | ScheduledDateCreateWithoutMatchInput[] | ScheduledDateUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: ScheduledDateCreateOrConnectWithoutMatchInput | ScheduledDateCreateOrConnectWithoutMatchInput[]
    createMany?: ScheduledDateCreateManyMatchInputEnvelope
    connect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
  }

  export type MatchUpdatetopReasonsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutMatchesAsUserANestedInput = {
    create?: XOR<UserCreateWithoutMatchesAsUserAInput, UserUncheckedCreateWithoutMatchesAsUserAInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchesAsUserAInput
    upsert?: UserUpsertWithoutMatchesAsUserAInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMatchesAsUserAInput, UserUpdateWithoutMatchesAsUserAInput>, UserUncheckedUpdateWithoutMatchesAsUserAInput>
  }

  export type UserUpdateOneRequiredWithoutMatchesAsUserBNestedInput = {
    create?: XOR<UserCreateWithoutMatchesAsUserBInput, UserUncheckedCreateWithoutMatchesAsUserBInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchesAsUserBInput
    upsert?: UserUpsertWithoutMatchesAsUserBInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMatchesAsUserBInput, UserUpdateWithoutMatchesAsUserBInput>, UserUncheckedUpdateWithoutMatchesAsUserBInput>
  }

  export type MessageUpdateManyWithoutMatchNestedInput = {
    create?: XOR<MessageCreateWithoutMatchInput, MessageUncheckedCreateWithoutMatchInput> | MessageCreateWithoutMatchInput[] | MessageUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutMatchInput | MessageCreateOrConnectWithoutMatchInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutMatchInput | MessageUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: MessageCreateManyMatchInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutMatchInput | MessageUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutMatchInput | MessageUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ScheduledDateUpdateManyWithoutMatchNestedInput = {
    create?: XOR<ScheduledDateCreateWithoutMatchInput, ScheduledDateUncheckedCreateWithoutMatchInput> | ScheduledDateCreateWithoutMatchInput[] | ScheduledDateUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: ScheduledDateCreateOrConnectWithoutMatchInput | ScheduledDateCreateOrConnectWithoutMatchInput[]
    upsert?: ScheduledDateUpsertWithWhereUniqueWithoutMatchInput | ScheduledDateUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: ScheduledDateCreateManyMatchInputEnvelope
    set?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    disconnect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    delete?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    connect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    update?: ScheduledDateUpdateWithWhereUniqueWithoutMatchInput | ScheduledDateUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: ScheduledDateUpdateManyWithWhereWithoutMatchInput | ScheduledDateUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: ScheduledDateScalarWhereInput | ScheduledDateScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<MessageCreateWithoutMatchInput, MessageUncheckedCreateWithoutMatchInput> | MessageCreateWithoutMatchInput[] | MessageUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutMatchInput | MessageCreateOrConnectWithoutMatchInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutMatchInput | MessageUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: MessageCreateManyMatchInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutMatchInput | MessageUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutMatchInput | MessageUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ScheduledDateUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<ScheduledDateCreateWithoutMatchInput, ScheduledDateUncheckedCreateWithoutMatchInput> | ScheduledDateCreateWithoutMatchInput[] | ScheduledDateUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: ScheduledDateCreateOrConnectWithoutMatchInput | ScheduledDateCreateOrConnectWithoutMatchInput[]
    upsert?: ScheduledDateUpsertWithWhereUniqueWithoutMatchInput | ScheduledDateUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: ScheduledDateCreateManyMatchInputEnvelope
    set?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    disconnect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    delete?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    connect?: ScheduledDateWhereUniqueInput | ScheduledDateWhereUniqueInput[]
    update?: ScheduledDateUpdateWithWhereUniqueWithoutMatchInput | ScheduledDateUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: ScheduledDateUpdateManyWithWhereWithoutMatchInput | ScheduledDateUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: ScheduledDateScalarWhereInput | ScheduledDateScalarWhereInput[]
  }

  export type MessageCreatesafetyFlagsInput = {
    set: string[]
  }

  export type MatchCreateNestedOneWithoutMessagesInput = {
    create?: XOR<MatchCreateWithoutMessagesInput, MatchUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: MatchCreateOrConnectWithoutMessagesInput
    connect?: MatchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesSentInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesReceivedInput = {
    create?: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMessageStatusFieldUpdateOperationsInput = {
    set?: $Enums.MessageStatus
  }

  export type MessageUpdatesafetyFlagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MatchUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<MatchCreateWithoutMessagesInput, MatchUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: MatchCreateOrConnectWithoutMessagesInput
    upsert?: MatchUpsertWithoutMessagesInput
    connect?: MatchWhereUniqueInput
    update?: XOR<XOR<MatchUpdateToOneWithWhereWithoutMessagesInput, MatchUpdateWithoutMessagesInput>, MatchUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesSentNestedInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    upsert?: UserUpsertWithoutMessagesSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesSentInput, UserUpdateWithoutMessagesSentInput>, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesReceivedNestedInput = {
    create?: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesReceivedInput
    upsert?: UserUpsertWithoutMessagesReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesReceivedInput, UserUpdateWithoutMessagesReceivedInput>, UserUncheckedUpdateWithoutMessagesReceivedInput>
  }

  export type UserCreateNestedOneWithoutTrustScoreInput = {
    create?: XOR<UserCreateWithoutTrustScoreInput, UserUncheckedCreateWithoutTrustScoreInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrustScoreInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTrustScoreNestedInput = {
    create?: XOR<UserCreateWithoutTrustScoreInput, UserUncheckedCreateWithoutTrustScoreInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrustScoreInput
    upsert?: UserUpsertWithoutTrustScoreInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTrustScoreInput, UserUpdateWithoutTrustScoreInput>, UserUncheckedUpdateWithoutTrustScoreInput>
  }

  export type UserCreateNestedOneWithoutBehaviorLogsInput = {
    create?: XOR<UserCreateWithoutBehaviorLogsInput, UserUncheckedCreateWithoutBehaviorLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBehaviorLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumBehaviorTypeFieldUpdateOperationsInput = {
    set?: $Enums.BehaviorType
  }

  export type UserUpdateOneRequiredWithoutBehaviorLogsNestedInput = {
    create?: XOR<UserCreateWithoutBehaviorLogsInput, UserUncheckedCreateWithoutBehaviorLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBehaviorLogsInput
    upsert?: UserUpsertWithoutBehaviorLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBehaviorLogsInput, UserUpdateWithoutBehaviorLogsInput>, UserUncheckedUpdateWithoutBehaviorLogsInput>
  }

  export type UserCreateNestedOneWithoutRiskAssessmentInput = {
    create?: XOR<UserCreateWithoutRiskAssessmentInput, UserUncheckedCreateWithoutRiskAssessmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutRiskAssessmentInput
    connect?: UserWhereUniqueInput
  }

  export type EnumRiskLevelFieldUpdateOperationsInput = {
    set?: $Enums.RiskLevel
  }

  export type UserUpdateOneRequiredWithoutRiskAssessmentNestedInput = {
    create?: XOR<UserCreateWithoutRiskAssessmentInput, UserUncheckedCreateWithoutRiskAssessmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutRiskAssessmentInput
    upsert?: UserUpsertWithoutRiskAssessmentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRiskAssessmentInput, UserUpdateWithoutRiskAssessmentInput>, UserUncheckedUpdateWithoutRiskAssessmentInput>
  }

  export type UserCreateNestedOneWithoutReportsFiledInput = {
    create?: XOR<UserCreateWithoutReportsFiledInput, UserUncheckedCreateWithoutReportsFiledInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsFiledInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportsReceivedInput = {
    create?: XOR<UserCreateWithoutReportsReceivedInput, UserUncheckedCreateWithoutReportsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReportTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReportType
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type UserUpdateOneRequiredWithoutReportsFiledNestedInput = {
    create?: XOR<UserCreateWithoutReportsFiledInput, UserUncheckedCreateWithoutReportsFiledInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsFiledInput
    upsert?: UserUpsertWithoutReportsFiledInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsFiledInput, UserUpdateWithoutReportsFiledInput>, UserUncheckedUpdateWithoutReportsFiledInput>
  }

  export type UserUpdateOneRequiredWithoutReportsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutReportsReceivedInput, UserUncheckedCreateWithoutReportsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsReceivedInput
    upsert?: UserUpsertWithoutReportsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsReceivedInput, UserUpdateWithoutReportsReceivedInput>, UserUncheckedUpdateWithoutReportsReceivedInput>
  }

  export type UserCreateNestedOneWithoutSafetySignalsInput = {
    create?: XOR<UserCreateWithoutSafetySignalsInput, UserUncheckedCreateWithoutSafetySignalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSafetySignalsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSafetySignalTypeFieldUpdateOperationsInput = {
    set?: $Enums.SafetySignalType
  }

  export type UserUpdateOneRequiredWithoutSafetySignalsNestedInput = {
    create?: XOR<UserCreateWithoutSafetySignalsInput, UserUncheckedCreateWithoutSafetySignalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSafetySignalsInput
    upsert?: UserUpsertWithoutSafetySignalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSafetySignalsInput, UserUpdateWithoutSafetySignalsInput>, UserUncheckedUpdateWithoutSafetySignalsInput>
  }

  export type UserCreateNestedOneWithoutVerificationsInput = {
    create?: XOR<UserCreateWithoutVerificationsInput, UserUncheckedCreateWithoutVerificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutVerificationsNestedInput = {
    create?: XOR<UserCreateWithoutVerificationsInput, UserUncheckedCreateWithoutVerificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerificationsInput
    upsert?: UserUpsertWithoutVerificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerificationsInput, UserUpdateWithoutVerificationsInput>, UserUncheckedUpdateWithoutVerificationsInput>
  }

  export type UserCreateNestedOneWithoutBlocksCreatedInput = {
    create?: XOR<UserCreateWithoutBlocksCreatedInput, UserUncheckedCreateWithoutBlocksCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlocksCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBlocksReceivedInput = {
    create?: XOR<UserCreateWithoutBlocksReceivedInput, UserUncheckedCreateWithoutBlocksReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlocksReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBlocksCreatedNestedInput = {
    create?: XOR<UserCreateWithoutBlocksCreatedInput, UserUncheckedCreateWithoutBlocksCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlocksCreatedInput
    upsert?: UserUpsertWithoutBlocksCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlocksCreatedInput, UserUpdateWithoutBlocksCreatedInput>, UserUncheckedUpdateWithoutBlocksCreatedInput>
  }

  export type UserUpdateOneRequiredWithoutBlocksReceivedNestedInput = {
    create?: XOR<UserCreateWithoutBlocksReceivedInput, UserUncheckedCreateWithoutBlocksReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlocksReceivedInput
    upsert?: UserUpsertWithoutBlocksReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlocksReceivedInput, UserUpdateWithoutBlocksReceivedInput>, UserUncheckedUpdateWithoutBlocksReceivedInput>
  }

  export type UserCreateNestedOneWithoutIntentHistoryInput = {
    create?: XOR<UserCreateWithoutIntentHistoryInput, UserUncheckedCreateWithoutIntentHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutIntentHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type EnumRelationshipIntentFieldUpdateOperationsInput = {
    set?: $Enums.RelationshipIntent
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutIntentHistoryNestedInput = {
    create?: XOR<UserCreateWithoutIntentHistoryInput, UserUncheckedCreateWithoutIntentHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutIntentHistoryInput
    upsert?: UserUpsertWithoutIntentHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIntentHistoryInput, UserUpdateWithoutIntentHistoryInput>, UserUncheckedUpdateWithoutIntentHistoryInput>
  }

  export type ScheduledDateCreateconcernsInput = {
    set: string[]
  }

  export type ScheduledDateCreatesuggestionsInput = {
    set: string[]
  }

  export type MatchCreateNestedOneWithoutScheduledDatesInput = {
    create?: XOR<MatchCreateWithoutScheduledDatesInput, MatchUncheckedCreateWithoutScheduledDatesInput>
    connectOrCreate?: MatchCreateOrConnectWithoutScheduledDatesInput
    connect?: MatchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutScheduledDatesInput = {
    create?: XOR<UserCreateWithoutScheduledDatesInput, UserUncheckedCreateWithoutScheduledDatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutScheduledDatesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDatesAsPartnerInput = {
    create?: XOR<UserCreateWithoutDatesAsPartnerInput, UserUncheckedCreateWithoutDatesAsPartnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutDatesAsPartnerInput
    connect?: UserWhereUniqueInput
  }

  export type ScheduledDateUpdateconcernsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ScheduledDateUpdatesuggestionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MatchUpdateOneRequiredWithoutScheduledDatesNestedInput = {
    create?: XOR<MatchCreateWithoutScheduledDatesInput, MatchUncheckedCreateWithoutScheduledDatesInput>
    connectOrCreate?: MatchCreateOrConnectWithoutScheduledDatesInput
    upsert?: MatchUpsertWithoutScheduledDatesInput
    connect?: MatchWhereUniqueInput
    update?: XOR<XOR<MatchUpdateToOneWithWhereWithoutScheduledDatesInput, MatchUpdateWithoutScheduledDatesInput>, MatchUncheckedUpdateWithoutScheduledDatesInput>
  }

  export type UserUpdateOneRequiredWithoutScheduledDatesNestedInput = {
    create?: XOR<UserCreateWithoutScheduledDatesInput, UserUncheckedCreateWithoutScheduledDatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutScheduledDatesInput
    upsert?: UserUpsertWithoutScheduledDatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutScheduledDatesInput, UserUpdateWithoutScheduledDatesInput>, UserUncheckedUpdateWithoutScheduledDatesInput>
  }

  export type UserUpdateOneRequiredWithoutDatesAsPartnerNestedInput = {
    create?: XOR<UserCreateWithoutDatesAsPartnerInput, UserUncheckedCreateWithoutDatesAsPartnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutDatesAsPartnerInput
    upsert?: UserUpsertWithoutDatesAsPartnerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDatesAsPartnerInput, UserUpdateWithoutDatesAsPartnerInput>, UserUncheckedUpdateWithoutDatesAsPartnerInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRelationshipIntentNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipIntent | EnumRelationshipIntentFieldRefInput<$PrismaModel> | null
    in?: $Enums.RelationshipIntent[] | ListEnumRelationshipIntentFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RelationshipIntent[] | ListEnumRelationshipIntentFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRelationshipIntentNullableFilter<$PrismaModel> | $Enums.RelationshipIntent | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumRelationshipIntentNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipIntent | EnumRelationshipIntentFieldRefInput<$PrismaModel> | null
    in?: $Enums.RelationshipIntent[] | ListEnumRelationshipIntentFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RelationshipIntent[] | ListEnumRelationshipIntentFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRelationshipIntentNullableWithAggregatesFilter<$PrismaModel> | $Enums.RelationshipIntent | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRelationshipIntentNullableFilter<$PrismaModel>
    _max?: NestedEnumRelationshipIntentNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumQuestionCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionCategory | EnumQuestionCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionCategory[] | ListEnumQuestionCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionCategory[] | ListEnumQuestionCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionCategoryFilter<$PrismaModel> | $Enums.QuestionCategory
  }

  export type NestedEnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type NestedEnumQuestionCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionCategory | EnumQuestionCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionCategory[] | ListEnumQuestionCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionCategory[] | ListEnumQuestionCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionCategoryWithAggregatesFilter<$PrismaModel> | $Enums.QuestionCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionCategoryFilter<$PrismaModel>
    _max?: NestedEnumQuestionCategoryFilter<$PrismaModel>
  }

  export type NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type NestedEnumBehaviorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BehaviorType | EnumBehaviorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BehaviorType[] | ListEnumBehaviorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehaviorType[] | ListEnumBehaviorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBehaviorTypeFilter<$PrismaModel> | $Enums.BehaviorType
  }

  export type NestedEnumBehaviorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BehaviorType | EnumBehaviorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BehaviorType[] | ListEnumBehaviorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehaviorType[] | ListEnumBehaviorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBehaviorTypeWithAggregatesFilter<$PrismaModel> | $Enums.BehaviorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBehaviorTypeFilter<$PrismaModel>
    _max?: NestedEnumBehaviorTypeFilter<$PrismaModel>
  }

  export type NestedEnumRiskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelFilter<$PrismaModel> | $Enums.RiskLevel
  }

  export type NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel> | $Enums.RiskLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskLevelFilter<$PrismaModel>
    _max?: NestedEnumRiskLevelFilter<$PrismaModel>
  }

  export type NestedEnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumSafetySignalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SafetySignalType | EnumSafetySignalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SafetySignalType[] | ListEnumSafetySignalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SafetySignalType[] | ListEnumSafetySignalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSafetySignalTypeFilter<$PrismaModel> | $Enums.SafetySignalType
  }

  export type NestedEnumSafetySignalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SafetySignalType | EnumSafetySignalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SafetySignalType[] | ListEnumSafetySignalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SafetySignalType[] | ListEnumSafetySignalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSafetySignalTypeWithAggregatesFilter<$PrismaModel> | $Enums.SafetySignalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSafetySignalTypeFilter<$PrismaModel>
    _max?: NestedEnumSafetySignalTypeFilter<$PrismaModel>
  }

  export type NestedEnumRelationshipIntentFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipIntent | EnumRelationshipIntentFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipIntent[] | ListEnumRelationshipIntentFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipIntent[] | ListEnumRelationshipIntentFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipIntentFilter<$PrismaModel> | $Enums.RelationshipIntent
  }

  export type NestedEnumRelationshipIntentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipIntent | EnumRelationshipIntentFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipIntent[] | ListEnumRelationshipIntentFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipIntent[] | ListEnumRelationshipIntentFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipIntentWithAggregatesFilter<$PrismaModel> | $Enums.RelationshipIntent
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationshipIntentFilter<$PrismaModel>
    _max?: NestedEnumRelationshipIntentFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    firstName: string
    displayName?: string | null
    birthDate: Date | string
    gender: $Enums.Gender
    genderPreferences?: ProfileCreategenderPreferencesInput | $Enums.Gender[]
    city?: string | null
    state?: string | null
    country?: string | null
    latitude?: number | null
    longitude?: number | null
    bio?: string | null
    height?: number | null
    relationshipIntent?: $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: number
    completenessScore?: number
    specificityScore?: number
    consistencyScore?: number
    stabilityScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoCreateNestedManyWithoutProfileInput
    prompts?: ProfilePromptCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    firstName: string
    displayName?: string | null
    birthDate: Date | string
    gender: $Enums.Gender
    genderPreferences?: ProfileCreategenderPreferencesInput | $Enums.Gender[]
    city?: string | null
    state?: string | null
    country?: string | null
    latitude?: number | null
    longitude?: number | null
    bio?: string | null
    height?: number | null
    relationshipIntent?: $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: number
    completenessScore?: number
    specificityScore?: number
    consistencyScore?: number
    stabilityScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoUncheckedCreateNestedManyWithoutProfileInput
    prompts?: ProfilePromptUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type OnboardingAnswerCreateWithoutUserInput = {
    id?: string
    answer: JsonNullValueInput | InputJsonValue
    followUpCount?: number
    confidence?: number | null
    consistency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    question: OnboardingQuestionCreateNestedOneWithoutAnswersInput
  }

  export type OnboardingAnswerUncheckedCreateWithoutUserInput = {
    id?: string
    questionId: string
    answer: JsonNullValueInput | InputJsonValue
    followUpCount?: number
    confidence?: number | null
    consistency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnboardingAnswerCreateOrConnectWithoutUserInput = {
    where: OnboardingAnswerWhereUniqueInput
    create: XOR<OnboardingAnswerCreateWithoutUserInput, OnboardingAnswerUncheckedCreateWithoutUserInput>
  }

  export type OnboardingAnswerCreateManyUserInputEnvelope = {
    data: OnboardingAnswerCreateManyUserInput | OnboardingAnswerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutFromUserInput = {
    id?: string
    createdAt?: Date | string
    toUser: UserCreateNestedOneWithoutLikesReceivedInput
  }

  export type LikeUncheckedCreateWithoutFromUserInput = {
    id?: string
    toUserId: string
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutFromUserInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutFromUserInput, LikeUncheckedCreateWithoutFromUserInput>
  }

  export type LikeCreateManyFromUserInputEnvelope = {
    data: LikeCreateManyFromUserInput | LikeCreateManyFromUserInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutToUserInput = {
    id?: string
    createdAt?: Date | string
    fromUser: UserCreateNestedOneWithoutLikesGivenInput
  }

  export type LikeUncheckedCreateWithoutToUserInput = {
    id?: string
    fromUserId: string
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutToUserInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutToUserInput, LikeUncheckedCreateWithoutToUserInput>
  }

  export type LikeCreateManyToUserInputEnvelope = {
    data: LikeCreateManyToUserInput | LikeCreateManyToUserInput[]
    skipDuplicates?: boolean
  }

  export type MatchCreateWithoutUserAInput = {
    id?: string
    overallScore?: number
    valuesScore?: number
    lifestyleScore?: number
    intentScore?: number
    communicationScore?: number
    logisticsScore?: number
    topReasons?: MatchCreatetopReasonsInput | string[]
    frictionPoint?: string | null
    confidenceLevel?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userB: UserCreateNestedOneWithoutMatchesAsUserBInput
    messages?: MessageCreateNestedManyWithoutMatchInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutUserAInput = {
    id?: string
    userBId: string
    overallScore?: number
    valuesScore?: number
    lifestyleScore?: number
    intentScore?: number
    communicationScore?: number
    logisticsScore?: number
    topReasons?: MatchCreatetopReasonsInput | string[]
    frictionPoint?: string | null
    confidenceLevel?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutMatchInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutUserAInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutUserAInput, MatchUncheckedCreateWithoutUserAInput>
  }

  export type MatchCreateManyUserAInputEnvelope = {
    data: MatchCreateManyUserAInput | MatchCreateManyUserAInput[]
    skipDuplicates?: boolean
  }

  export type MatchCreateWithoutUserBInput = {
    id?: string
    overallScore?: number
    valuesScore?: number
    lifestyleScore?: number
    intentScore?: number
    communicationScore?: number
    logisticsScore?: number
    topReasons?: MatchCreatetopReasonsInput | string[]
    frictionPoint?: string | null
    confidenceLevel?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userA: UserCreateNestedOneWithoutMatchesAsUserAInput
    messages?: MessageCreateNestedManyWithoutMatchInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutUserBInput = {
    id?: string
    userAId: string
    overallScore?: number
    valuesScore?: number
    lifestyleScore?: number
    intentScore?: number
    communicationScore?: number
    logisticsScore?: number
    topReasons?: MatchCreatetopReasonsInput | string[]
    frictionPoint?: string | null
    confidenceLevel?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutMatchInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutUserBInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutUserBInput, MatchUncheckedCreateWithoutUserBInput>
  }

  export type MatchCreateManyUserBInputEnvelope = {
    data: MatchCreateManyUserBInput | MatchCreateManyUserBInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    status?: $Enums.MessageStatus
    safetyScore?: number | null
    safetyFlags?: MessageCreatesafetyFlagsInput | string[]
    createdAt?: Date | string
    readAt?: Date | string | null
    match: MatchCreateNestedOneWithoutMessagesInput
    receiver: UserCreateNestedOneWithoutMessagesReceivedInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    matchId: string
    receiverId: string
    content: string
    status?: $Enums.MessageStatus
    safetyScore?: number | null
    safetyFlags?: MessageCreatesafetyFlagsInput | string[]
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutReceiverInput = {
    id?: string
    content: string
    status?: $Enums.MessageStatus
    safetyScore?: number | null
    safetyFlags?: MessageCreatesafetyFlagsInput | string[]
    createdAt?: Date | string
    readAt?: Date | string | null
    match: MatchCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesSentInput
  }

  export type MessageUncheckedCreateWithoutReceiverInput = {
    id?: string
    matchId: string
    senderId: string
    content: string
    status?: $Enums.MessageStatus
    safetyScore?: number | null
    safetyFlags?: MessageCreatesafetyFlagsInput | string[]
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type MessageCreateOrConnectWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageCreateManyReceiverInputEnvelope = {
    data: MessageCreateManyReceiverInput | MessageCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type TrustScoreCreateWithoutUserInput = {
    id?: string
    overallScore?: number
    replyPatternScore?: number
    commitmentScore?: number
    respectScore?: number
    toneConsistencyScore?: number
    lastCalculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrustScoreUncheckedCreateWithoutUserInput = {
    id?: string
    overallScore?: number
    replyPatternScore?: number
    commitmentScore?: number
    respectScore?: number
    toneConsistencyScore?: number
    lastCalculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrustScoreCreateOrConnectWithoutUserInput = {
    where: TrustScoreWhereUniqueInput
    create: XOR<TrustScoreCreateWithoutUserInput, TrustScoreUncheckedCreateWithoutUserInput>
  }

  export type BehaviorLogCreateWithoutUserInput = {
    id?: string
    behaviorType: $Enums.BehaviorType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    createdAt?: Date | string
  }

  export type BehaviorLogUncheckedCreateWithoutUserInput = {
    id?: string
    behaviorType: $Enums.BehaviorType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    createdAt?: Date | string
  }

  export type BehaviorLogCreateOrConnectWithoutUserInput = {
    where: BehaviorLogWhereUniqueInput
    create: XOR<BehaviorLogCreateWithoutUserInput, BehaviorLogUncheckedCreateWithoutUserInput>
  }

  export type BehaviorLogCreateManyUserInputEnvelope = {
    data: BehaviorLogCreateManyUserInput | BehaviorLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RiskAssessmentCreateWithoutUserInput = {
    id?: string
    riskIndex?: number
    riskLevel?: $Enums.RiskLevel
    reportScore?: number
    messageRiskScore?: number
    patternRiskScore?: number
    isRestricted?: boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    lastAssessedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskAssessmentUncheckedCreateWithoutUserInput = {
    id?: string
    riskIndex?: number
    riskLevel?: $Enums.RiskLevel
    reportScore?: number
    messageRiskScore?: number
    patternRiskScore?: number
    isRestricted?: boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    lastAssessedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskAssessmentCreateOrConnectWithoutUserInput = {
    where: RiskAssessmentWhereUniqueInput
    create: XOR<RiskAssessmentCreateWithoutUserInput, RiskAssessmentUncheckedCreateWithoutUserInput>
  }

  export type ReportCreateWithoutReporterInput = {
    id?: string
    type: $Enums.ReportType
    description?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    reviewNotes?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    reportedUser: UserCreateNestedOneWithoutReportsReceivedInput
  }

  export type ReportUncheckedCreateWithoutReporterInput = {
    id?: string
    reportedUserId: string
    type: $Enums.ReportType
    description?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    reviewNotes?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutReporterInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>
  }

  export type ReportCreateManyReporterInputEnvelope = {
    data: ReportCreateManyReporterInput | ReportCreateManyReporterInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutReportedUserInput = {
    id?: string
    type: $Enums.ReportType
    description?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    reviewNotes?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportsFiledInput
  }

  export type ReportUncheckedCreateWithoutReportedUserInput = {
    id?: string
    reporterId: string
    type: $Enums.ReportType
    description?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    reviewNotes?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutReportedUserInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput>
  }

  export type ReportCreateManyReportedUserInputEnvelope = {
    data: ReportCreateManyReportedUserInput | ReportCreateManyReportedUserInput[]
    skipDuplicates?: boolean
  }

  export type SafetySignalCreateWithoutUserInput = {
    id?: string
    signalType: $Enums.SafetySignalType
    verifiedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SafetySignalUncheckedCreateWithoutUserInput = {
    id?: string
    signalType: $Enums.SafetySignalType
    verifiedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SafetySignalCreateOrConnectWithoutUserInput = {
    where: SafetySignalWhereUniqueInput
    create: XOR<SafetySignalCreateWithoutUserInput, SafetySignalUncheckedCreateWithoutUserInput>
  }

  export type SafetySignalCreateManyUserInputEnvelope = {
    data: SafetySignalCreateManyUserInput | SafetySignalCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VerificationCreateWithoutUserInput = {
    id?: string
    type: string
    status?: string
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    verifiedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type VerificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    status?: string
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    verifiedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type VerificationCreateOrConnectWithoutUserInput = {
    where: VerificationWhereUniqueInput
    create: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput>
  }

  export type VerificationCreateManyUserInputEnvelope = {
    data: VerificationCreateManyUserInput | VerificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IntentHistoryCreateWithoutUserInput = {
    id?: string
    statedIntent: $Enums.RelationshipIntent
    behaviorIntent?: $Enums.RelationshipIntent | null
    confidence?: number
    driftDetected?: boolean
    createdAt?: Date | string
  }

  export type IntentHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    statedIntent: $Enums.RelationshipIntent
    behaviorIntent?: $Enums.RelationshipIntent | null
    confidence?: number
    driftDetected?: boolean
    createdAt?: Date | string
  }

  export type IntentHistoryCreateOrConnectWithoutUserInput = {
    where: IntentHistoryWhereUniqueInput
    create: XOR<IntentHistoryCreateWithoutUserInput, IntentHistoryUncheckedCreateWithoutUserInput>
  }

  export type IntentHistoryCreateManyUserInputEnvelope = {
    data: IntentHistoryCreateManyUserInput | IntentHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlockCreateWithoutBlockerInput = {
    id?: string
    reason?: string | null
    createdAt?: Date | string
    blockedUser: UserCreateNestedOneWithoutBlocksReceivedInput
  }

  export type BlockUncheckedCreateWithoutBlockerInput = {
    id?: string
    blockedUserId: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type BlockCreateOrConnectWithoutBlockerInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput>
  }

  export type BlockCreateManyBlockerInputEnvelope = {
    data: BlockCreateManyBlockerInput | BlockCreateManyBlockerInput[]
    skipDuplicates?: boolean
  }

  export type BlockCreateWithoutBlockedUserInput = {
    id?: string
    reason?: string | null
    createdAt?: Date | string
    blocker: UserCreateNestedOneWithoutBlocksCreatedInput
  }

  export type BlockUncheckedCreateWithoutBlockedUserInput = {
    id?: string
    blockerId: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type BlockCreateOrConnectWithoutBlockedUserInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutBlockedUserInput, BlockUncheckedCreateWithoutBlockedUserInput>
  }

  export type BlockCreateManyBlockedUserInputEnvelope = {
    data: BlockCreateManyBlockedUserInput | BlockCreateManyBlockedUserInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledDateCreateWithoutSchedulerInput = {
    id?: string
    dateTime: Date | string
    location?: string | null
    isPublicPlace?: boolean
    safetyCheckIn?: boolean
    checkInTime?: Date | string | null
    locationSharing?: boolean
    safetyScore?: number | null
    concerns?: ScheduledDateCreateconcernsInput | string[]
    suggestions?: ScheduledDateCreatesuggestionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    match: MatchCreateNestedOneWithoutScheduledDatesInput
    partner: UserCreateNestedOneWithoutDatesAsPartnerInput
  }

  export type ScheduledDateUncheckedCreateWithoutSchedulerInput = {
    id?: string
    matchId: string
    partnerId: string
    dateTime: Date | string
    location?: string | null
    isPublicPlace?: boolean
    safetyCheckIn?: boolean
    checkInTime?: Date | string | null
    locationSharing?: boolean
    safetyScore?: number | null
    concerns?: ScheduledDateCreateconcernsInput | string[]
    suggestions?: ScheduledDateCreatesuggestionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledDateCreateOrConnectWithoutSchedulerInput = {
    where: ScheduledDateWhereUniqueInput
    create: XOR<ScheduledDateCreateWithoutSchedulerInput, ScheduledDateUncheckedCreateWithoutSchedulerInput>
  }

  export type ScheduledDateCreateManySchedulerInputEnvelope = {
    data: ScheduledDateCreateManySchedulerInput | ScheduledDateCreateManySchedulerInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledDateCreateWithoutPartnerInput = {
    id?: string
    dateTime: Date | string
    location?: string | null
    isPublicPlace?: boolean
    safetyCheckIn?: boolean
    checkInTime?: Date | string | null
    locationSharing?: boolean
    safetyScore?: number | null
    concerns?: ScheduledDateCreateconcernsInput | string[]
    suggestions?: ScheduledDateCreatesuggestionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    match: MatchCreateNestedOneWithoutScheduledDatesInput
    scheduler: UserCreateNestedOneWithoutScheduledDatesInput
  }

  export type ScheduledDateUncheckedCreateWithoutPartnerInput = {
    id?: string
    matchId: string
    schedulerId: string
    dateTime: Date | string
    location?: string | null
    isPublicPlace?: boolean
    safetyCheckIn?: boolean
    checkInTime?: Date | string | null
    locationSharing?: boolean
    safetyScore?: number | null
    concerns?: ScheduledDateCreateconcernsInput | string[]
    suggestions?: ScheduledDateCreatesuggestionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledDateCreateOrConnectWithoutPartnerInput = {
    where: ScheduledDateWhereUniqueInput
    create: XOR<ScheduledDateCreateWithoutPartnerInput, ScheduledDateUncheckedCreateWithoutPartnerInput>
  }

  export type ScheduledDateCreateManyPartnerInputEnvelope = {
    data: ScheduledDateCreateManyPartnerInput | ScheduledDateCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    genderPreferences?: ProfileUpdategenderPreferencesInput | $Enums.Gender[]
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipIntent?: NullableEnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    specificityScore?: IntFieldUpdateOperationsInput | number
    consistencyScore?: IntFieldUpdateOperationsInput | number
    stabilityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUpdateManyWithoutProfileNestedInput
    prompts?: ProfilePromptUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    genderPreferences?: ProfileUpdategenderPreferencesInput | $Enums.Gender[]
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipIntent?: NullableEnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    specificityScore?: IntFieldUpdateOperationsInput | number
    consistencyScore?: IntFieldUpdateOperationsInput | number
    stabilityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUncheckedUpdateManyWithoutProfileNestedInput
    prompts?: ProfilePromptUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type OnboardingAnswerUpsertWithWhereUniqueWithoutUserInput = {
    where: OnboardingAnswerWhereUniqueInput
    update: XOR<OnboardingAnswerUpdateWithoutUserInput, OnboardingAnswerUncheckedUpdateWithoutUserInput>
    create: XOR<OnboardingAnswerCreateWithoutUserInput, OnboardingAnswerUncheckedCreateWithoutUserInput>
  }

  export type OnboardingAnswerUpdateWithWhereUniqueWithoutUserInput = {
    where: OnboardingAnswerWhereUniqueInput
    data: XOR<OnboardingAnswerUpdateWithoutUserInput, OnboardingAnswerUncheckedUpdateWithoutUserInput>
  }

  export type OnboardingAnswerUpdateManyWithWhereWithoutUserInput = {
    where: OnboardingAnswerScalarWhereInput
    data: XOR<OnboardingAnswerUpdateManyMutationInput, OnboardingAnswerUncheckedUpdateManyWithoutUserInput>
  }

  export type OnboardingAnswerScalarWhereInput = {
    AND?: OnboardingAnswerScalarWhereInput | OnboardingAnswerScalarWhereInput[]
    OR?: OnboardingAnswerScalarWhereInput[]
    NOT?: OnboardingAnswerScalarWhereInput | OnboardingAnswerScalarWhereInput[]
    id?: StringFilter<"OnboardingAnswer"> | string
    userId?: StringFilter<"OnboardingAnswer"> | string
    questionId?: StringFilter<"OnboardingAnswer"> | string
    answer?: JsonFilter<"OnboardingAnswer">
    followUpCount?: IntFilter<"OnboardingAnswer"> | number
    confidence?: FloatNullableFilter<"OnboardingAnswer"> | number | null
    consistency?: FloatNullableFilter<"OnboardingAnswer"> | number | null
    createdAt?: DateTimeFilter<"OnboardingAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"OnboardingAnswer"> | Date | string
  }

  export type LikeUpsertWithWhereUniqueWithoutFromUserInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutFromUserInput, LikeUncheckedUpdateWithoutFromUserInput>
    create: XOR<LikeCreateWithoutFromUserInput, LikeUncheckedCreateWithoutFromUserInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutFromUserInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutFromUserInput, LikeUncheckedUpdateWithoutFromUserInput>
  }

  export type LikeUpdateManyWithWhereWithoutFromUserInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutFromUserInput>
  }

  export type LikeScalarWhereInput = {
    AND?: LikeScalarWhereInput | LikeScalarWhereInput[]
    OR?: LikeScalarWhereInput[]
    NOT?: LikeScalarWhereInput | LikeScalarWhereInput[]
    id?: StringFilter<"Like"> | string
    fromUserId?: StringFilter<"Like"> | string
    toUserId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
  }

  export type LikeUpsertWithWhereUniqueWithoutToUserInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutToUserInput, LikeUncheckedUpdateWithoutToUserInput>
    create: XOR<LikeCreateWithoutToUserInput, LikeUncheckedCreateWithoutToUserInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutToUserInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutToUserInput, LikeUncheckedUpdateWithoutToUserInput>
  }

  export type LikeUpdateManyWithWhereWithoutToUserInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutToUserInput>
  }

  export type MatchUpsertWithWhereUniqueWithoutUserAInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutUserAInput, MatchUncheckedUpdateWithoutUserAInput>
    create: XOR<MatchCreateWithoutUserAInput, MatchUncheckedCreateWithoutUserAInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutUserAInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutUserAInput, MatchUncheckedUpdateWithoutUserAInput>
  }

  export type MatchUpdateManyWithWhereWithoutUserAInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutUserAInput>
  }

  export type MatchScalarWhereInput = {
    AND?: MatchScalarWhereInput | MatchScalarWhereInput[]
    OR?: MatchScalarWhereInput[]
    NOT?: MatchScalarWhereInput | MatchScalarWhereInput[]
    id?: StringFilter<"Match"> | string
    userAId?: StringFilter<"Match"> | string
    userBId?: StringFilter<"Match"> | string
    overallScore?: IntFilter<"Match"> | number
    valuesScore?: IntFilter<"Match"> | number
    lifestyleScore?: IntFilter<"Match"> | number
    intentScore?: IntFilter<"Match"> | number
    communicationScore?: IntFilter<"Match"> | number
    logisticsScore?: IntFilter<"Match"> | number
    topReasons?: StringNullableListFilter<"Match">
    frictionPoint?: StringNullableFilter<"Match"> | string | null
    confidenceLevel?: FloatNullableFilter<"Match"> | number | null
    isActive?: BoolFilter<"Match"> | boolean
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
  }

  export type MatchUpsertWithWhereUniqueWithoutUserBInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutUserBInput, MatchUncheckedUpdateWithoutUserBInput>
    create: XOR<MatchCreateWithoutUserBInput, MatchUncheckedCreateWithoutUserBInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutUserBInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutUserBInput, MatchUncheckedUpdateWithoutUserBInput>
  }

  export type MatchUpdateManyWithWhereWithoutUserBInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutUserBInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    matchId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    safetyScore?: IntNullableFilter<"Message"> | number | null
    safetyFlags?: StringNullableListFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
  }

  export type MessageUpdateManyWithWhereWithoutReceiverInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type TrustScoreUpsertWithoutUserInput = {
    update: XOR<TrustScoreUpdateWithoutUserInput, TrustScoreUncheckedUpdateWithoutUserInput>
    create: XOR<TrustScoreCreateWithoutUserInput, TrustScoreUncheckedCreateWithoutUserInput>
    where?: TrustScoreWhereInput
  }

  export type TrustScoreUpdateToOneWithWhereWithoutUserInput = {
    where?: TrustScoreWhereInput
    data: XOR<TrustScoreUpdateWithoutUserInput, TrustScoreUncheckedUpdateWithoutUserInput>
  }

  export type TrustScoreUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    replyPatternScore?: IntFieldUpdateOperationsInput | number
    commitmentScore?: IntFieldUpdateOperationsInput | number
    respectScore?: IntFieldUpdateOperationsInput | number
    toneConsistencyScore?: IntFieldUpdateOperationsInput | number
    lastCalculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustScoreUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    replyPatternScore?: IntFieldUpdateOperationsInput | number
    commitmentScore?: IntFieldUpdateOperationsInput | number
    respectScore?: IntFieldUpdateOperationsInput | number
    toneConsistencyScore?: IntFieldUpdateOperationsInput | number
    lastCalculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorLogUpsertWithWhereUniqueWithoutUserInput = {
    where: BehaviorLogWhereUniqueInput
    update: XOR<BehaviorLogUpdateWithoutUserInput, BehaviorLogUncheckedUpdateWithoutUserInput>
    create: XOR<BehaviorLogCreateWithoutUserInput, BehaviorLogUncheckedCreateWithoutUserInput>
  }

  export type BehaviorLogUpdateWithWhereUniqueWithoutUserInput = {
    where: BehaviorLogWhereUniqueInput
    data: XOR<BehaviorLogUpdateWithoutUserInput, BehaviorLogUncheckedUpdateWithoutUserInput>
  }

  export type BehaviorLogUpdateManyWithWhereWithoutUserInput = {
    where: BehaviorLogScalarWhereInput
    data: XOR<BehaviorLogUpdateManyMutationInput, BehaviorLogUncheckedUpdateManyWithoutUserInput>
  }

  export type BehaviorLogScalarWhereInput = {
    AND?: BehaviorLogScalarWhereInput | BehaviorLogScalarWhereInput[]
    OR?: BehaviorLogScalarWhereInput[]
    NOT?: BehaviorLogScalarWhereInput | BehaviorLogScalarWhereInput[]
    id?: StringFilter<"BehaviorLog"> | string
    userId?: StringFilter<"BehaviorLog"> | string
    behaviorType?: EnumBehaviorTypeFilter<"BehaviorLog"> | $Enums.BehaviorType
    metadata?: JsonNullableFilter<"BehaviorLog">
    score?: IntNullableFilter<"BehaviorLog"> | number | null
    createdAt?: DateTimeFilter<"BehaviorLog"> | Date | string
  }

  export type RiskAssessmentUpsertWithoutUserInput = {
    update: XOR<RiskAssessmentUpdateWithoutUserInput, RiskAssessmentUncheckedUpdateWithoutUserInput>
    create: XOR<RiskAssessmentCreateWithoutUserInput, RiskAssessmentUncheckedCreateWithoutUserInput>
    where?: RiskAssessmentWhereInput
  }

  export type RiskAssessmentUpdateToOneWithWhereWithoutUserInput = {
    where?: RiskAssessmentWhereInput
    data: XOR<RiskAssessmentUpdateWithoutUserInput, RiskAssessmentUncheckedUpdateWithoutUserInput>
  }

  export type RiskAssessmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskIndex?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    reportScore?: IntFieldUpdateOperationsInput | number
    messageRiskScore?: IntFieldUpdateOperationsInput | number
    patternRiskScore?: IntFieldUpdateOperationsInput | number
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    lastAssessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAssessmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    riskIndex?: IntFieldUpdateOperationsInput | number
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    reportScore?: IntFieldUpdateOperationsInput | number
    messageRiskScore?: IntFieldUpdateOperationsInput | number
    patternRiskScore?: IntFieldUpdateOperationsInput | number
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    restrictions?: NullableJsonNullValueInput | InputJsonValue
    lastAssessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutReporterInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReporterInput, ReportUncheckedUpdateWithoutReporterInput>
    create: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReporterInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReporterInput, ReportUncheckedUpdateWithoutReporterInput>
  }

  export type ReportUpdateManyWithWhereWithoutReporterInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReporterInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    reporterId?: StringFilter<"Report"> | string
    reportedUserId?: StringFilter<"Report"> | string
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    description?: StringNullableFilter<"Report"> | string | null
    evidence?: JsonNullableFilter<"Report">
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    reviewNotes?: StringNullableFilter<"Report"> | string | null
    reviewedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutReportedUserInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReportedUserInput, ReportUncheckedUpdateWithoutReportedUserInput>
    create: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReportedUserInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReportedUserInput, ReportUncheckedUpdateWithoutReportedUserInput>
  }

  export type ReportUpdateManyWithWhereWithoutReportedUserInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReportedUserInput>
  }

  export type SafetySignalUpsertWithWhereUniqueWithoutUserInput = {
    where: SafetySignalWhereUniqueInput
    update: XOR<SafetySignalUpdateWithoutUserInput, SafetySignalUncheckedUpdateWithoutUserInput>
    create: XOR<SafetySignalCreateWithoutUserInput, SafetySignalUncheckedCreateWithoutUserInput>
  }

  export type SafetySignalUpdateWithWhereUniqueWithoutUserInput = {
    where: SafetySignalWhereUniqueInput
    data: XOR<SafetySignalUpdateWithoutUserInput, SafetySignalUncheckedUpdateWithoutUserInput>
  }

  export type SafetySignalUpdateManyWithWhereWithoutUserInput = {
    where: SafetySignalScalarWhereInput
    data: XOR<SafetySignalUpdateManyMutationInput, SafetySignalUncheckedUpdateManyWithoutUserInput>
  }

  export type SafetySignalScalarWhereInput = {
    AND?: SafetySignalScalarWhereInput | SafetySignalScalarWhereInput[]
    OR?: SafetySignalScalarWhereInput[]
    NOT?: SafetySignalScalarWhereInput | SafetySignalScalarWhereInput[]
    id?: StringFilter<"SafetySignal"> | string
    userId?: StringFilter<"SafetySignal"> | string
    signalType?: EnumSafetySignalTypeFilter<"SafetySignal"> | $Enums.SafetySignalType
    verifiedAt?: DateTimeFilter<"SafetySignal"> | Date | string
    expiresAt?: DateTimeNullableFilter<"SafetySignal"> | Date | string | null
    createdAt?: DateTimeFilter<"SafetySignal"> | Date | string
  }

  export type VerificationUpsertWithWhereUniqueWithoutUserInput = {
    where: VerificationWhereUniqueInput
    update: XOR<VerificationUpdateWithoutUserInput, VerificationUncheckedUpdateWithoutUserInput>
    create: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput>
  }

  export type VerificationUpdateWithWhereUniqueWithoutUserInput = {
    where: VerificationWhereUniqueInput
    data: XOR<VerificationUpdateWithoutUserInput, VerificationUncheckedUpdateWithoutUserInput>
  }

  export type VerificationUpdateManyWithWhereWithoutUserInput = {
    where: VerificationScalarWhereInput
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyWithoutUserInput>
  }

  export type VerificationScalarWhereInput = {
    AND?: VerificationScalarWhereInput | VerificationScalarWhereInput[]
    OR?: VerificationScalarWhereInput[]
    NOT?: VerificationScalarWhereInput | VerificationScalarWhereInput[]
    id?: StringFilter<"Verification"> | string
    userId?: StringFilter<"Verification"> | string
    type?: StringFilter<"Verification"> | string
    status?: StringFilter<"Verification"> | string
    verificationData?: JsonNullableFilter<"Verification">
    verifiedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    createdAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type IntentHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: IntentHistoryWhereUniqueInput
    update: XOR<IntentHistoryUpdateWithoutUserInput, IntentHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<IntentHistoryCreateWithoutUserInput, IntentHistoryUncheckedCreateWithoutUserInput>
  }

  export type IntentHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: IntentHistoryWhereUniqueInput
    data: XOR<IntentHistoryUpdateWithoutUserInput, IntentHistoryUncheckedUpdateWithoutUserInput>
  }

  export type IntentHistoryUpdateManyWithWhereWithoutUserInput = {
    where: IntentHistoryScalarWhereInput
    data: XOR<IntentHistoryUpdateManyMutationInput, IntentHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type IntentHistoryScalarWhereInput = {
    AND?: IntentHistoryScalarWhereInput | IntentHistoryScalarWhereInput[]
    OR?: IntentHistoryScalarWhereInput[]
    NOT?: IntentHistoryScalarWhereInput | IntentHistoryScalarWhereInput[]
    id?: StringFilter<"IntentHistory"> | string
    userId?: StringFilter<"IntentHistory"> | string
    statedIntent?: EnumRelationshipIntentFilter<"IntentHistory"> | $Enums.RelationshipIntent
    behaviorIntent?: EnumRelationshipIntentNullableFilter<"IntentHistory"> | $Enums.RelationshipIntent | null
    confidence?: FloatFilter<"IntentHistory"> | number
    driftDetected?: BoolFilter<"IntentHistory"> | boolean
    createdAt?: DateTimeFilter<"IntentHistory"> | Date | string
  }

  export type BlockUpsertWithWhereUniqueWithoutBlockerInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutBlockerInput, BlockUncheckedUpdateWithoutBlockerInput>
    create: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutBlockerInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutBlockerInput, BlockUncheckedUpdateWithoutBlockerInput>
  }

  export type BlockUpdateManyWithWhereWithoutBlockerInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutBlockerInput>
  }

  export type BlockScalarWhereInput = {
    AND?: BlockScalarWhereInput | BlockScalarWhereInput[]
    OR?: BlockScalarWhereInput[]
    NOT?: BlockScalarWhereInput | BlockScalarWhereInput[]
    id?: StringFilter<"Block"> | string
    blockerId?: StringFilter<"Block"> | string
    blockedUserId?: StringFilter<"Block"> | string
    reason?: StringNullableFilter<"Block"> | string | null
    createdAt?: DateTimeFilter<"Block"> | Date | string
  }

  export type BlockUpsertWithWhereUniqueWithoutBlockedUserInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutBlockedUserInput, BlockUncheckedUpdateWithoutBlockedUserInput>
    create: XOR<BlockCreateWithoutBlockedUserInput, BlockUncheckedCreateWithoutBlockedUserInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutBlockedUserInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutBlockedUserInput, BlockUncheckedUpdateWithoutBlockedUserInput>
  }

  export type BlockUpdateManyWithWhereWithoutBlockedUserInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutBlockedUserInput>
  }

  export type ScheduledDateUpsertWithWhereUniqueWithoutSchedulerInput = {
    where: ScheduledDateWhereUniqueInput
    update: XOR<ScheduledDateUpdateWithoutSchedulerInput, ScheduledDateUncheckedUpdateWithoutSchedulerInput>
    create: XOR<ScheduledDateCreateWithoutSchedulerInput, ScheduledDateUncheckedCreateWithoutSchedulerInput>
  }

  export type ScheduledDateUpdateWithWhereUniqueWithoutSchedulerInput = {
    where: ScheduledDateWhereUniqueInput
    data: XOR<ScheduledDateUpdateWithoutSchedulerInput, ScheduledDateUncheckedUpdateWithoutSchedulerInput>
  }

  export type ScheduledDateUpdateManyWithWhereWithoutSchedulerInput = {
    where: ScheduledDateScalarWhereInput
    data: XOR<ScheduledDateUpdateManyMutationInput, ScheduledDateUncheckedUpdateManyWithoutSchedulerInput>
  }

  export type ScheduledDateScalarWhereInput = {
    AND?: ScheduledDateScalarWhereInput | ScheduledDateScalarWhereInput[]
    OR?: ScheduledDateScalarWhereInput[]
    NOT?: ScheduledDateScalarWhereInput | ScheduledDateScalarWhereInput[]
    id?: StringFilter<"ScheduledDate"> | string
    matchId?: StringFilter<"ScheduledDate"> | string
    schedulerId?: StringFilter<"ScheduledDate"> | string
    partnerId?: StringFilter<"ScheduledDate"> | string
    dateTime?: DateTimeFilter<"ScheduledDate"> | Date | string
    location?: StringNullableFilter<"ScheduledDate"> | string | null
    isPublicPlace?: BoolFilter<"ScheduledDate"> | boolean
    safetyCheckIn?: BoolFilter<"ScheduledDate"> | boolean
    checkInTime?: DateTimeNullableFilter<"ScheduledDate"> | Date | string | null
    locationSharing?: BoolFilter<"ScheduledDate"> | boolean
    safetyScore?: IntNullableFilter<"ScheduledDate"> | number | null
    concerns?: StringNullableListFilter<"ScheduledDate">
    suggestions?: StringNullableListFilter<"ScheduledDate">
    status?: StringFilter<"ScheduledDate"> | string
    createdAt?: DateTimeFilter<"ScheduledDate"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledDate"> | Date | string
  }

  export type ScheduledDateUpsertWithWhereUniqueWithoutPartnerInput = {
    where: ScheduledDateWhereUniqueInput
    update: XOR<ScheduledDateUpdateWithoutPartnerInput, ScheduledDateUncheckedUpdateWithoutPartnerInput>
    create: XOR<ScheduledDateCreateWithoutPartnerInput, ScheduledDateUncheckedCreateWithoutPartnerInput>
  }

  export type ScheduledDateUpdateWithWhereUniqueWithoutPartnerInput = {
    where: ScheduledDateWhereUniqueInput
    data: XOR<ScheduledDateUpdateWithoutPartnerInput, ScheduledDateUncheckedUpdateWithoutPartnerInput>
  }

  export type ScheduledDateUpdateManyWithWhereWithoutPartnerInput = {
    where: ScheduledDateScalarWhereInput
    data: XOR<ScheduledDateUpdateManyMutationInput, ScheduledDateUncheckedUpdateManyWithoutPartnerInput>
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type PhotoCreateWithoutProfileInput = {
    id?: string
    url: string
    isMain?: boolean
    isVerified?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type PhotoUncheckedCreateWithoutProfileInput = {
    id?: string
    url: string
    isMain?: boolean
    isVerified?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type PhotoCreateOrConnectWithoutProfileInput = {
    where: PhotoWhereUniqueInput
    create: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput>
  }

  export type PhotoCreateManyProfileInputEnvelope = {
    data: PhotoCreateManyProfileInput | PhotoCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProfilePromptCreateWithoutProfileInput = {
    id?: string
    question: string
    answer: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfilePromptUncheckedCreateWithoutProfileInput = {
    id?: string
    question: string
    answer: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfilePromptCreateOrConnectWithoutProfileInput = {
    where: ProfilePromptWhereUniqueInput
    create: XOR<ProfilePromptCreateWithoutProfileInput, ProfilePromptUncheckedCreateWithoutProfileInput>
  }

  export type ProfilePromptCreateManyProfileInputEnvelope = {
    data: ProfilePromptCreateManyProfileInput | ProfilePromptCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type PhotoUpsertWithWhereUniqueWithoutProfileInput = {
    where: PhotoWhereUniqueInput
    update: XOR<PhotoUpdateWithoutProfileInput, PhotoUncheckedUpdateWithoutProfileInput>
    create: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput>
  }

  export type PhotoUpdateWithWhereUniqueWithoutProfileInput = {
    where: PhotoWhereUniqueInput
    data: XOR<PhotoUpdateWithoutProfileInput, PhotoUncheckedUpdateWithoutProfileInput>
  }

  export type PhotoUpdateManyWithWhereWithoutProfileInput = {
    where: PhotoScalarWhereInput
    data: XOR<PhotoUpdateManyMutationInput, PhotoUncheckedUpdateManyWithoutProfileInput>
  }

  export type PhotoScalarWhereInput = {
    AND?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
    OR?: PhotoScalarWhereInput[]
    NOT?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
    id?: StringFilter<"Photo"> | string
    profileId?: StringFilter<"Photo"> | string
    url?: StringFilter<"Photo"> | string
    isMain?: BoolFilter<"Photo"> | boolean
    isVerified?: BoolFilter<"Photo"> | boolean
    order?: IntFilter<"Photo"> | number
    createdAt?: DateTimeFilter<"Photo"> | Date | string
  }

  export type ProfilePromptUpsertWithWhereUniqueWithoutProfileInput = {
    where: ProfilePromptWhereUniqueInput
    update: XOR<ProfilePromptUpdateWithoutProfileInput, ProfilePromptUncheckedUpdateWithoutProfileInput>
    create: XOR<ProfilePromptCreateWithoutProfileInput, ProfilePromptUncheckedCreateWithoutProfileInput>
  }

  export type ProfilePromptUpdateWithWhereUniqueWithoutProfileInput = {
    where: ProfilePromptWhereUniqueInput
    data: XOR<ProfilePromptUpdateWithoutProfileInput, ProfilePromptUncheckedUpdateWithoutProfileInput>
  }

  export type ProfilePromptUpdateManyWithWhereWithoutProfileInput = {
    where: ProfilePromptScalarWhereInput
    data: XOR<ProfilePromptUpdateManyMutationInput, ProfilePromptUncheckedUpdateManyWithoutProfileInput>
  }

  export type ProfilePromptScalarWhereInput = {
    AND?: ProfilePromptScalarWhereInput | ProfilePromptScalarWhereInput[]
    OR?: ProfilePromptScalarWhereInput[]
    NOT?: ProfilePromptScalarWhereInput | ProfilePromptScalarWhereInput[]
    id?: StringFilter<"ProfilePrompt"> | string
    profileId?: StringFilter<"ProfilePrompt"> | string
    question?: StringFilter<"ProfilePrompt"> | string
    answer?: StringFilter<"ProfilePrompt"> | string
    order?: IntFilter<"ProfilePrompt"> | number
    createdAt?: DateTimeFilter<"ProfilePrompt"> | Date | string
    updatedAt?: DateTimeFilter<"ProfilePrompt"> | Date | string
  }

  export type ProfileCreateWithoutPhotosInput = {
    id?: string
    firstName: string
    displayName?: string | null
    birthDate: Date | string
    gender: $Enums.Gender
    genderPreferences?: ProfileCreategenderPreferencesInput | $Enums.Gender[]
    city?: string | null
    state?: string | null
    country?: string | null
    latitude?: number | null
    longitude?: number | null
    bio?: string | null
    height?: number | null
    relationshipIntent?: $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: number
    completenessScore?: number
    specificityScore?: number
    consistencyScore?: number
    stabilityScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    prompts?: ProfilePromptCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutPhotosInput = {
    id?: string
    userId: string
    firstName: string
    displayName?: string | null
    birthDate: Date | string
    gender: $Enums.Gender
    genderPreferences?: ProfileCreategenderPreferencesInput | $Enums.Gender[]
    city?: string | null
    state?: string | null
    country?: string | null
    latitude?: number | null
    longitude?: number | null
    bio?: string | null
    height?: number | null
    relationshipIntent?: $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: number
    completenessScore?: number
    specificityScore?: number
    consistencyScore?: number
    stabilityScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prompts?: ProfilePromptUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutPhotosInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutPhotosInput, ProfileUncheckedCreateWithoutPhotosInput>
  }

  export type ProfileUpsertWithoutPhotosInput = {
    update: XOR<ProfileUpdateWithoutPhotosInput, ProfileUncheckedUpdateWithoutPhotosInput>
    create: XOR<ProfileCreateWithoutPhotosInput, ProfileUncheckedCreateWithoutPhotosInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutPhotosInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutPhotosInput, ProfileUncheckedUpdateWithoutPhotosInput>
  }

  export type ProfileUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    genderPreferences?: ProfileUpdategenderPreferencesInput | $Enums.Gender[]
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipIntent?: NullableEnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    specificityScore?: IntFieldUpdateOperationsInput | number
    consistencyScore?: IntFieldUpdateOperationsInput | number
    stabilityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    prompts?: ProfilePromptUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    genderPreferences?: ProfileUpdategenderPreferencesInput | $Enums.Gender[]
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipIntent?: NullableEnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    specificityScore?: IntFieldUpdateOperationsInput | number
    consistencyScore?: IntFieldUpdateOperationsInput | number
    stabilityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompts?: ProfilePromptUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateWithoutPromptsInput = {
    id?: string
    firstName: string
    displayName?: string | null
    birthDate: Date | string
    gender: $Enums.Gender
    genderPreferences?: ProfileCreategenderPreferencesInput | $Enums.Gender[]
    city?: string | null
    state?: string | null
    country?: string | null
    latitude?: number | null
    longitude?: number | null
    bio?: string | null
    height?: number | null
    relationshipIntent?: $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: number
    completenessScore?: number
    specificityScore?: number
    consistencyScore?: number
    stabilityScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    photos?: PhotoCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutPromptsInput = {
    id?: string
    userId: string
    firstName: string
    displayName?: string | null
    birthDate: Date | string
    gender: $Enums.Gender
    genderPreferences?: ProfileCreategenderPreferencesInput | $Enums.Gender[]
    city?: string | null
    state?: string | null
    country?: string | null
    latitude?: number | null
    longitude?: number | null
    bio?: string | null
    height?: number | null
    relationshipIntent?: $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: number
    completenessScore?: number
    specificityScore?: number
    consistencyScore?: number
    stabilityScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutPromptsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutPromptsInput, ProfileUncheckedCreateWithoutPromptsInput>
  }

  export type ProfileUpsertWithoutPromptsInput = {
    update: XOR<ProfileUpdateWithoutPromptsInput, ProfileUncheckedUpdateWithoutPromptsInput>
    create: XOR<ProfileCreateWithoutPromptsInput, ProfileUncheckedCreateWithoutPromptsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutPromptsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutPromptsInput, ProfileUncheckedUpdateWithoutPromptsInput>
  }

  export type ProfileUpdateWithoutPromptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    genderPreferences?: ProfileUpdategenderPreferencesInput | $Enums.Gender[]
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipIntent?: NullableEnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    specificityScore?: IntFieldUpdateOperationsInput | number
    consistencyScore?: IntFieldUpdateOperationsInput | number
    stabilityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    photos?: PhotoUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutPromptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    genderPreferences?: ProfileUpdategenderPreferencesInput | $Enums.Gender[]
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipIntent?: NullableEnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent | null
    values?: NullableJsonNullValueInput | InputJsonValue
    lifestyle?: NullableJsonNullValueInput | InputJsonValue
    dealbreakers?: NullableJsonNullValueInput | InputJsonValue
    profileStrengthScore?: IntFieldUpdateOperationsInput | number
    completenessScore?: IntFieldUpdateOperationsInput | number
    specificityScore?: IntFieldUpdateOperationsInput | number
    consistencyScore?: IntFieldUpdateOperationsInput | number
    stabilityScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type OnboardingAnswerCreateWithoutQuestionInput = {
    id?: string
    answer: JsonNullValueInput | InputJsonValue
    followUpCount?: number
    confidence?: number | null
    consistency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOnboardingAnswersInput
  }

  export type OnboardingAnswerUncheckedCreateWithoutQuestionInput = {
    id?: string
    userId: string
    answer: JsonNullValueInput | InputJsonValue
    followUpCount?: number
    confidence?: number | null
    consistency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnboardingAnswerCreateOrConnectWithoutQuestionInput = {
    where: OnboardingAnswerWhereUniqueInput
    create: XOR<OnboardingAnswerCreateWithoutQuestionInput, OnboardingAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type OnboardingAnswerCreateManyQuestionInputEnvelope = {
    data: OnboardingAnswerCreateManyQuestionInput | OnboardingAnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type OnboardingAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: OnboardingAnswerWhereUniqueInput
    update: XOR<OnboardingAnswerUpdateWithoutQuestionInput, OnboardingAnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<OnboardingAnswerCreateWithoutQuestionInput, OnboardingAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type OnboardingAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: OnboardingAnswerWhereUniqueInput
    data: XOR<OnboardingAnswerUpdateWithoutQuestionInput, OnboardingAnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type OnboardingAnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: OnboardingAnswerScalarWhereInput
    data: XOR<OnboardingAnswerUpdateManyMutationInput, OnboardingAnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type UserCreateWithoutOnboardingAnswersInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutOnboardingAnswersInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutOnboardingAnswersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOnboardingAnswersInput, UserUncheckedCreateWithoutOnboardingAnswersInput>
  }

  export type OnboardingQuestionCreateWithoutAnswersInput = {
    id?: string
    category: $Enums.QuestionCategory
    questionText: string
    questionType: $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    followUpLogic?: NullableJsonNullValueInput | InputJsonValue
    order: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type OnboardingQuestionUncheckedCreateWithoutAnswersInput = {
    id?: string
    category: $Enums.QuestionCategory
    questionText: string
    questionType: $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    followUpLogic?: NullableJsonNullValueInput | InputJsonValue
    order: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type OnboardingQuestionCreateOrConnectWithoutAnswersInput = {
    where: OnboardingQuestionWhereUniqueInput
    create: XOR<OnboardingQuestionCreateWithoutAnswersInput, OnboardingQuestionUncheckedCreateWithoutAnswersInput>
  }

  export type UserUpsertWithoutOnboardingAnswersInput = {
    update: XOR<UserUpdateWithoutOnboardingAnswersInput, UserUncheckedUpdateWithoutOnboardingAnswersInput>
    create: XOR<UserCreateWithoutOnboardingAnswersInput, UserUncheckedCreateWithoutOnboardingAnswersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOnboardingAnswersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOnboardingAnswersInput, UserUncheckedUpdateWithoutOnboardingAnswersInput>
  }

  export type UserUpdateWithoutOnboardingAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutOnboardingAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type OnboardingQuestionUpsertWithoutAnswersInput = {
    update: XOR<OnboardingQuestionUpdateWithoutAnswersInput, OnboardingQuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<OnboardingQuestionCreateWithoutAnswersInput, OnboardingQuestionUncheckedCreateWithoutAnswersInput>
    where?: OnboardingQuestionWhereInput
  }

  export type OnboardingQuestionUpdateToOneWithWhereWithoutAnswersInput = {
    where?: OnboardingQuestionWhereInput
    data: XOR<OnboardingQuestionUpdateWithoutAnswersInput, OnboardingQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type OnboardingQuestionUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumQuestionCategoryFieldUpdateOperationsInput | $Enums.QuestionCategory
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    followUpLogic?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingQuestionUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumQuestionCategoryFieldUpdateOperationsInput | $Enums.QuestionCategory
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    options?: NullableJsonNullValueInput | InputJsonValue
    followUpLogic?: NullableJsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutLikesGivenInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutLikesGivenInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutLikesGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikesGivenInput, UserUncheckedCreateWithoutLikesGivenInput>
  }

  export type UserCreateWithoutLikesReceivedInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutLikesReceivedInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutLikesReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikesReceivedInput, UserUncheckedCreateWithoutLikesReceivedInput>
  }

  export type UserUpsertWithoutLikesGivenInput = {
    update: XOR<UserUpdateWithoutLikesGivenInput, UserUncheckedUpdateWithoutLikesGivenInput>
    create: XOR<UserCreateWithoutLikesGivenInput, UserUncheckedCreateWithoutLikesGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikesGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikesGivenInput, UserUncheckedUpdateWithoutLikesGivenInput>
  }

  export type UserUpdateWithoutLikesGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutLikesGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserUpsertWithoutLikesReceivedInput = {
    update: XOR<UserUpdateWithoutLikesReceivedInput, UserUncheckedUpdateWithoutLikesReceivedInput>
    create: XOR<UserCreateWithoutLikesReceivedInput, UserUncheckedCreateWithoutLikesReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikesReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikesReceivedInput, UserUncheckedUpdateWithoutLikesReceivedInput>
  }

  export type UserUpdateWithoutLikesReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutLikesReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserCreateWithoutMatchesAsUserAInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutMatchesAsUserAInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutMatchesAsUserAInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMatchesAsUserAInput, UserUncheckedCreateWithoutMatchesAsUserAInput>
  }

  export type UserCreateWithoutMatchesAsUserBInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutMatchesAsUserBInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutMatchesAsUserBInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMatchesAsUserBInput, UserUncheckedCreateWithoutMatchesAsUserBInput>
  }

  export type MessageCreateWithoutMatchInput = {
    id?: string
    content: string
    status?: $Enums.MessageStatus
    safetyScore?: number | null
    safetyFlags?: MessageCreatesafetyFlagsInput | string[]
    createdAt?: Date | string
    readAt?: Date | string | null
    sender: UserCreateNestedOneWithoutMessagesSentInput
    receiver: UserCreateNestedOneWithoutMessagesReceivedInput
  }

  export type MessageUncheckedCreateWithoutMatchInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    status?: $Enums.MessageStatus
    safetyScore?: number | null
    safetyFlags?: MessageCreatesafetyFlagsInput | string[]
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type MessageCreateOrConnectWithoutMatchInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutMatchInput, MessageUncheckedCreateWithoutMatchInput>
  }

  export type MessageCreateManyMatchInputEnvelope = {
    data: MessageCreateManyMatchInput | MessageCreateManyMatchInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledDateCreateWithoutMatchInput = {
    id?: string
    dateTime: Date | string
    location?: string | null
    isPublicPlace?: boolean
    safetyCheckIn?: boolean
    checkInTime?: Date | string | null
    locationSharing?: boolean
    safetyScore?: number | null
    concerns?: ScheduledDateCreateconcernsInput | string[]
    suggestions?: ScheduledDateCreatesuggestionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    scheduler: UserCreateNestedOneWithoutScheduledDatesInput
    partner: UserCreateNestedOneWithoutDatesAsPartnerInput
  }

  export type ScheduledDateUncheckedCreateWithoutMatchInput = {
    id?: string
    schedulerId: string
    partnerId: string
    dateTime: Date | string
    location?: string | null
    isPublicPlace?: boolean
    safetyCheckIn?: boolean
    checkInTime?: Date | string | null
    locationSharing?: boolean
    safetyScore?: number | null
    concerns?: ScheduledDateCreateconcernsInput | string[]
    suggestions?: ScheduledDateCreatesuggestionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledDateCreateOrConnectWithoutMatchInput = {
    where: ScheduledDateWhereUniqueInput
    create: XOR<ScheduledDateCreateWithoutMatchInput, ScheduledDateUncheckedCreateWithoutMatchInput>
  }

  export type ScheduledDateCreateManyMatchInputEnvelope = {
    data: ScheduledDateCreateManyMatchInput | ScheduledDateCreateManyMatchInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMatchesAsUserAInput = {
    update: XOR<UserUpdateWithoutMatchesAsUserAInput, UserUncheckedUpdateWithoutMatchesAsUserAInput>
    create: XOR<UserCreateWithoutMatchesAsUserAInput, UserUncheckedCreateWithoutMatchesAsUserAInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMatchesAsUserAInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMatchesAsUserAInput, UserUncheckedUpdateWithoutMatchesAsUserAInput>
  }

  export type UserUpdateWithoutMatchesAsUserAInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutMatchesAsUserAInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserUpsertWithoutMatchesAsUserBInput = {
    update: XOR<UserUpdateWithoutMatchesAsUserBInput, UserUncheckedUpdateWithoutMatchesAsUserBInput>
    create: XOR<UserCreateWithoutMatchesAsUserBInput, UserUncheckedCreateWithoutMatchesAsUserBInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMatchesAsUserBInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMatchesAsUserBInput, UserUncheckedUpdateWithoutMatchesAsUserBInput>
  }

  export type UserUpdateWithoutMatchesAsUserBInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutMatchesAsUserBInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutMatchInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutMatchInput, MessageUncheckedUpdateWithoutMatchInput>
    create: XOR<MessageCreateWithoutMatchInput, MessageUncheckedCreateWithoutMatchInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutMatchInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutMatchInput, MessageUncheckedUpdateWithoutMatchInput>
  }

  export type MessageUpdateManyWithWhereWithoutMatchInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutMatchInput>
  }

  export type ScheduledDateUpsertWithWhereUniqueWithoutMatchInput = {
    where: ScheduledDateWhereUniqueInput
    update: XOR<ScheduledDateUpdateWithoutMatchInput, ScheduledDateUncheckedUpdateWithoutMatchInput>
    create: XOR<ScheduledDateCreateWithoutMatchInput, ScheduledDateUncheckedCreateWithoutMatchInput>
  }

  export type ScheduledDateUpdateWithWhereUniqueWithoutMatchInput = {
    where: ScheduledDateWhereUniqueInput
    data: XOR<ScheduledDateUpdateWithoutMatchInput, ScheduledDateUncheckedUpdateWithoutMatchInput>
  }

  export type ScheduledDateUpdateManyWithWhereWithoutMatchInput = {
    where: ScheduledDateScalarWhereInput
    data: XOR<ScheduledDateUpdateManyMutationInput, ScheduledDateUncheckedUpdateManyWithoutMatchInput>
  }

  export type MatchCreateWithoutMessagesInput = {
    id?: string
    overallScore?: number
    valuesScore?: number
    lifestyleScore?: number
    intentScore?: number
    communicationScore?: number
    logisticsScore?: number
    topReasons?: MatchCreatetopReasonsInput | string[]
    frictionPoint?: string | null
    confidenceLevel?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userA: UserCreateNestedOneWithoutMatchesAsUserAInput
    userB: UserCreateNestedOneWithoutMatchesAsUserBInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutMessagesInput = {
    id?: string
    userAId: string
    userBId: string
    overallScore?: number
    valuesScore?: number
    lifestyleScore?: number
    intentScore?: number
    communicationScore?: number
    logisticsScore?: number
    topReasons?: MatchCreatetopReasonsInput | string[]
    frictionPoint?: string | null
    confidenceLevel?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutMessagesInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutMessagesInput, MatchUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesSentInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutMessagesSentInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutMessagesSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
  }

  export type UserCreateWithoutMessagesReceivedInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutMessagesReceivedInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutMessagesReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
  }

  export type MatchUpsertWithoutMessagesInput = {
    update: XOR<MatchUpdateWithoutMessagesInput, MatchUncheckedUpdateWithoutMessagesInput>
    create: XOR<MatchCreateWithoutMessagesInput, MatchUncheckedCreateWithoutMessagesInput>
    where?: MatchWhereInput
  }

  export type MatchUpdateToOneWithWhereWithoutMessagesInput = {
    where?: MatchWhereInput
    data: XOR<MatchUpdateWithoutMessagesInput, MatchUncheckedUpdateWithoutMessagesInput>
  }

  export type MatchUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    valuesScore?: IntFieldUpdateOperationsInput | number
    lifestyleScore?: IntFieldUpdateOperationsInput | number
    intentScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    logisticsScore?: IntFieldUpdateOperationsInput | number
    topReasons?: MatchUpdatetopReasonsInput | string[]
    frictionPoint?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userA?: UserUpdateOneRequiredWithoutMatchesAsUserANestedInput
    userB?: UserUpdateOneRequiredWithoutMatchesAsUserBNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    valuesScore?: IntFieldUpdateOperationsInput | number
    lifestyleScore?: IntFieldUpdateOperationsInput | number
    intentScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    logisticsScore?: IntFieldUpdateOperationsInput | number
    topReasons?: MatchUpdatetopReasonsInput | string[]
    frictionPoint?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type UserUpsertWithoutMessagesSentInput = {
    update: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UserUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserUpsertWithoutMessagesReceivedInput = {
    update: XOR<UserUpdateWithoutMessagesReceivedInput, UserUncheckedUpdateWithoutMessagesReceivedInput>
    create: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesReceivedInput, UserUncheckedUpdateWithoutMessagesReceivedInput>
  }

  export type UserUpdateWithoutMessagesReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserCreateWithoutTrustScoreInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutTrustScoreInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutTrustScoreInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrustScoreInput, UserUncheckedCreateWithoutTrustScoreInput>
  }

  export type UserUpsertWithoutTrustScoreInput = {
    update: XOR<UserUpdateWithoutTrustScoreInput, UserUncheckedUpdateWithoutTrustScoreInput>
    create: XOR<UserCreateWithoutTrustScoreInput, UserUncheckedCreateWithoutTrustScoreInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTrustScoreInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTrustScoreInput, UserUncheckedUpdateWithoutTrustScoreInput>
  }

  export type UserUpdateWithoutTrustScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutTrustScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserCreateWithoutBehaviorLogsInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutBehaviorLogsInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutBehaviorLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBehaviorLogsInput, UserUncheckedCreateWithoutBehaviorLogsInput>
  }

  export type UserUpsertWithoutBehaviorLogsInput = {
    update: XOR<UserUpdateWithoutBehaviorLogsInput, UserUncheckedUpdateWithoutBehaviorLogsInput>
    create: XOR<UserCreateWithoutBehaviorLogsInput, UserUncheckedCreateWithoutBehaviorLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBehaviorLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBehaviorLogsInput, UserUncheckedUpdateWithoutBehaviorLogsInput>
  }

  export type UserUpdateWithoutBehaviorLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutBehaviorLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserCreateWithoutRiskAssessmentInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutRiskAssessmentInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutRiskAssessmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRiskAssessmentInput, UserUncheckedCreateWithoutRiskAssessmentInput>
  }

  export type UserUpsertWithoutRiskAssessmentInput = {
    update: XOR<UserUpdateWithoutRiskAssessmentInput, UserUncheckedUpdateWithoutRiskAssessmentInput>
    create: XOR<UserCreateWithoutRiskAssessmentInput, UserUncheckedCreateWithoutRiskAssessmentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRiskAssessmentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRiskAssessmentInput, UserUncheckedUpdateWithoutRiskAssessmentInput>
  }

  export type UserUpdateWithoutRiskAssessmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutRiskAssessmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserCreateWithoutReportsFiledInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutReportsFiledInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutReportsFiledInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsFiledInput, UserUncheckedCreateWithoutReportsFiledInput>
  }

  export type UserCreateWithoutReportsReceivedInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutReportsReceivedInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutReportsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsReceivedInput, UserUncheckedCreateWithoutReportsReceivedInput>
  }

  export type UserUpsertWithoutReportsFiledInput = {
    update: XOR<UserUpdateWithoutReportsFiledInput, UserUncheckedUpdateWithoutReportsFiledInput>
    create: XOR<UserCreateWithoutReportsFiledInput, UserUncheckedCreateWithoutReportsFiledInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsFiledInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsFiledInput, UserUncheckedUpdateWithoutReportsFiledInput>
  }

  export type UserUpdateWithoutReportsFiledInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsFiledInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserUpsertWithoutReportsReceivedInput = {
    update: XOR<UserUpdateWithoutReportsReceivedInput, UserUncheckedUpdateWithoutReportsReceivedInput>
    create: XOR<UserCreateWithoutReportsReceivedInput, UserUncheckedCreateWithoutReportsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsReceivedInput, UserUncheckedUpdateWithoutReportsReceivedInput>
  }

  export type UserUpdateWithoutReportsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserCreateWithoutSafetySignalsInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutSafetySignalsInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutSafetySignalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSafetySignalsInput, UserUncheckedCreateWithoutSafetySignalsInput>
  }

  export type UserUpsertWithoutSafetySignalsInput = {
    update: XOR<UserUpdateWithoutSafetySignalsInput, UserUncheckedUpdateWithoutSafetySignalsInput>
    create: XOR<UserCreateWithoutSafetySignalsInput, UserUncheckedCreateWithoutSafetySignalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSafetySignalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSafetySignalsInput, UserUncheckedUpdateWithoutSafetySignalsInput>
  }

  export type UserUpdateWithoutSafetySignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutSafetySignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserCreateWithoutVerificationsInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutVerificationsInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutVerificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerificationsInput, UserUncheckedCreateWithoutVerificationsInput>
  }

  export type UserUpsertWithoutVerificationsInput = {
    update: XOR<UserUpdateWithoutVerificationsInput, UserUncheckedUpdateWithoutVerificationsInput>
    create: XOR<UserCreateWithoutVerificationsInput, UserUncheckedCreateWithoutVerificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerificationsInput, UserUncheckedUpdateWithoutVerificationsInput>
  }

  export type UserUpdateWithoutVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserCreateWithoutBlocksCreatedInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutBlocksCreatedInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutBlocksCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlocksCreatedInput, UserUncheckedCreateWithoutBlocksCreatedInput>
  }

  export type UserCreateWithoutBlocksReceivedInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutBlocksReceivedInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutBlocksReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlocksReceivedInput, UserUncheckedCreateWithoutBlocksReceivedInput>
  }

  export type UserUpsertWithoutBlocksCreatedInput = {
    update: XOR<UserUpdateWithoutBlocksCreatedInput, UserUncheckedUpdateWithoutBlocksCreatedInput>
    create: XOR<UserCreateWithoutBlocksCreatedInput, UserUncheckedCreateWithoutBlocksCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlocksCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlocksCreatedInput, UserUncheckedUpdateWithoutBlocksCreatedInput>
  }

  export type UserUpdateWithoutBlocksCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutBlocksCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserUpsertWithoutBlocksReceivedInput = {
    update: XOR<UserUpdateWithoutBlocksReceivedInput, UserUncheckedUpdateWithoutBlocksReceivedInput>
    create: XOR<UserCreateWithoutBlocksReceivedInput, UserUncheckedCreateWithoutBlocksReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlocksReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlocksReceivedInput, UserUncheckedUpdateWithoutBlocksReceivedInput>
  }

  export type UserUpdateWithoutBlocksReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutBlocksReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserCreateWithoutIntentHistoryInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutIntentHistoryInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutIntentHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIntentHistoryInput, UserUncheckedCreateWithoutIntentHistoryInput>
  }

  export type UserUpsertWithoutIntentHistoryInput = {
    update: XOR<UserUpdateWithoutIntentHistoryInput, UserUncheckedUpdateWithoutIntentHistoryInput>
    create: XOR<UserCreateWithoutIntentHistoryInput, UserUncheckedCreateWithoutIntentHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIntentHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIntentHistoryInput, UserUncheckedUpdateWithoutIntentHistoryInput>
  }

  export type UserUpdateWithoutIntentHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutIntentHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type MatchCreateWithoutScheduledDatesInput = {
    id?: string
    overallScore?: number
    valuesScore?: number
    lifestyleScore?: number
    intentScore?: number
    communicationScore?: number
    logisticsScore?: number
    topReasons?: MatchCreatetopReasonsInput | string[]
    frictionPoint?: string | null
    confidenceLevel?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userA: UserCreateNestedOneWithoutMatchesAsUserAInput
    userB: UserCreateNestedOneWithoutMatchesAsUserBInput
    messages?: MessageCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutScheduledDatesInput = {
    id?: string
    userAId: string
    userBId: string
    overallScore?: number
    valuesScore?: number
    lifestyleScore?: number
    intentScore?: number
    communicationScore?: number
    logisticsScore?: number
    topReasons?: MatchCreatetopReasonsInput | string[]
    frictionPoint?: string | null
    confidenceLevel?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutScheduledDatesInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutScheduledDatesInput, MatchUncheckedCreateWithoutScheduledDatesInput>
  }

  export type UserCreateWithoutScheduledDatesInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    datesAsPartner?: ScheduledDateCreateNestedManyWithoutPartnerInput
  }

  export type UserUncheckedCreateWithoutScheduledDatesInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    datesAsPartner?: ScheduledDateUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type UserCreateOrConnectWithoutScheduledDatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutScheduledDatesInput, UserUncheckedCreateWithoutScheduledDatesInput>
  }

  export type UserCreateWithoutDatesAsPartnerInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerCreateNestedManyWithoutUserInput
    likesGiven?: LikeCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchCreateNestedManyWithoutUserBInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentCreateNestedOneWithoutUserInput
    reportsFiled?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalCreateNestedManyWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryCreateNestedManyWithoutUserInput
    blocksCreated?: BlockCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateCreateNestedManyWithoutSchedulerInput
  }

  export type UserUncheckedCreateWithoutDatesAsPartnerInput = {
    id?: string
    email: string
    passwordHash: string
    status?: $Enums.UserStatus
    onboardingCompleted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    onboardingAnswers?: OnboardingAnswerUncheckedCreateNestedManyWithoutUserInput
    likesGiven?: LikeUncheckedCreateNestedManyWithoutFromUserInput
    likesReceived?: LikeUncheckedCreateNestedManyWithoutToUserInput
    matchesAsUserA?: MatchUncheckedCreateNestedManyWithoutUserAInput
    matchesAsUserB?: MatchUncheckedCreateNestedManyWithoutUserBInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    trustScore?: TrustScoreUncheckedCreateNestedOneWithoutUserInput
    behaviorLogs?: BehaviorLogUncheckedCreateNestedManyWithoutUserInput
    riskAssessment?: RiskAssessmentUncheckedCreateNestedOneWithoutUserInput
    reportsFiled?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    safetySignals?: SafetySignalUncheckedCreateNestedManyWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    intentHistory?: IntentHistoryUncheckedCreateNestedManyWithoutUserInput
    blocksCreated?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksReceived?: BlockUncheckedCreateNestedManyWithoutBlockedUserInput
    scheduledDates?: ScheduledDateUncheckedCreateNestedManyWithoutSchedulerInput
  }

  export type UserCreateOrConnectWithoutDatesAsPartnerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDatesAsPartnerInput, UserUncheckedCreateWithoutDatesAsPartnerInput>
  }

  export type MatchUpsertWithoutScheduledDatesInput = {
    update: XOR<MatchUpdateWithoutScheduledDatesInput, MatchUncheckedUpdateWithoutScheduledDatesInput>
    create: XOR<MatchCreateWithoutScheduledDatesInput, MatchUncheckedCreateWithoutScheduledDatesInput>
    where?: MatchWhereInput
  }

  export type MatchUpdateToOneWithWhereWithoutScheduledDatesInput = {
    where?: MatchWhereInput
    data: XOR<MatchUpdateWithoutScheduledDatesInput, MatchUncheckedUpdateWithoutScheduledDatesInput>
  }

  export type MatchUpdateWithoutScheduledDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    valuesScore?: IntFieldUpdateOperationsInput | number
    lifestyleScore?: IntFieldUpdateOperationsInput | number
    intentScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    logisticsScore?: IntFieldUpdateOperationsInput | number
    topReasons?: MatchUpdatetopReasonsInput | string[]
    frictionPoint?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userA?: UserUpdateOneRequiredWithoutMatchesAsUserANestedInput
    userB?: UserUpdateOneRequiredWithoutMatchesAsUserBNestedInput
    messages?: MessageUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutScheduledDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    valuesScore?: IntFieldUpdateOperationsInput | number
    lifestyleScore?: IntFieldUpdateOperationsInput | number
    intentScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    logisticsScore?: IntFieldUpdateOperationsInput | number
    topReasons?: MatchUpdatetopReasonsInput | string[]
    frictionPoint?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type UserUpsertWithoutScheduledDatesInput = {
    update: XOR<UserUpdateWithoutScheduledDatesInput, UserUncheckedUpdateWithoutScheduledDatesInput>
    create: XOR<UserCreateWithoutScheduledDatesInput, UserUncheckedCreateWithoutScheduledDatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutScheduledDatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutScheduledDatesInput, UserUncheckedUpdateWithoutScheduledDatesInput>
  }

  export type UserUpdateWithoutScheduledDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    datesAsPartner?: ScheduledDateUpdateManyWithoutPartnerNestedInput
  }

  export type UserUncheckedUpdateWithoutScheduledDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    datesAsPartner?: ScheduledDateUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserUpsertWithoutDatesAsPartnerInput = {
    update: XOR<UserUpdateWithoutDatesAsPartnerInput, UserUncheckedUpdateWithoutDatesAsPartnerInput>
    create: XOR<UserCreateWithoutDatesAsPartnerInput, UserUncheckedCreateWithoutDatesAsPartnerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDatesAsPartnerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDatesAsPartnerInput, UserUncheckedUpdateWithoutDatesAsPartnerInput>
  }

  export type UserUpdateWithoutDatesAsPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUpdateManyWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutSchedulerNestedInput
  }

  export type UserUncheckedUpdateWithoutDatesAsPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    onboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    onboardingAnswers?: OnboardingAnswerUncheckedUpdateManyWithoutUserNestedInput
    likesGiven?: LikeUncheckedUpdateManyWithoutFromUserNestedInput
    likesReceived?: LikeUncheckedUpdateManyWithoutToUserNestedInput
    matchesAsUserA?: MatchUncheckedUpdateManyWithoutUserANestedInput
    matchesAsUserB?: MatchUncheckedUpdateManyWithoutUserBNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    trustScore?: TrustScoreUncheckedUpdateOneWithoutUserNestedInput
    behaviorLogs?: BehaviorLogUncheckedUpdateManyWithoutUserNestedInput
    riskAssessment?: RiskAssessmentUncheckedUpdateOneWithoutUserNestedInput
    reportsFiled?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    safetySignals?: SafetySignalUncheckedUpdateManyWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    intentHistory?: IntentHistoryUncheckedUpdateManyWithoutUserNestedInput
    blocksCreated?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksReceived?: BlockUncheckedUpdateManyWithoutBlockedUserNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutSchedulerNestedInput
  }

  export type OnboardingAnswerCreateManyUserInput = {
    id?: string
    questionId: string
    answer: JsonNullValueInput | InputJsonValue
    followUpCount?: number
    confidence?: number | null
    consistency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateManyFromUserInput = {
    id?: string
    toUserId: string
    createdAt?: Date | string
  }

  export type LikeCreateManyToUserInput = {
    id?: string
    fromUserId: string
    createdAt?: Date | string
  }

  export type MatchCreateManyUserAInput = {
    id?: string
    userBId: string
    overallScore?: number
    valuesScore?: number
    lifestyleScore?: number
    intentScore?: number
    communicationScore?: number
    logisticsScore?: number
    topReasons?: MatchCreatetopReasonsInput | string[]
    frictionPoint?: string | null
    confidenceLevel?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchCreateManyUserBInput = {
    id?: string
    userAId: string
    overallScore?: number
    valuesScore?: number
    lifestyleScore?: number
    intentScore?: number
    communicationScore?: number
    logisticsScore?: number
    topReasons?: MatchCreatetopReasonsInput | string[]
    frictionPoint?: string | null
    confidenceLevel?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    matchId: string
    receiverId: string
    content: string
    status?: $Enums.MessageStatus
    safetyScore?: number | null
    safetyFlags?: MessageCreatesafetyFlagsInput | string[]
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type MessageCreateManyReceiverInput = {
    id?: string
    matchId: string
    senderId: string
    content: string
    status?: $Enums.MessageStatus
    safetyScore?: number | null
    safetyFlags?: MessageCreatesafetyFlagsInput | string[]
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type BehaviorLogCreateManyUserInput = {
    id?: string
    behaviorType: $Enums.BehaviorType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    score?: number | null
    createdAt?: Date | string
  }

  export type ReportCreateManyReporterInput = {
    id?: string
    reportedUserId: string
    type: $Enums.ReportType
    description?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    reviewNotes?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReportCreateManyReportedUserInput = {
    id?: string
    reporterId: string
    type: $Enums.ReportType
    description?: string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    reviewNotes?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SafetySignalCreateManyUserInput = {
    id?: string
    signalType: $Enums.SafetySignalType
    verifiedAt?: Date | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type VerificationCreateManyUserInput = {
    id?: string
    type: string
    status?: string
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    verifiedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type IntentHistoryCreateManyUserInput = {
    id?: string
    statedIntent: $Enums.RelationshipIntent
    behaviorIntent?: $Enums.RelationshipIntent | null
    confidence?: number
    driftDetected?: boolean
    createdAt?: Date | string
  }

  export type BlockCreateManyBlockerInput = {
    id?: string
    blockedUserId: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type BlockCreateManyBlockedUserInput = {
    id?: string
    blockerId: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type ScheduledDateCreateManySchedulerInput = {
    id?: string
    matchId: string
    partnerId: string
    dateTime: Date | string
    location?: string | null
    isPublicPlace?: boolean
    safetyCheckIn?: boolean
    checkInTime?: Date | string | null
    locationSharing?: boolean
    safetyScore?: number | null
    concerns?: ScheduledDateCreateconcernsInput | string[]
    suggestions?: ScheduledDateCreatesuggestionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledDateCreateManyPartnerInput = {
    id?: string
    matchId: string
    schedulerId: string
    dateTime: Date | string
    location?: string | null
    isPublicPlace?: boolean
    safetyCheckIn?: boolean
    checkInTime?: Date | string | null
    locationSharing?: boolean
    safetyScore?: number | null
    concerns?: ScheduledDateCreateconcernsInput | string[]
    suggestions?: ScheduledDateCreatesuggestionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnboardingAnswerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: JsonNullValueInput | InputJsonValue
    followUpCount?: IntFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    consistency?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: OnboardingQuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type OnboardingAnswerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: JsonNullValueInput | InputJsonValue
    followUpCount?: IntFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    consistency?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingAnswerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: JsonNullValueInput | InputJsonValue
    followUpCount?: IntFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    consistency?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toUser?: UserUpdateOneRequiredWithoutLikesReceivedNestedInput
  }

  export type LikeUncheckedUpdateWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUser?: UserUpdateOneRequiredWithoutLikesGivenNestedInput
  }

  export type LikeUncheckedUpdateWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUpdateWithoutUserAInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    valuesScore?: IntFieldUpdateOperationsInput | number
    lifestyleScore?: IntFieldUpdateOperationsInput | number
    intentScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    logisticsScore?: IntFieldUpdateOperationsInput | number
    topReasons?: MatchUpdatetopReasonsInput | string[]
    frictionPoint?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userB?: UserUpdateOneRequiredWithoutMatchesAsUserBNestedInput
    messages?: MessageUpdateManyWithoutMatchNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutUserAInput = {
    id?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    valuesScore?: IntFieldUpdateOperationsInput | number
    lifestyleScore?: IntFieldUpdateOperationsInput | number
    intentScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    logisticsScore?: IntFieldUpdateOperationsInput | number
    topReasons?: MatchUpdatetopReasonsInput | string[]
    frictionPoint?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutMatchNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateManyWithoutUserAInput = {
    id?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    valuesScore?: IntFieldUpdateOperationsInput | number
    lifestyleScore?: IntFieldUpdateOperationsInput | number
    intentScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    logisticsScore?: IntFieldUpdateOperationsInput | number
    topReasons?: MatchUpdatetopReasonsInput | string[]
    frictionPoint?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUpdateWithoutUserBInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    valuesScore?: IntFieldUpdateOperationsInput | number
    lifestyleScore?: IntFieldUpdateOperationsInput | number
    intentScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    logisticsScore?: IntFieldUpdateOperationsInput | number
    topReasons?: MatchUpdatetopReasonsInput | string[]
    frictionPoint?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userA?: UserUpdateOneRequiredWithoutMatchesAsUserANestedInput
    messages?: MessageUpdateManyWithoutMatchNestedInput
    scheduledDates?: ScheduledDateUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutUserBInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    valuesScore?: IntFieldUpdateOperationsInput | number
    lifestyleScore?: IntFieldUpdateOperationsInput | number
    intentScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    logisticsScore?: IntFieldUpdateOperationsInput | number
    topReasons?: MatchUpdatetopReasonsInput | string[]
    frictionPoint?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutMatchNestedInput
    scheduledDates?: ScheduledDateUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateManyWithoutUserBInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    valuesScore?: IntFieldUpdateOperationsInput | number
    lifestyleScore?: IntFieldUpdateOperationsInput | number
    intentScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    logisticsScore?: IntFieldUpdateOperationsInput | number
    topReasons?: MatchUpdatetopReasonsInput | string[]
    frictionPoint?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    safetyFlags?: MessageUpdatesafetyFlagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    match?: MatchUpdateOneRequiredWithoutMessagesNestedInput
    receiver?: UserUpdateOneRequiredWithoutMessagesReceivedNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    safetyFlags?: MessageUpdatesafetyFlagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    safetyFlags?: MessageUpdatesafetyFlagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    safetyFlags?: MessageUpdatesafetyFlagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    match?: MatchUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
  }

  export type MessageUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    safetyFlags?: MessageUpdatesafetyFlagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    safetyFlags?: MessageUpdatesafetyFlagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BehaviorLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    behaviorType?: EnumBehaviorTypeFieldUpdateOperationsInput | $Enums.BehaviorType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    behaviorType?: EnumBehaviorTypeFieldUpdateOperationsInput | $Enums.BehaviorType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    behaviorType?: EnumBehaviorTypeFieldUpdateOperationsInput | $Enums.BehaviorType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedUser?: UserUpdateOneRequiredWithoutReportsReceivedNestedInput
  }

  export type ReportUncheckedUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutReportedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportsFiledNestedInput
  }

  export type ReportUncheckedUpdateWithoutReportedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutReportedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetySignalUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    signalType?: EnumSafetySignalTypeFieldUpdateOperationsInput | $Enums.SafetySignalType
    verifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetySignalUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    signalType?: EnumSafetySignalTypeFieldUpdateOperationsInput | $Enums.SafetySignalType
    verifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetySignalUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    signalType?: EnumSafetySignalTypeFieldUpdateOperationsInput | $Enums.SafetySignalType
    verifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    statedIntent?: EnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent
    behaviorIntent?: NullableEnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent | null
    confidence?: FloatFieldUpdateOperationsInput | number
    driftDetected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    statedIntent?: EnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent
    behaviorIntent?: NullableEnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent | null
    confidence?: FloatFieldUpdateOperationsInput | number
    driftDetected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    statedIntent?: EnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent
    behaviorIntent?: NullableEnumRelationshipIntentFieldUpdateOperationsInput | $Enums.RelationshipIntent | null
    confidence?: FloatFieldUpdateOperationsInput | number
    driftDetected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUpdateWithoutBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedUser?: UserUpdateOneRequiredWithoutBlocksReceivedNestedInput
  }

  export type BlockUncheckedUpdateWithoutBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedUserId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyWithoutBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedUserId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUpdateWithoutBlockedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocker?: UserUpdateOneRequiredWithoutBlocksCreatedNestedInput
  }

  export type BlockUncheckedUpdateWithoutBlockedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyWithoutBlockedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledDateUpdateWithoutSchedulerInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublicPlace?: BoolFieldUpdateOperationsInput | boolean
    safetyCheckIn?: BoolFieldUpdateOperationsInput | boolean
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    concerns?: ScheduledDateUpdateconcernsInput | string[]
    suggestions?: ScheduledDateUpdatesuggestionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutScheduledDatesNestedInput
    partner?: UserUpdateOneRequiredWithoutDatesAsPartnerNestedInput
  }

  export type ScheduledDateUncheckedUpdateWithoutSchedulerInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublicPlace?: BoolFieldUpdateOperationsInput | boolean
    safetyCheckIn?: BoolFieldUpdateOperationsInput | boolean
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    concerns?: ScheduledDateUpdateconcernsInput | string[]
    suggestions?: ScheduledDateUpdatesuggestionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledDateUncheckedUpdateManyWithoutSchedulerInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublicPlace?: BoolFieldUpdateOperationsInput | boolean
    safetyCheckIn?: BoolFieldUpdateOperationsInput | boolean
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    concerns?: ScheduledDateUpdateconcernsInput | string[]
    suggestions?: ScheduledDateUpdatesuggestionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledDateUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublicPlace?: BoolFieldUpdateOperationsInput | boolean
    safetyCheckIn?: BoolFieldUpdateOperationsInput | boolean
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    concerns?: ScheduledDateUpdateconcernsInput | string[]
    suggestions?: ScheduledDateUpdatesuggestionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutScheduledDatesNestedInput
    scheduler?: UserUpdateOneRequiredWithoutScheduledDatesNestedInput
  }

  export type ScheduledDateUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    schedulerId?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublicPlace?: BoolFieldUpdateOperationsInput | boolean
    safetyCheckIn?: BoolFieldUpdateOperationsInput | boolean
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    concerns?: ScheduledDateUpdateconcernsInput | string[]
    suggestions?: ScheduledDateUpdatesuggestionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledDateUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    schedulerId?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublicPlace?: BoolFieldUpdateOperationsInput | boolean
    safetyCheckIn?: BoolFieldUpdateOperationsInput | boolean
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    concerns?: ScheduledDateUpdateconcernsInput | string[]
    suggestions?: ScheduledDateUpdatesuggestionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoCreateManyProfileInput = {
    id?: string
    url: string
    isMain?: boolean
    isVerified?: boolean
    order?: number
    createdAt?: Date | string
  }

  export type ProfilePromptCreateManyProfileInput = {
    id?: string
    question: string
    answer: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhotoUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    isMain?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfilePromptUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfilePromptUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfilePromptUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingAnswerCreateManyQuestionInput = {
    id?: string
    userId: string
    answer: JsonNullValueInput | InputJsonValue
    followUpCount?: number
    confidence?: number | null
    consistency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OnboardingAnswerUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: JsonNullValueInput | InputJsonValue
    followUpCount?: IntFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    consistency?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOnboardingAnswersNestedInput
  }

  export type OnboardingAnswerUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answer?: JsonNullValueInput | InputJsonValue
    followUpCount?: IntFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    consistency?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingAnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answer?: JsonNullValueInput | InputJsonValue
    followUpCount?: IntFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    consistency?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyMatchInput = {
    id?: string
    senderId: string
    receiverId: string
    content: string
    status?: $Enums.MessageStatus
    safetyScore?: number | null
    safetyFlags?: MessageCreatesafetyFlagsInput | string[]
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type ScheduledDateCreateManyMatchInput = {
    id?: string
    schedulerId: string
    partnerId: string
    dateTime: Date | string
    location?: string | null
    isPublicPlace?: boolean
    safetyCheckIn?: boolean
    checkInTime?: Date | string | null
    locationSharing?: boolean
    safetyScore?: number | null
    concerns?: ScheduledDateCreateconcernsInput | string[]
    suggestions?: ScheduledDateCreatesuggestionsInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    safetyFlags?: MessageUpdatesafetyFlagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    receiver?: UserUpdateOneRequiredWithoutMessagesReceivedNestedInput
  }

  export type MessageUncheckedUpdateWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    safetyFlags?: MessageUpdatesafetyFlagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUncheckedUpdateManyWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    safetyFlags?: MessageUpdatesafetyFlagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScheduledDateUpdateWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublicPlace?: BoolFieldUpdateOperationsInput | boolean
    safetyCheckIn?: BoolFieldUpdateOperationsInput | boolean
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    concerns?: ScheduledDateUpdateconcernsInput | string[]
    suggestions?: ScheduledDateUpdatesuggestionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduler?: UserUpdateOneRequiredWithoutScheduledDatesNestedInput
    partner?: UserUpdateOneRequiredWithoutDatesAsPartnerNestedInput
  }

  export type ScheduledDateUncheckedUpdateWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    schedulerId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublicPlace?: BoolFieldUpdateOperationsInput | boolean
    safetyCheckIn?: BoolFieldUpdateOperationsInput | boolean
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    concerns?: ScheduledDateUpdateconcernsInput | string[]
    suggestions?: ScheduledDateUpdatesuggestionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledDateUncheckedUpdateManyWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    schedulerId?: StringFieldUpdateOperationsInput | string
    partnerId?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isPublicPlace?: BoolFieldUpdateOperationsInput | boolean
    safetyCheckIn?: BoolFieldUpdateOperationsInput | boolean
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationSharing?: BoolFieldUpdateOperationsInput | boolean
    safetyScore?: NullableIntFieldUpdateOperationsInput | number | null
    concerns?: ScheduledDateUpdateconcernsInput | string[]
    suggestions?: ScheduledDateUpdatesuggestionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileCountOutputTypeDefaultArgs instead
     */
    export type ProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OnboardingQuestionCountOutputTypeDefaultArgs instead
     */
    export type OnboardingQuestionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OnboardingQuestionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatchCountOutputTypeDefaultArgs instead
     */
    export type MatchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhotoDefaultArgs instead
     */
    export type PhotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhotoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfilePromptDefaultArgs instead
     */
    export type ProfilePromptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfilePromptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OnboardingQuestionDefaultArgs instead
     */
    export type OnboardingQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OnboardingQuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OnboardingAnswerDefaultArgs instead
     */
    export type OnboardingAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OnboardingAnswerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LikeDefaultArgs instead
     */
    export type LikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LikeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatchDefaultArgs instead
     */
    export type MatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrustScoreDefaultArgs instead
     */
    export type TrustScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrustScoreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BehaviorLogDefaultArgs instead
     */
    export type BehaviorLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BehaviorLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RiskAssessmentDefaultArgs instead
     */
    export type RiskAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RiskAssessmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SafetySignalDefaultArgs instead
     */
    export type SafetySignalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SafetySignalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationDefaultArgs instead
     */
    export type VerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockDefaultArgs instead
     */
    export type BlockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IntentHistoryDefaultArgs instead
     */
    export type IntentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IntentHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduledDateDefaultArgs instead
     */
    export type ScheduledDateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduledDateDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}